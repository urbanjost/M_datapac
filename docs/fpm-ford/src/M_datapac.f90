module M_datapac
implicit none
private
public :: autoco
public :: betran
public :: bincdf
public :: binppf
public :: binran
public :: caucdf
public :: caupdf
public :: cauplt
public :: cauppf
public :: cauran
public :: causf
public :: chscdf
public :: chsplt
public :: chsppf
public :: chsran
public :: code
public :: copy
public :: corr
public :: count
public :: decomp
public :: define
public :: delete
public :: demod
public :: dexcdf
public :: dexpdf
public :: dexplt
public :: dexppf
public :: dexran
public :: dexsf
public :: discr2
public :: discr3
public :: discre
public :: dot
public :: ev1cdf
public :: ev1plt
public :: ev1ppf
public :: ev1ran
public :: ev2cdf
public :: ev2plt
public :: ev2ppf
public :: ev2ran
public :: expcdf
public :: exppdf
public :: expplt
public :: expppf
public :: expran
public :: expsf
public :: extrem
public :: fcdf
public :: fourie
public :: fran
public :: freq
public :: gamcdf
public :: gamplt
public :: gamppf
public :: gamran
public :: geocdf
public :: geoplt
public :: geoppf
public :: georan
public :: hfncdf
public :: hfnplt
public :: hfnppf
public :: hfnran
public :: hist
public :: invxwx
public :: lamcdf
public :: lampdf
public :: lamplt
public :: lamppf
public :: lamran
public :: lamsf
public :: lgncdf
public :: lgnplt
public :: lgnppf
public :: lgnran
public :: loc
public :: logcdf
public :: logpdf
public :: logplt
public :: logppf
public :: logran
public :: logsf
public :: max
public :: mean
public :: median
public :: midm
public :: midr
public :: min
public :: move
public :: nbcdf
public :: nbppf
public :: nbran
public :: norcdf
public :: norout
public :: norpdf
public :: norplt
public :: norppf
public :: norran
public :: norsf
public :: parcdf
public :: parplt
public :: parppf
public :: parran
public :: plot10
public :: plot6
public :: plot7
public :: plot8
public :: plot9
public :: plotc
public :: plotco
public :: plotct
public :: plot
public :: plotsc
public :: plots
public :: plotsp
public :: plotst
public :: plott
public :: plotu
public :: plotx
public :: plotxt
public :: plotxx
public :: pltsct
public :: pltxxt
public :: poicdf
public :: poiplt
public :: poippf
public :: poiran
public :: poly
public :: propor
public :: range
public :: rank
public :: ranper
public :: read
public :: readg
public :: relsd
public :: replac
public :: retain
public :: runs
public :: sampp
public :: scale
public :: sd
public :: skipr
public :: sortc
public :: sort
public :: sortp
public :: spcorr
public :: stmom3
public :: stmom4
public :: subse1
public :: subse2
public :: subset
public :: tail
public :: tcdf
public :: time
public :: tol
public :: tplt
public :: tppf
public :: tran
public :: trim
public :: unicdf
public :: unimed
public :: unipdf
public :: uniplt
public :: unippf
public :: uniran
public :: unisf
public :: var
public :: weib
public :: weicdf
public :: weiplt
public :: weippf
public :: weiran
public :: wind
public :: write
contains
!*==autoco.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE AUTOCO(X,N,Iwrite,Xautoc)
      IMPLICIT NONE
!*--AUTOCO4
!*** Start of declarations inserted by SPAG
      REAL an , hold , sum1 , sum2 , sum3 , X , Xautoc , xbar , xbar1 , xbar2
      INTEGER i , ip1 , ipr , Iwrite , N , nm1
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT AUTOCO
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE AUTOCORRELATION COEFFICIENT
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE SAMPLE AUTOCORRELATION COEFFICIENT =  THE CORRELATION
!              BETWEEN X(I) AND X(I+1) OVER THE ENTIRE SAMPLE.
!              THE AUTOCORRELATION COEFFICIENT COEFFICIENT WILL BE A
!              SINGLE PRECISION VALUE BETWEEN -1.0 AND 1.0
!              (INCLUSIVELY).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE AUTOCORRELATION COEFFICIENT
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE AUTOCORRELATION COEFFICIENT
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XAUTOC = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE AUTOCORRELATION
!                                COEFFICIENT.
!                                THIS SINGLE PRECISION VALUE
!                                WILL BE BETWEEN -1.0 AND 1.0
!                                (INCLUSIVELY).
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE AUTOCORRELATION COEFFICIENT.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JENKINS AND WATTS, SPECTRAL ANALYSIS AND
!                 ITS APPLICATIONS, 1968, PAGES 5, 182.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION (714)
!                 NATIONAL BUREAU OF STANDARDS
!                 GAITHERSBURG, MD  20899
!                 PHONE:  301-921-3651
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      an = N
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE AUTOCO SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE AUTO&
     &CO SUBROUTINE HAS THE VALUE 1 *****')
            Xautoc = 0.0
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE AUTOCO SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            Xautoc = 0.0
         ENDIF
         GOTO 100
!
!-----START POINT-----------------------------------------------------
!
 50      xbar = 0.0
         DO i = 1 , N
            xbar = xbar + X(i)
         ENDDO
         xbar1 = xbar - X(N)
         xbar1 = xbar1/(an-1.0)
         xbar2 = xbar - X(1)
         xbar2 = xbar2/(an-1.0)
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         nm1 = N - 1
         DO i = 1 , nm1
            ip1 = i + 1
            sum1 = sum1 + (X(i)-xbar1)*(X(ip1)-xbar2)
            sum2 = sum2 + (X(i)-xbar1)**2
            sum3 = sum3 + (X(ip1)-xbar2)**2
         ENDDO
         Xautoc = sum1/(SQRT(sum2*sum3))
      ENDIF
!
 100  IF ( Iwrite==0 ) RETURN
      WRITE (ipr,99005)
99005 FORMAT (' ')
      WRITE (ipr,99006) N , Xautoc
99006 FORMAT (' ',                                                      &
     &        'THE LINEAR AUTOCORRELATION COEFFICIENT OF THE SET OF ',  &
     &        I6,' OBSERVATIONS IS ',F14.6)
      END SUBROUTINE AUTOCO
!*==betran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE BETRAN(N,Alpha,Beta,Iseed,X)
      IMPLICIT NONE
!*--BETRAN135
!*** Start of declarations inserted by SPAG
      REAL a1 , a2 , Alpha , arg , athird , b1 , b2 , Beta , funct ,    &
     &     sqrt3 , term , u , X , xg , xg01 , xg02 , xg1 , xg2 , xn(1) ,   &
     &     xn01
      REAL xn02
      INTEGER i , ipr , Iseed , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT BETRAN
!     ***** STILL NEEDS ALGORITHM WORK ******
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE BETA DISTRIBUTION
!          WITH SINGLE PRECISION SHAPE
!          PARAMETERS = ALPHA AND BETA.
!              THE PROTOTYPE BETA DISTRIBUTION USED
!              HEREIN HAS MEAN = ALPHA/(ALPHA+BETA)
!              AND STANDARD DEVIATION =
!              SQRT((ALPHA*BETA) / ((ALPHA+BETA)**2)*(ALPHA+BETA+1))
!              THIS DISTRIBUTION IS DEFINED FOR ALL X
!              BETWEEN 0.0 (INCLUSIVELY) AND 1.0 (INCLUSIVELY).
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/CONSTANT) * X**(ALPHA-1) * (1.0-X)**(BETA-1)
!              WHERE THE CONSTANT = THE BETA FUNCTION EVALUATED
!              AT THE VALUES ALPHA AND BETA.
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!                     --ALPHA  = THE SINGLE PRECISION VALUE OF THE
!                                FIRST  SHAPE PARAMETER.
!                                ALPHA SHOULD BE GREATER THAN
!                                OR EQUAL TO 1.0.
!                     --BETA   = THE SINGLE PRECISION VALUE OF THE
!                                SECOND SHAPE PARAMETER.
!                                BETA  SHOULD BE GREATER THAN
!                                OR EQUAL TO 1.0.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE BETA DISTRIBUTION
!             WITH SHAPE PARAMETER VALUES = ALPHA AND BETA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!                 --ALPHA SHOULD BE GREATER THAN
!                   OR EQUAL TO 1.0.
!                 --BETA  SHOULD BE GREATER THAN
!                   OR EQUAL TO 1.0.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN, NORRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     REFERENCES--GREENWOOD, 'A FAST GENERATOR FOR
!                 BETA-DISTRIBUTED RANDOM VARIABLES',
!                 COMPSTAT 1974, PROCEEDINGS IN
!                 COMPUTATIONAL STATISTICS, VIENNA,
!                 SEPTEMBER, 1974, PAGES 19-27.
!               --TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 24-27.
!               --HAMMERSLEY AND HANDSCOMB, MONTE CARLO METHODS,
!                 1964, PAGES 36-37.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 37-56.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 30-35.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 952.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLARITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82.3
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --JUNE      1978.
!     UPDATED         --DECEMBER  1981.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
!
      DIMENSION u(10)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
!-----DATA STATEMENTS-------------------------------------------------
!
      DATA athird/0.33333333/
      DATA sqrt3/1.73205081/
!
      ipr = 6
!
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE BETRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( Alpha<1.0 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE BETRAN SUBROU&
     &TINE IS SMALLER THAN 1.0 *****')
         WRITE (ipr,99005) Alpha
         RETURN
      ELSEIF ( Beta<1.0 ) THEN
         WRITE (ipr,99004)
99004    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE BETRAN SUBROU&
     &TINE IS SMALLER THAN 1.0 *****')
         WRITE (ipr,99005) Beta
         RETURN
      ELSE
!
!     GENERATE N BETA RANDOM NUMBERS
!     BY USING THE FACT THAT
!     IF X1 IS A GAMMA VARIATE WITH PARAMETER ALPHA
!     AND IF X2 IS A GAMMA VARIATE WITH PARAMETER BETA,
!     THEN THE RATIO X1/(X1+X2) IS A BETA VARIATE
!     WITH PARAMETERS ALPHA AND BETA.
!
!     TO GENERATE N GAMMA DISTRIBUTION RANDOM NUMBERS,
!     USE GREENWOOD'S REJECTION ALGORITHM--
!     1) GENERATE A NORMAL RANDOM NUMBER;
!     2) TRANSFORM THE NORMAL VARIATE TO AN APPROXIMATE
!        GAMMA VARIATE USING THE WILSON-HILFERTY
!        APPROXIMATION (SEE THE JOHNSON AND KOTZ
!        REFERENCE, PAGE 176);
!     3) FORM THE REJECTION FUNCTION VALUE, BASED
!        ON THE PROBABILITY DENSITY FUNCTION VALUE
!        OF THE ACTUAL DISTRIBUTION OF THE PSEUDO-GAMMA
!        VARIATE, AND THE PROBABILITY DENSITY FUNCTION VALUE
!        OF A TRUE GAMMA VARIATE.
!     4) GENERATE A UNIFORM RANDOM NUMBER;
!     5) IF THE UNIFORM RANDOM NUMBER IS LESS THAN
!        THE REJECTION FUNCTION VALUE, THEN ACCEPT
!        THE PSEUDO-RANDOM NUMBER AS A GAMMA VARIATE;
!        IF THE UNIFORM RANDOM NUMBER IS LARGER THAN
!        THE REJECTION FUNCTION VALUE, THEN REJECT
!        THE PSEUDO-RANDOM NUMBER AS A GAMMA VARIATE.
!
         a1 = 1.0/(9.0*Alpha)
         b1 = SQRT(a1)
         xn01 = -sqrt3 + b1
         xg01 = Alpha*(1.0-a1+b1*xn01)**3
         a2 = 1.0/(9.0*Beta)
         b2 = SQRT(a2)
         xn02 = -sqrt3 + b2
         xg02 = Beta*(1.0-a2+b2*xn02)**3
!
         DO i = 1 , N
            DO
!
               CALL NORRAN(1,Iseed,xn(1))
               xg = Alpha*(1.0-a1+b1*xn(1))**3
               IF ( xg>=0.0 ) THEN
                  term = (xg/xg01)**(Alpha-athird)
                  arg = 0.5*xn(1)*xn(1) - xg - 0.5*xn01*xn01 + xg01
                  funct = term*EXP(arg)
                  CALL UNIRAN(1,Iseed,u)
                  IF ( u(1)<=funct ) THEN
                     xg1 = xg
                     DO
!
                        CALL NORRAN(1,Iseed,xn(1))
                        xg = Beta*(1.0-a2+b2*xn(1))**3
                        IF ( xg>=0.0 ) THEN
                           term = (xg/xg02)**(Beta-athird)
                           arg = 0.5*xn(1)*xn(1) - xg - 0.5*xn02*xn02 + xg02
                           funct = term*EXP(arg)
                           CALL UNIRAN(1,Iseed,u)
                           IF ( u(1)<=funct ) THEN
                              xg2 = xg
!
                              X(i) = xg1/(xg1+xg2)
                              GOTO 50
                           ENDIF
                        ENDIF
                     ENDDO
                  ENDIF
               ENDIF
            ENDDO
!
 50      ENDDO
      ENDIF
99005 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
      END SUBROUTINE BETRAN
!*==bincdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE BINCDF(X,P,N,Cdf)
      IMPLICIT NONE
!*--BINCDF356
!*** Start of declarations inserted by SPAG
      REAL an , Cdf , del , fintx , P , X
      INTEGER i , ievodd , iflag1 , iflag2 , imax , imin , intx , ipr , &
     &        N , nu1 , nu2
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT BINCDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE AT THE SINGLE PRECISION VALUE X
!              FOR THE BINOMIAL DISTRIBUTION
!              WITH SINGLE PRECISION 'BERNOULLI PROBABILITY'
!              PARAMETER = P,
!              AND INTEGER 'NUMBER OF BERNOULLI TRIALS'
!              PARAMETER = N.
!              THE BINOMIAL DISTRIBUTION USED
!              HEREIN HAS MEAN = N*P
!              AND STANDARD DEVIATION = SQRT(N*P*(1-P)).
!              THIS DISTRIBUTION IS DEFINED FOR ALL
!              DISCRETE INTEGER X BETWEEN 0 (INCLUSIVELY)
!              AND N (INCLUSIVELY).
!              THIS DISTRIBUTION HAS THE PROBABILITY FUNCTION
!              F(X) = C(N,X) * P**X * (1-P)**(N-X).
!              WHERE C(N,X) IS THE COMBINATORIAL FUNCTION
!              EQUALING THE NUMBER OF COMBINATIONS OF N ITEMS
!              TAKEN X AT A TIME.
!              THE BINOMIAL DISTRIBUTION IS THE
!              DISTRIBUTION OF THE NUMBER OF
!              SUCCESSES IN N BERNOULLI (0,1)
!              TRIALS WHERE THE PROBABILITY OF SUCCESS
!              IN A SINGLE TRIAL = P.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE
!                                AT WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!                                X SHOULD BE INTEGRAL-VALUED,
!                                AND BETWEEN 0.0 (INCLUSIVELY)
!                                AND N (INCLUSIVELY).
!                     --P      = THE SINGLE PRECISION VALUE
!                                OF THE 'BERNOULLI PROBABILITY'
!                                PARAMETER FOR THE BINOMIAL
!                                DISTRIBUTION.
!                                P SHOULD BE BETWEEN
!                                0.0 (EXCLUSIVELY) AND
!                                1.0 (EXCLUSIVELY).
!                     --N      = THE INTEGER VALUE
!                                OF THE 'NUMBER OF BERNOULLI TRIALS'
!                                PARAMETER.
!                                N SHOULD BE A POSITIVE INTEGER.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF
!             FOR THE BINOMIAL DISTRIBUTION
!             WITH 'BERNOULLI PROBABILITY' PARAMETER = P
!             AND 'NUMBER OF BERNOULLI TRIALS' PARAMETER = N.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--X SHOULD BE INTEGRAL-VALUED,
!                   AND BETWEEN 0.0 (INCLUSIVELY)
!                   AND N (INCLUSIVELY).
!                 --P SHOULD BE BETWEEN 0.0 (EXCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!                 --N SHOULD BE A POSITIVE INTEGER.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--DSQRT, DATAN.
!     MODE OF INTERNAL OPERATIONS--DOUBLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--NOTE THAT EVEN THOUGH THE INPUT
!              TO THIS CUMULATIVE
!              DISTRIBUTION FUNCTION SUBROUTINE
!              FOR THIS DISCRETE DISTRIBUTION
!              SHOULD (UNDER NORMAL CIRCUMSTANCES) BE A
!              DISCRETE INTEGER VALUE,
!              THE INPUT VARIABLE X IS SINGLE
!              PRECISION IN MODE.
!              X HAS BEEN SPECIFIED AS SINGLE
!              PRECISION SO AS TO CONFORM WITH THE DATAPAC
!              CONVENTION THAT ALL INPUT ****DATA****
!              (AS OPPOSED TO SAMPLE SIZE, FOR EXAMPLE)
!              VARIABLES TO ALL
!              DATAPAC SUBROUTINES ARE SINGLE PRECISION.
!              THIS CONVENTION IS BASED ON THE BELIEF THAT
!              1) A MIXTURE OF MODES (FLOATING POINT
!              VERSUS INTEGER) IS INCONSISTENT AND
!              AN UNNECESSARY COMPLICATION
!              IN A DATA ANALYSIS; AND
!              2) FLOATING POINT MACHINE ARITHMETIC
!              (AS OPPOSED TO INTEGER ARITHMETIC)
!              IS THE MORE NATURAL MODE FOR DOING
!              DATA ANALYSIS.
!     REFERENCES--HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGE 38.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 945, FORMULAE 26.5.24 AND
!                 26.5.28, AND PAGE 929.
!               --JOHNSON AND KOTZ, DISCRETE
!                 DISTRIBUTIONS, 1969, PAGES 50-86,
!                 ESPECIALLY PAGES 63-64.
!               --FELLER, AN INTRODUCTION TO PROBABILITY
!                 THEORY AND ITS APPLICATIONS, VOLUME 1,
!                 EDITION 2, 1957, PAGES 135-142.
!               --KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGES 120-125.
!               --MOOD AND GRABLE, INTRODUCTION TO THE THEORY
!                 OF STATISTICS, EDITION 2, 1963, PAGES 64-69.
!               --OWEN, HANDBOOK OF STATISTICAL
!                 TABLES, 1962, PAGES 264-272.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --MAY       1977.
!
!---------------------------------------------------------------------
!
      DOUBLE PRECISION dx , pi , anu1 , anu2 , z , sum , term , ai ,    &
     &                 coef1 , coef2 , arg
      DOUBLE PRECISION coef
      DOUBLE PRECISION theta , sinth , costh , a , b
      DOUBLE PRECISION DSQRT , DATAN
      DATA pi/3.14159265358979D0/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      an = N
      IF ( P<0.0 .OR. P>1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE BINCDF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99006) P
         Cdf = 0.0
         RETURN
      ELSEIF ( N<1 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE BINCDF SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99003) N
99003    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         Cdf = 0.0
         RETURN
      ELSEIF ( X<0.0 .OR. X>an ) THEN
         WRITE (ipr,99004) N
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE BINC&
     &DF SUBROUTINE IS OUTSIDE THE USUAL (0,N) = (0,',I7,',INTERVAL *')
         WRITE (ipr,99006) X
         IF ( X<0.0 ) Cdf = 0.0
         IF ( X>an ) Cdf = 1.0
         RETURN
      ELSE
         intx = X + 0.0001
         fintx = intx
         del = X - fintx
         IF ( del<0.0 ) del = -del
         IF ( del>0.001 ) THEN
            WRITE (ipr,99005)
99005       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE BINC&
     &DF SUBROUTINE IS NON-INTEGRAL *****')
            WRITE (ipr,99006) X
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
!     TREAT IMMEDIATELY THE SPECIAL CASE OF X = N,
!     IN WHICH CASE CDF = 1.0.
!     ALSO TREAT IMMEDIATELY THE SPECIAL CASE OF P = 0.0
!     IN WHICH CASE CDF = 1.0 FOR ALL X.
!     THIRDLY, TREAT THE SPECIAL CASE IN WHICH P = 1.0
!     IN WHICH CASE CDF = 0.0 FOR ALL X SMALLER THAN N
!     AND CDF = 1.0 FOR ALL X EQUAL TO OR LARGER
!     THAN N.
!
         intx = X + 0.0001
         Cdf = 1.0
         IF ( intx==N ) RETURN
         IF ( P==0.0 ) RETURN
         IF ( P==1.0 .AND. intx>=N ) RETURN
         IF ( P==1.0 .AND. intx<N ) Cdf = 0.0
         IF ( P==1.0 .AND. intx<N ) RETURN
!
!     EXPRESS THE BINOMIAL CUMULATIVE DISTRIBUTION
!     FUNCTION IN TERMS OF THE EQUIVALENT F
!     CUMULATIVE DISTRIBUTION FUNCTION,
!     AND THEN EVALUATE THE LATTER.
!
         an = N
         dx = (P/(1.0-P))*((an-X)/(X+1.0))
         nu1 = 2.0*(X+1.0) + 0.1
         nu2 = 2.0*(an-X) + 0.1
         anu1 = nu1
         anu2 = nu2
         z = anu2/(anu2+anu1*dx)
!
!     DETERMINE IF NU1 AND NU2 ARE EVEN OR ODD
!
         iflag1 = nu1 - 2*(nu1/2)
         iflag2 = nu2 - 2*(nu2/2)
         IF ( iflag1==0 ) THEN
!
!     DO THE NU1 EVEN AND NU2 EVEN OR ODD CASE
!
            sum = 0.0D0
            term = 1.0D0
            imax = (nu1-2)/2
            IF ( imax>0 ) THEN
               DO i = 1 , imax
                  ai = i
                  coef1 = 2.0D0*(ai-1.0D0)
                  coef2 = 2.0D0*ai
                  term = term*((anu2+coef1)/coef2)*(1.0D0-z)
                  sum = sum + term
               ENDDO
            ENDIF
!
            sum = sum + 1.0D0
            sum = (z**(anu2/2.0D0))*sum
            Cdf = sum
            RETURN
         ELSEIF ( iflag2==0 ) THEN
!
!     DO THE NU1 ODD AND NU2 EVEN CASE
!
            sum = 0.0D0
            term = 1.0D0
            imax = (nu2-2)/2
            IF ( imax>0 ) THEN
               DO i = 1 , imax
                  ai = i
                  coef1 = 2.0D0*(ai-1.0D0)
                  coef2 = 2.0D0*ai
                  term = term*((anu1+coef1)/coef2)*z
                  sum = sum + term
               ENDDO
            ENDIF
!
            sum = sum + 1.0D0
            Cdf = 1.0D0 - ((1.0D0-z)**(anu1/2.0D0))*sum
            RETURN
         ELSE
!
!     DO THE NU1 ODD AND NU2 ODD CASE
!
            sum = 0.0D0
            term = 1.0D0
            arg = DSQRT((anu1/anu2)*dx)
            theta = DATAN(arg)
            sinth = arg/DSQRT(1.0D0+arg*arg)
            costh = 1.0D0/DSQRT(1.0D0+arg*arg)
            IF ( nu2/=1 ) THEN
               IF ( nu2/=3 ) THEN
                  imax = nu2 - 2
                  DO i = 3 , imax , 2
                     ai = i
                     coef1 = ai - 1.0D0
                     coef2 = ai
                     term = term*(coef1/coef2)*(costh*costh)
                     sum = sum + term
                  ENDDO
               ENDIF
!
               sum = sum + 1.0D0
               sum = sum*sinth*costh
            ENDIF
!
            a = (2.0D0/pi)*(theta+sum)
            sum = 0.0D0
            term = 1.0D0
            IF ( nu1==1 ) b = 0.0D0
            IF ( nu1/=1 ) THEN
               IF ( nu1/=3 ) THEN
                  imax = nu1 - 3
                  DO i = 1 , imax , 2
                     ai = i
                     coef1 = ai
                     coef2 = ai + 2.0D0
                     term = term*((anu2+coef1)/coef2)*(sinth*sinth)
                     sum = sum + term
                  ENDDO
               ENDIF
!
               sum = sum + 1.0D0
               sum = sum*sinth*(costh**N)
               coef = 1.0D0
               ievodd = nu2 - 2*(nu2/2)
               imin = 3
               IF ( ievodd==0 ) imin = 2
               IF ( imin<=nu2 ) THEN
                  DO i = imin , nu2 , 2
                     ai = i
                     coef = ((ai-1.0D0)/ai)*coef
                  ENDDO
               ENDIF
!
               coef = coef*anu2
               IF ( ievodd/=0 ) coef = coef*(2.0D0/pi)
!
               b = coef*sum
            ENDIF
!
            Cdf = 1.0D0 - (a-b)
         ENDIF
      ENDIF
99006 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
      END SUBROUTINE BINCDF
!*==binppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE BINPPF(P,Ppar,N,Ppf)
      IMPLICIT NONE
!*--BINPPF673
!*** Start of declarations inserted by SPAG
      REAL amean , an , P , p0 , p1 , p2 , pf0 , Ppar , Ppf , qfn , sd ,&
     &     x0 , x1 , x2 , zppf
      INTEGER i , ipr , isd , ix0 , ix0p1 , ix1 , ix2 , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT BINPPF

!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE AT THE SINGLE PRECISION VALUE P
!              FOR THE BINOMIAL DISTRIBUTION
!              WITH SINGLE PRECISION 'BERNOULLI PROBABILITY'
!              PARAMETER = PPAR,
!              AND INTEGER 'NUMBER OF BERNOULLI TRIALS'
!              PARAMETER = N.
!              THE BINOMIAL DISTRIBUTION USED
!              HEREIN HAS MEAN = N*PPAR
!              AND STANDARD DEVIATION = SQRT(N*PPAR*(1-PPAR)).
!              THIS DISTRIBUTION IS DEFINED FOR ALL
!              DISCRETE INTEGER X BETWEEN 0 (INCLUSIVELY)
!              AND N (INCLUSIVELY).
!              THIS DISTRIBUTION HAS THE PROBABILITY FUNCTION
!              F(X) = C(N,X) * PPAR**X * (1-PPAR)**(N-X).
!              WHERE C(N,X) IS THE COMBINATORIAL FUNCTION
!              EQUALING THE NUMBER OF COMBINATIONS OF N ITEMS
!              TAKEN X AT A TIME.
!              THE BINOMIAL DISTRIBUTION IS THE
!              DISTRIBUTION OF THE NUMBER OF
!              SUCCESSES IN N BERNOULLI (0,1)
!              TRIALS WHERE THE PROBABILITY OF SUCCESS
!              IN A SINGLE TRIAL = PPAR.
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 (INCLUSIVELY)
!                                AND 1.0 (INCLUSIVELY))
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!                     --PPAR   = THE SINGLE PRECISION VALUE
!                                OF THE 'BERNOULLI PROBABILITY'
!                                PARAMETER FOR THE BINOMIAL
!                                DISTRIBUTION.
!                                PPAR SHOULD BE BETWEEN
!                                0.0 (EXCLUSIVELY) AND
!                                1.0 (EXCLUSIVELY).
!                     --N      = THE INTEGER VALUE
!                                OF THE 'NUMBER OF BERNOULLI TRIALS'
!                                PARAMETER.
!                                N SHOULD BE A POSITIVE INTEGER.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT  .
!             FUNCTION VALUE PPF
!             FOR THE BINOMIAL DISTRIBUTION
!             WITH 'BERNOULLI PROBABILITY' PARAMETER = PPAR
!             AND 'NUMBER OF BERNOULLI TRIALS' PARAMETER = N.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--PPAR SHOULD BE BETWEEN 0.0 (EXCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!                 --N SHOULD BE A POSITIVE INTEGER.
!                 --P SHOULD BE BETWEEN 0.0 (INCLUSIVELY)
!                   AND 1.0 (INCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NORPPF, BINCDF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION AND DOUBLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--NOTE THAT EVEN THOUGH THE OUTPUT
!              FROM THIS DISCRETE DISTRIBUTION
!              PERCENT POINT FUNCTION
!              SUBROUTINE MUST NECESSARILY BE A
!              DISCRETE INTEGER VALUE,
!              THE OUTPUT VARIABLE PPF IS SINGLE
!              PRECISION IN MODE.
!              PPF HAS BEEN SPECIFIED AS SINGLE
!              PRECISION SO AS TO CONFORM WITH THE DATAPAC
!              CONVENTION THAT ALL OUTPUT VARIABLES FROM ALL
!              DATAPAC SUBROUTINES ARE SINGLE PRECISION.
!              THIS CONVENTION IS BASED ON THE BELIEF THAT
!              1) A MIXTURE OF MODES (FLOATING POINT
!              VERSUS INTEGER) IS INCONSISTENT AND
!              AN UNNECESSARY COMPLICATION
!              IN A DATA ANALYSIS; AND
!              2) FLOATING POINT MACHINE ARITHMETIC
!              (AS OPPOSED TO INTEGER ARITHMETIC)
!              IS THE MORE NATURAL MODE FOR DOING
!              DATA ANALYSIS.
!     REFERENCES--JOHNSON AND KOTZ, DISCRETE
!                 DISTRIBUTIONS, 1969, PAGES 50-86,
!                 ESPECIALLY PAGE 64, FORMULA 36.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 36-41.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 929.
!               --FELLER, AN INTRODUCTION TO PROBABILITY
!                 THEORY AND ITS APPLICATIONS, VOLUME 1,
!                 EDITION 2, 1957, PAGES 135-142.
!               --KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGES 120-125.
!               --MOOD AND GRABLE, INTRODUCTION TO THE THEORY
!                 OF STATISTICS, EDITION 2, 1963, PAGES 64-69.
!               --OWEN, HANDBOOK OF STATISTICAL
!                 TABLES, 1962, PAGES 264-272.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DOUBLE PRECISION dppar
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<0.0 .OR. P>1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE BINPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99019) P
         Ppf = 0.0
         RETURN
      ELSE
         IF ( Ppar<=0.0 .OR. Ppar>=1.0 ) THEN
            WRITE (ipr,99002)
99002       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE BINPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
            WRITE (ipr,99019) Ppar
            Ppf = 0.0
            RETURN
         ELSE
            IF ( N<1 ) THEN
               WRITE (ipr,99003)
99003          FORMAT (' ',                                             &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE BINPPF SUBROU&
     &TINE IS NON-POSITIVE *****')
               WRITE (ipr,99004) N
99004          FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,    &
     &                 ' *****')
               Ppf = 0.0
               RETURN
            ELSE
!
!-----START POINT-----------------------------------------------------
!
               an = N
               dppar = Ppar
               Ppf = 0.0
               ix0 = 0
               ix1 = 0
               ix2 = 0
               p0 = 0.0
               p1 = 0.0
               p2 = 0.0
!
!     TREAT CERTAIN SPECIAL CASES IMMEDIATELY--
!     1) P = 0.0 OR 1.0
!     2) P = 0.5 AND PPAR = 0.5
!     3) PPF = 0 OR N
!
               IF ( P/=0.0 ) THEN
                  IF ( P==1.0 ) GOTO 20
                  IF ( P==0.5 .AND. Ppar==0.5 ) THEN
                     Ppf = N/2
                     RETURN
                  ELSE
                     pf0 = (1.0D0-dppar)**N
                     qfn = 1.0D0 - (dppar**N)
                     IF ( P>pf0 ) THEN
                        IF ( P>qfn ) GOTO 20
!
!     DETERMINE AN INITIAL APPROXIMATION TO THE BINOMIAL
!     PERCENT POINT BY USE OF THE NORMAL APPROXIMATION
!     TO THE BINOMIAL.
!     (SEE JOHNSON AND KOTZ, DISCRETE DISTRIBUTIONS,
!     PAGE 64, FORMULA 36).
!
                        amean = an*Ppar
                        sd = SQRT(an*Ppar*(1.0-Ppar))
                        CALL NORPPF(P,zppf)
                        x2 = amean - 0.5 + zppf*sd
                        ix2 = x2
!
!     CHECK AND MODIFY (IF NECESSARY) THIS INITIAL
!     ESTIMATE OF THE PERCENT POINT
!     TO ASSURE THAT IT BE IN THE CLOSED INTERVAL 0 TO N.
!
                        IF ( ix2<0 ) ix2 = 0
                        IF ( ix2>N ) ix2 = N
!
!     DETERMINE UPPER AND LOWER BOUNDS ON THE DESIRED
!     PERCENT POINT BY ITERATING OUT (BOTH BELOW AND ABOVE)
!     FROM THE ORIGINAL APPROXIMATION AT STEPS
!     OF 1 STANDARD DEVIATION.
!     THE RESULTING BOUNDS WILL BE AT MOST
!     1 STANDARD DEVIATION APART.
!
                        ix0 = 0
                        ix1 = N
                        isd = sd + 1.0
                        x2 = ix2
                        CALL BINCDF(x2,Ppar,N,p2)
!
                        IF ( p2<P ) THEN
!
                           ix0 = ix2
                           DO i = 1 , 100000
                              ix2 = ix0 + isd
                              IF ( ix2>=ix1 ) GOTO 200
                              x2 = ix2
                              CALL BINCDF(x2,Ppar,N,p2)
                              IF ( p2>=P ) GOTO 50
                              ix0 = ix2
                           ENDDO
                           WRITE (ipr,99020)
                           WRITE (ipr,99005)
!
99005                      FORMAT (' ',                                 &
     &                     'NO UPPER BOUND FOUND AFTER 10**7 ITERATIONS'&
     &                     )
                        ELSE
!
                           ix1 = ix2
                           DO i = 1 , 100000
                              ix2 = ix1 - isd
                              IF ( ix2<=ix0 ) GOTO 200
                              x2 = ix2
                              CALL BINCDF(x2,Ppar,N,p2)
                              IF ( p2<P ) GOTO 100
                              ix1 = ix2
                           ENDDO
                           WRITE (ipr,99020)
                           WRITE (ipr,99006)
99006                      FORMAT (' ',                                 &
     &                     'NO LOWER BOUND FOUND AFTER 10**7 ITERATIONS'&
     &                     )
                        ENDIF
                        GOTO 300
                     ENDIF
                  ENDIF
               ENDIF
               Ppf = 0.0
               RETURN
            ENDIF
 20         Ppf = N
            RETURN
         ENDIF
 50      ix1 = ix2
         GOTO 200
      ENDIF
 100  ix0 = ix2
!
 200  IF ( ix0==ix1 ) THEN
         IF ( ix0==0 ) THEN
            ix1 = ix1 + 1
         ELSEIF ( ix0==N ) THEN
            ix0 = ix0 - 1
         ELSE
            WRITE (ipr,99020)
            WRITE (ipr,99007)
99007       FORMAT (' ','LOWER AND UPPER BOUND IDENTICAL')
            GOTO 300
         ENDIF
      ENDIF
!
!     COMPUTE BINOMIAL PROBABILITIES FOR THE
!     DERIVED LOWER AND UPPER BOUNDS.
!
      x0 = ix0
      x1 = ix1
      CALL BINCDF(x0,Ppar,N,p0)
      CALL BINCDF(x1,Ppar,N,p1)
!
!     CHECK THE PROBABILITIES FOR PROPER ORDERING
!
      IF ( p0<P .AND. P<=p1 ) THEN
         DO
!
!     THE STOPPING CRITERION IS THAT THE LOWER BOUND
!     AND UPPER BOUND ARE EXACTLY 1 UNIT APART.
!     CHECK TO SEE IF IX1 = IX0 + 1;
!     IF SO, THE ITERATIONS ARE COMPLETE;
!     IF NOT, THEN BISECT, COMPUTE PROBABILIIES,
!     CHECK PROBABILITIES, AND CONTINUE ITERATING
!     UNTIL IX1 = IX0 + 1.
!
            ix0p1 = ix0 + 1
            IF ( ix1==ix0p1 ) THEN
               Ppf = ix1
               IF ( p0==P ) Ppf = ix0
               RETURN
            ELSE
               ix2 = (ix0+ix1)/2
               IF ( ix2/=ix0 ) THEN
                  IF ( ix2==ix1 ) THEN
                     WRITE (ipr,99020)
                     WRITE (ipr,99021)
                     EXIT
                  ELSE
                     x2 = ix2
                     CALL BINCDF(x2,Ppar,N,p2)
                     IF ( p0<p2 .AND. p2<p1 ) THEN
                        IF ( p2<=P ) THEN
                           ix0 = ix2
                           p0 = p2
                        ELSE
                           ix1 = ix2
                           p1 = p2
                        ENDIF
                        CYCLE
                     ELSEIF ( p2<=p0 ) THEN
                        WRITE (ipr,99020)
                        WRITE (ipr,99008)
99008                   FORMAT (' ','BISECTION VALUE PROBABILITY (P2) ',&
     &                          'LESS THAN LOWER BOUND PROBABILITY (P0)'&
     &                          )
                        EXIT
                     ELSEIF ( p2>=p1 ) THEN
                        WRITE (ipr,99020)
                        WRITE (ipr,99009)
99009                   FORMAT (' ','BISECTION VALUE PROBABILITY (P2) ',&
     &                       'GREATER THAN UPPER BOUND PROBABILITY (P1)'&
     &                       )
                        EXIT
                     ENDIF
                  ENDIF
               ENDIF
               WRITE (ipr,99020)
               WRITE (ipr,99021)
               EXIT
            ENDIF
         ENDDO
      ELSEIF ( p0==P ) THEN
         Ppf = ix0
         RETURN
      ELSEIF ( p1==P ) THEN
         Ppf = ix1
         RETURN
      ELSEIF ( p0>p1 ) THEN
         WRITE (ipr,99020)
         WRITE (ipr,99010)
99010    FORMAT (' ','LOWER BOUND PROBABILITY (P0) GREATER THAN ',      &
     &           'UPPER BOUND PROBABILITY (P1)')
      ELSEIF ( p0>P ) THEN
         WRITE (ipr,99020)
         WRITE (ipr,99011)
99011    FORMAT (' ','LOWER BOUND PROBABILITY (P0) GREATER THAN ',      &
     &           'INPUT PROBABILITY (P)')
      ELSEIF ( p1<P ) THEN
         WRITE (ipr,99020)
         WRITE (ipr,99012)
99012    FORMAT (' ','UPPER BOUND PROBABILITY (P1) LESS    THAN ',      &
     &           'INPUT PROBABILITY (P)')
      ELSE
         WRITE (ipr,99020)
         WRITE (ipr,99013)
99013    FORMAT (' ','IMPOSSIBLE BRANCH CONDITION ENCOUNTERED')
      ENDIF
!
 300  WRITE (ipr,99014) ix0 , p0
99014 FORMAT (' ','IX0  = ',I8,10X,'P0 = ',F14.7)
      WRITE (ipr,99015) ix1 , p1
99015 FORMAT (' ','IX1  = ',I8,10X,'P1 = ',F14.7)
      WRITE (ipr,99016) ix2 , p2
99016 FORMAT (' ','IX2  = ',I8,10X,'P2 = ',F14.7)
      WRITE (ipr,99017) P
99017 FORMAT (' ','P    = ',F14.7)
      WRITE (ipr,99018) Ppar , N
99018 FORMAT (' ','PPAR = ',F14.7,10X,'N  = ',I8)
      RETURN
99019 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
99020 FORMAT (' ','***** INTERNAL ERROR IN BINPPF SUBROUTINE *****')
99021 FORMAT (' ','BISECTION VALUE (X2) = LOWER BOUND (X0)')
99022 FORMAT (' ','BISECTION VALUE (X2) = UPPER BOUND (X1)')
!
      END SUBROUTINE BINPPF
!*==binran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE BINRAN(N,P,Npar,Iseed,X)
      IMPLICIT NONE
!*--BINRAN1061
!*** Start of declarations inserted by SPAG
      REAL g(1) , P , u(1) , X
      INTEGER i , ig , ipr , Iseed , isum , j , N , Npar
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT BINRAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE BINOMIAL DISTRIBUTION
!              WITH SINGLE PRECISION 'BERNOULLI PROBABILITY'
!              PARAMETER = P,
!              AND INTEGER 'NUMBER OF BERNOULLI TRIALS'
!              PARAMETER = NPAR.
!              THE BINOMIAL DISTRIBUTION USED
!              HEREIN HAS MEAN = NPAR*P
!              AND STANDARD DEVIATION = SQRT(NPAR*P*(1-P)).
!              THIS DISTRIBUTION IS DEFINED FOR ALL
!              DISCRETE INTEGER X BETWEEN 0 (INCLUSIVELY)
!              AND NPAR (INCLUSIVELY).
!              THIS DISTRIBUTION HAS THE PROBABILITY FUNCTION
!              F(X) = C(NPAR,X) * P**X * (1-P)**(NPAR-X).
!              WHERE C(NPAR,X) IS THE COMBINATORIAL FUNCTION
!              EQUALING THE NUMBER OF COMBINATIONS OF NPAR ITEMS
!              TAKEN X AT A TIME.
!              THE BINOMIAL DISTRIBUTION IS THE
!              DISTRIBUTION OF THE NUMBER OF
!              SUCCESSES IN NPAR BERNOULLI (0,1)
!              TRIALS WHERE THE PROBABILITY OF SUCCESS
!              IN A SINGLE TRIAL = P.
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!                     --P      = THE SINGLE PRECISION VALUE
!                                OF THE 'BERNOULLI PROBABILITY'
!                                PARAMETER FOR THE BINOMIAL
!                                DISTRIBUTION.
!                                P SHOULD BE BETWEEN
!                                0.0 (EXCLUSIVELY) AND
!                                1.0 (EXCLUSIVELY).
!                     --NPAR   = THE INTEGER VALUE
!                                OF THE 'NUMBER OF BERNOULLI TRIALS'
!                                PARAMETER.
!                                NPAR SHOULD BE A POSITIVE INTEGER.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE BINOMIAL DISTRIBUTION
!             WITH 'BERNOULLI PROBABILITY' PARAMETER = P
!             AND 'NUMBER OF BERNOULLI TRIALS' PARAMETER = NPAR.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!                 --P SHOULD BE BETWEEN 0.0 (EXCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!                 --NPAR SHOULD BE A POSITIVE INTEGER.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN, GEORAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     COMMENT--NOTE THAT EVEN THOUGH THE OUTPUT
!              FROM THIS DISCRETE RANDOM NUMBER
!              GENERATOR MUST NECESSARILY BE A
!              SEQUENCE OF ***INTEGER*** VALUES,
!              THE OUTPUT VECTOR X IS SINGLE
!              PRECISION IN MODE.
!              X HAS BEEN SPECIFIED AS SINGLE
!              PRECISION SO AS TO CONFORM WITH THE DATAPAC
!              CONVENTION THAT ALL OUTPUT VECTORS FROM ALL
!              DATAPAC SUBROUTINES ARE SINGLE PRECISION.
!              THIS CONVENTION IS BASED ON THE BELIEF THAT
!              1) A MIXTURE OF MODES (FLOATING POINT
!              VERSUS INTEGER) IS INCONSISTENT AND
!              AN UNNECESSARY COMPLICATION
!              IN A DATA ANALYSIS; AND
!              2) FLOATING POINT MACHINE ARITHMETIC
!              (AS OPPOSED TO INTEGER ARITHMETIC)
!              IS THE MORE NATURAL MODE FOR DOING
!              DATA ANALYSIS.
!     REFERENCES--JOHNSON AND KOTZ, DISCRETE
!                 DISTRIBUTIONS, 1969, PAGES 50-86.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGE 41.
!               --FELLER, AN INTRODUCTION TO PROBABILITY
!                 THEORY AND ITS APPLICATIONS, VOLUME 1,
!                 EDITION 2, 1957, PAGES 135-142.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 929.
!               --KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGES 120-125.
!               --MOOD AND GRABLE, INTRODUCTION TO THE THEORY
!                 OF STATISTICS, EDITION 2, 1963, PAGES 64-69.
!               --TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 39-40.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82/7
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
      ipr = 6
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE BINRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99005) N
         RETURN
      ELSEIF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE BINRAN SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99003) P
99003    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSEIF ( Npar<1 ) THEN
         WRITE (ipr,99004)
99004    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE BINRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99005) Npar
         RETURN
!
!     CHECK ON THE MAGNITUDE OF P,
!     AND BRANCH TO THE FASTER
!     GENERATION METHOD ACCORDINGLY.
!
      ELSEIF ( P<0.1 ) THEN
!
!     IF P IS SMALL,
!     GENERATE N BINOMIAL NUMBERS
!     USING THE FACT THAT THE
!     WAITING TIME FOR 1 SUCCESS IN
!     BERNOULLI TRIALS HAS A
!     GEOMETRIC DISTRIBUTION.
!
         DO i = 1 , N
            isum = 0
            j = 1
            DO
               CALL GEORAN(1,P,Iseed,g)
               ig = g(1) + 0.5
               isum = isum + ig + 1
               IF ( isum>Npar ) THEN
                  X(i) = j - 1
                  EXIT
               ELSE
                  j = j + 1
               ENDIF
            ENDDO
         ENDDO
         GOTO 99999
      ENDIF
!
!     IF P IS MODERATE OR LARGE,
!     GENERATE N BINOMIAL RANDOM NUMBERS
!     USING THE REJECTION METHOD.
!
      DO i = 1 , N
         isum = 0
         DO j = 1 , Npar
            CALL UNIRAN(1,Iseed,u)
            IF ( u(1)<=P ) isum = isum + 1
         ENDDO
         X(i) = isum
      ENDDO
      RETURN
99005 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
!
99999 END SUBROUTINE BINRAN
!*==caucdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE CAUCDF(X,Cdf)
      IMPLICIT NONE
!*--CAUCDF1272
!*** Start of declarations inserted by SPAG
      REAL Cdf , pi , X
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT CAUCDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR THE CAUCHY DISTRIBUTION
!              WITH MEDIAN = 0 AND 75% POINT = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/PI)*(1/(1+X*X)).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF.
!     PRINTING--NONE.
!     RESTRICTIONS--NONE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ATAN.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 154-165.
!     WRITTEN BY--JAMES F. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DATA pi/3.14159265358979/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS.
!     NO INPUT ARGUMENT ERRORS POSSIBLE
!     FOR THIS DISTRIBUTION.
!
!-----START POINT-----------------------------------------------------
!
      Cdf = 0.5 + ((1.0/pi)*ATAN(X))
!
      END SUBROUTINE CAUCDF
!*==caupdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE CAUPDF(X,Pdf)
      IMPLICIT NONE
!*--CAUPDF1328
!*** Start of declarations inserted by SPAG
      REAL c , Pdf , X
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT CAUPDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PROBABILITY DENSITY
!              FUNCTION VALUE FOR THE CAUCHY DISTRIBUTION
!              WITH MEDIAN = 0 AND 75% POINT = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/PI)*(1/(1+X*X)).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE PROBABILITY DENSITY
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--PDF    = THE SINGLE PRECISION PROBABILITY
!                                DENSITY FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PROBABILITY DENSITY
!             FUNCTION VALUE PDF.
!     PRINTING--NONE.
!     RESTRICTIONS--NONE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 154-165.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DATA c/.31830988618379/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS.
!     NO INPUT ARGUMENT ERRORS POSSIBLE
!     FOR THIS DISTRIBUTION.
!
!-----START POINT-----------------------------------------------------
!
      Pdf = c*(1.0/(1.0+X*X))
!
      END SUBROUTINE CAUPDF
!*==cauplt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE CAUPLT(X,N)
      IMPLICIT NONE
!*--CAUPLT1384
!*** Start of declarations inserted by SPAG
      REAL an , arg , cc , hold , pi , sum1 , sum2 , sum3 , tau , W ,   &
     &     wbar , WS , X , Y , ybar , yint , yslope
      INTEGER i , ipr , iupper , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT CAUPLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES A CAUCHY
!              PROBABILITY PLOT.
!              THE PROTOTYPE CAUCHY DISTRIBUTION USED HEREIN
!              HAS MEDIAN = 0 AND 75% POINT = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/PI) * (1/(1+X*X)).
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE CAUCHY PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE CAUCHY DISTRIBUTION.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!     OUTPUT--A ONE-PAGE CAUCHY PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, SIN, COS.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 154-165.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
!
      DATA pi/3.14159265358979/
      DATA tau/10.02040649/
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE CAUPLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE CAUP&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE CAUPLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     COMPUTE CAUCHY ORDER STATISTIC MEDIANS
!
         DO i = 1 , N
            arg = pi*W(i)
            W(i) = -COS(arg)/SIN(arg)
         ENDDO
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         WRITE (ipr,99005) tau , N
!
99005    FORMAT (' ','CAUCHY PROBABILITY PLOT (TAU = ',E15.8,')',56X,   &
     &           'THE SAMPLE SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
         ENDDO
         ybar = sum1/an
         wbar = 0.0
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + W(i)*Y(i)
            sum3 = sum3 + W(i)*W(i)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99006) cc , yint , yslope
99006    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
!
      END SUBROUTINE CAUPLT
!*==cauppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE CAUPPF(P,Ppf)
      IMPLICIT NONE
!*--CAUPPF1545
!*** Start of declarations inserted by SPAG
      REAL arg , P , pi , Ppf
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT CAUPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE CAUCHY DISTRIBUTION
!              WITH MEDIAN = 0 AND 75% POINT = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/PI)*(1/(1+X*X)).
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT
!             FUNCTION VALUE PPF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0 AND 1.0, EXCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SIN, COS.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 154-165.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DATA pi/3.14159265358979/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE CAUPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         arg = pi*P
         Ppf = -COS(arg)/SIN(arg)
      ENDIF
!
      END SUBROUTINE CAUPPF
!*==cauran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE CAURAN(N,Iseed,X)
      IMPLICIT NONE
!*--CAURAN1622
!*** Start of declarations inserted by SPAG
      REAL arg , pi , X
      INTEGER i , ipr , Iseed , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT CAUPPF
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE CAUCHY DISTRIBUTION
!              WITH MEDIAN = 0 AND 75% POINT = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/PI)*(1/(1+X*X)).
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FUNCTION VALUE FOR THE CAUCHY DISTRIBUTION
!             WITH MEDIAN = 0 AND 75% POINT = 1.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SIN, COS.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     REFERENCES--TOCHER, THE ART OF SIMULATION,
!                 1963, PAGE 15.
!               --HAMMERSLEY AND HANDSCOMB, MONTE CARLO METHODS,
!                 1964, PAGE 36.
!               --FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGE 231.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 154-165.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82/7
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
!-----DATA STATEMENTS-------------------------------------------------
!
      DATA pi/3.14159265359/
!
      ipr = 6
!
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE CAURAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
!
!     GENERATE N UNIFORM (0,1) RANDOM NUMBERS;
!
         CALL UNIRAN(N,Iseed,X)
!
!     GENERATE N CAUCHY RANDOM NUMBERS
!     USING THE PERCENT POINT FUNCTION TRANSFORMATION METHOD.
!
         DO i = 1 , N
            arg = pi*X(i)
            X(i) = -COS(arg)/SIN(arg)
         ENDDO
      ENDIF
!
      END SUBROUTINE CAURAN
!*==causf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE CAUSF(P,Sf)
      IMPLICIT NONE
!*--CAUSF1738
!*** Start of declarations inserted by SPAG
      REAL arg , P , pi , Sf
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT CAUSF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE SPARSITY
!              FUNCTION VALUE FOR THE CAUCHY DISTRIBUTION
!              WITH MEDIAN = 0 AND 75% POINT = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/PI)*(1/(1+X*X)).
!              NOTE THAT THE SPARSITY FUNCTION OF A DISTRIBUTION
!              IS THE DERIVATIVE OF THE PERCENT POINT FUNCTION,
!              AND ALSO IS THE RECIPROCAL OF THE PROBABILITY
!              DENSITY FUNCTION (BUT IN UNITS OF P RATHER THAN X).
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                AT WHICH THE SPARSITY
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--SF     = THE SINGLE PRECISION
!                                SPARSITY FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION SPARSITY
!             FUNCTION VALUE SF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0 AND 1.0, EXCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SIN.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 154-165.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DATA pi/3.14159265358979/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE CAUSF  SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         arg = pi*P
         Sf = pi/((SIN(arg))**2)
      ENDIF
!
      END SUBROUTINE CAUSF
!*==chscdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE CHSCDF(X,Nu,Cdf)
      IMPLICIT NONE
!*--CHSCDF1816
!*** Start of declarations inserted by SPAG
      REAL amean , anu , Cdf , cdfn , danu , sd , spchi , u , X , z
      INTEGER i , ibran , ievodd , imax , imin , ipr , Nu , nucut
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT CHSCDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR THE CHI-SQUARED DISTRIBUTION
!              WITH INTEGER DEGREES OF FREEDOM PARAMETER = NU.
!              THIS DISTRIBUTION IS DEFINED FOR ALL NON-NEGATIVE X.
!              THE PROBABILITY DENSITY FUNCTION IS GIVEN
!              IN THE REFERENCES BELOW.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!                                X SHOULD BE NON-NEGATIVE.
!                     --NU     = THE INTEGER NUMBER OF DEGREES
!                                OF FREEDOM.
!                                NU SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF FOR THE CHI-SQUARED DISTRIBUTION
!             WITH DEGREES OF FREEDOM PARAMETER = NU.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--X SHOULD BE NON-NEGATIVE.
!                 --NU SHOULD BE A POSITIVE INTEGER VARIABLE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NORCDF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--DSQRT, DEXP.
!     MODE OF INTERNAL OPERATIONS--DOUBLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 941, FORMULAE 26.4.4 AND 26.4.5.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGE 176,
!                 FORMULA 28, AND PAGE 180, FORMULA 33.1.
!               --OWEN, HANDBOOK OF STATISTICAL TABLES,
!                 1962, PAGES 50-55.
!               --PEARSON AND HARTLEY, BIOMETRIKA TABLES
!                 FOR STATISTICIANS, VOLUME 1, 1954,
!                 PAGES 122-131.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --MAY       1974.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --OCTOBER   1976.
!
!---------------------------------------------------------------------
!
      DOUBLE PRECISION dx , pi , chi , sum , term , ai , dcdfn
      DOUBLE PRECISION dnu
      DOUBLE PRECISION DSQRT , DEXP
      DOUBLE PRECISION DLOG
      DOUBLE PRECISION dfact , dpower
      DOUBLE PRECISION dw
      DOUBLE PRECISION d1 , d2 , d3
      DOUBLE PRECISION term0 , term1 , term2 , term3 , term4
      DOUBLE PRECISION b11
      DOUBLE PRECISION b21
      DOUBLE PRECISION b31 , b32
      DOUBLE PRECISION b41 , b42 , b43
      DATA nucut/1000/
      DATA pi/3.14159265358979D0/
      DATA dpower/0.33333333333333D0/
      DATA b11/0.33333333333333D0/
      DATA b21/ - 0.02777777777778D0/
      DATA b31/ - 0.00061728395061D0/
      DATA b32/ - 13.0D0/
      DATA b41/0.00018004115226D0/
      DATA b42/6.0D0/
      DATA b43/17.0D0/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( Nu<=0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE CHSCDF SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) Nu
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         Cdf = 0.0
         RETURN
      ELSE
         IF ( X<0.0 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE CHSC&
     &DF SUBROUTINE IS NEGATIVE *****')
            WRITE (ipr,99004) X
99004       FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,    &
     &              ' *****')
            Cdf = 0.0
            RETURN
         ELSE
!
!-----START POINT-----------------------------------------------------
!
            dx = X
            anu = Nu
            dnu = Nu
!
!     IF X IS NON-POSITIVE, SET CDF = 0.0 AND RETURN.
!     IF NU IS SMALLER THAN 10 AND X IS MORE THAN 200
!     STANDARD DEVIATIONS BELOW THE MEAN,
!     SET CDF = 0.0 AND RETURN.
!     IF NU IS 10 OR LARGER AND X IS MORE THAN 100
!     STANDARD DEVIATIONS BELOW THE MEAN,
!     SET CDF = 0.0 AND RETURN.
!     IF NU IS SMALLER THAN 10 AND X IS MORE THAN 200
!     STANDARD DEVIATIONS ABOVE THE MEAN,
!     SET CDF = 1.0 AND RETURN.
!     IF NU IS 10 OR LARGER AND X IS MORE THAN 100
!     STANDARD DEVIATIONS ABOVE THE MEAN,
!     SET CDF = 1.0 AND RETURN.
!
            IF ( X>0.0 ) THEN
               amean = anu
               sd = SQRT(2.0*anu)
               z = (X-amean)/sd
               IF ( Nu>=10 .OR. z>=-200.0 ) THEN
                  IF ( Nu<10 .OR. z>=-100.0 ) THEN
                     IF ( Nu<10 .AND. z>200.0 ) GOTO 50
                     IF ( Nu>=10 .AND. z>100.0 ) GOTO 50
!
!     DISTINGUISH BETWEEN 3 SEPARATE REGIONS
!     OF THE (X,NU) SPACE.
!     BRANCH TO THE PROPER COMPUTATIONAL METHOD
!     DEPENDING ON THE REGION.
!     NUCUT HAS THE VALUE 1000.
!
                     IF ( Nu<nucut ) THEN
!
!     TREAT THE SMALL AND MODERATE DEGREES OF FREEDOM CASE
!     (THAT IS, WHEN NU IS SMALLER THAN 1000).
!     METHOD UTILIZED--EXACT FINITE SUM
!     (SEE AMS 55, PAGE 941, FORMULAE 26.4.4 AND 26.4.5).
!
                        chi = DSQRT(dx)
                        ievodd = Nu - 2*(Nu/2)
                        IF ( ievodd==0 ) THEN
!
                           sum = 1.0D0
                           term = 1.0D0
                           imin = 2
                           imax = Nu - 2
                        ELSE
!
                           sum = 0.0D0
                           term = 1.0/chi
                           imin = 1
                           imax = Nu - 1
                        ENDIF
!
                        IF ( imin<=imax ) THEN
                           DO i = imin , imax , 2
                              ai = i
                              term = term*(dx/ai)
                              sum = sum + term
                           ENDDO
                        ENDIF
!
                        sum = sum*DEXP(-dx/2.0D0)
                        IF ( ievodd/=0 ) THEN
                           sum = (DSQRT(2.0D0/pi))*sum
                           spchi = chi
                           CALL NORCDF(spchi,cdfn)
                           dcdfn = cdfn
                           sum = sum + 2.0D0*(1.0D0-dcdfn)
                        ENDIF
                        GOTO 100
                     ELSEIF ( Nu>=nucut .AND. X<=anu ) THEN
!
!     TREAT THE CASE WHEN NU IS LARGE
!     (THAT IS, WHEN NU IS EQUAL TO OR GREATER THAN 1000)
!     AND X IS LESS THAN OR EQUAL TO NU.
!     METHOD UTILIZED--WILSON-HILFERTY APPROXIMATION
!     (SEE JOHNSON AND KOTZ, VOLUME 1, PAGE 176, FORMULA 28).
!
                        dfact = 4.5D0*dnu
                        u = (((dx/dnu)**dpower)-1.0D0+(1.0D0/dfact))    &
     &                      *DSQRT(dfact)
                        CALL NORCDF(u,cdfn)
                        Cdf = cdfn
                        RETURN
                     ELSEIF ( Nu>=nucut .AND. X>anu ) THEN
!
!     TREAT THE CASE WHEN NU IS LARGE
!     (THAT IS, WHEN NU IS EQUAL TO OR GREATER THAN 1000)
!     AND X IS LARGER THAN NU.
!     METHOD UTILIZED--HILL'S ASYMPTOTIC EXPANSION
!     (SEE JOHNSON AND KOTZ, VOLUME 1, PAGE 180, FORMULA 33.1).
!
                        dw = DSQRT(dx-dnu-dnu*DLOG(dx/dnu))
                        danu = DSQRT(2.0D0/dnu)
                        d1 = dw
                        d2 = dw**2
                        d3 = dw**3
                        term0 = dw
                        term1 = b11*danu
                        term2 = b21*d1*(danu**2)
                        term3 = b31*(d2+b32)*(danu**3)
                        term4 = b41*(b42*d3+b43*d1)*(danu**4)
                        u = term0 + term1 + term2 + term3 + term4
                        CALL NORCDF(u,cdfn)
                        Cdf = cdfn
                        GOTO 99999
                     ELSE
                        ibran = 1
                        WRITE (ipr,99005) ibran
99005                   FORMAT (' ',                                    &
     &                      '*****INTERNAL ERROR IN CHSCDF SUBROUTINE--'&
     &                      ,                                           &
     &                  'IMPOSSIBLE BRANCH CONDITION AT BRANCH POINT = '&
     &                  ,I8)
                        RETURN
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
            Cdf = 0.0
            RETURN
         ENDIF
 50      Cdf = 1.0
         RETURN
      ENDIF
 100  Cdf = 1.0D0 - sum
      RETURN
!
99999 END SUBROUTINE CHSCDF
!*==chsplt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE CHSPLT(X,N,Nu)
      IMPLICIT NONE
!*--CHSPLT2058
!*** Start of declarations inserted by SPAG
      REAL an , cc , hold , pp0025 , pp025 , pp975 , pp9975 , q , sum1 ,&
     &     sum2 , sum3 , tau , W , wbar , WS , X , Y , ybar , yint ,    &
     &     yslope
      INTEGER i , ipr , iupper , N , Nu
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT CHSPLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES A CHI-SQUARED
!              PROBABILITY PLOT (WITH INTEGER
!              DEGREES OF FREEDOM PARAMETER VALUE = NU).
!              THE PROTOTYPE CHI-SQUARED DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL NON-NEGATIVE X,
!              AND ITS PROBABILITY DENSITY FUNCTION IS GIVEN
!              IN THE REFERENCES BELOW.
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE CHI-SQUARED PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE  CHI-SQUARED DISTRIBUTION
!              WITH DEGREES OF FREEDOM PARAMETER VALUE = NU.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --NU     = THE INTEGER NUMBER OF DEGREES
!                                OF FREEDOM.
!                                NU SHOULD BE POSITIVE.
!     OUTPUT--A ONE-PAGE CHI-SQUARED PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!                 --NU SHOULD BE POSITIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, CHSPPF, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--WILK, GNANADESIKAN, AND HUYETT, 'PROBABILITY
!                 PLOTS FOR THE GAMMA DISTRIBUTION',
!                 TECHNOMETRICS, 1962, PAGES 1-15.
!               --FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 166-206.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 46-51.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --FEBRUARY  1977.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE CHSPLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99007) N
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE CHSP&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         IF ( Nu<=0 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE CHSPLT SUBROU&
     &TINE IS NON-POSITIVE *****')
            WRITE (ipr,99007) Nu
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE CHSPLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     COMPUTE CHI-SQUARED DISTRIBUTION ORDER STATISTIC MEDIANS
!
         DO i = 1 , N
            CALL CHSPPF(W(i),Nu,W(i))
         ENDDO
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     COMPUTE THE TAIL LENGTH MEASURE OF THE DISTRIBUTION.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         q = .9975
         CALL CHSPPF(q,Nu,pp9975)
         q = .0025
         CALL CHSPPF(q,Nu,pp0025)
         q = .975
         CALL CHSPPF(q,Nu,pp975)
         q = .025
         CALL CHSPPF(q,Nu,pp025)
         tau = (pp9975-pp0025)/(pp975-pp025)
         WRITE (ipr,99005) Nu , tau , N
!
99005    FORMAT (' ',                                                   &
     &         'CHI-SQUARED PROBABILITY PLOT WITH DEGREES OF FREEDOM = '&
     &         ,I8,1X,'(TAU = ',E15.8,')',11X,'THE SAMPLE SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         sum2 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
            sum2 = sum2 + W(i)
         ENDDO
         ybar = sum1/an
         wbar = sum2/an
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + (Y(i)-ybar)*(W(i)-wbar)
            sum3 = sum3 + (W(i)-wbar)*(W(i)-wbar)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99006) cc , yint , yslope
99006    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
99007 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
!
      END SUBROUTINE CHSPLT
!*==chsppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE CHSPPF(P,Nu,Ppf)
      IMPLICIT NONE
!*--CHSPPF2250
!*** Start of declarations inserted by SPAG
      REAL anu , dnu , gamma , P , Ppf
      INTEGER icount , iloop , ipr , j , maxit , Nu
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT CHSPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE CHI-SQUARED DISTRIBUTION
!              WITH INTEGER DEGREES OF FREEDOM PARAMETER = NU.
!              THE CHI-SQUARED DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL NON-NEGATIVE X,
!              AND ITS PROBABILITY DENSITY FUNCTION IS GIVEN
!              IN REFERENCES 2, 3, AND 4 BELOW.
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 (INCLUSIVELY)
!                                AND 1.0 (EXCLUSIVELY))
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!                     --NU     = THE INTEGER NUMBER OF DEGREES
!                                OF FREEDOM.
!                                NU SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT FUNCTION .
!             VALUE PPF FOR THE CHI-SQUARED DISTRIBUTION
!             WITH DEGREES OF FREEDOM PARAMETER = NU.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--NU SHOULD BE A POSITIVE INTEGER VARIABLE.
!                 --P SHOULD BE BETWEEN 0.0 (INCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--DEXP, DLOG.
!     MODE OF INTERNAL OPERATIONS--DOUBLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     ACCURACY--(ON THE UNIVAC 1108, EXEC 8 SYSTEM AT NBS)
!               COMPARED TO THE KNOWN NU = 2 (EXPONENTIAL)
!               RESULTS, AGREEMENT WAS HAD OUT TO 6 SIGNIFICANT
!               DIGITS FOR ALL TESTED P IN THE RANGE P = .001 TO
!               P = .999.  FOR P = .95 AND SMALLER, THE AGREEMENT
!               WAS EVEN BETTER--7 SIGNIFICANT DIGITS.
!               (NOTE THAT THE TABULATED VALUES GIVEN IN THE WILK,
!               GNANADESIKAN, AND HUYETT REFERENCE BELOW, PAGE 20,
!               ARE IN ERROR FOR AT LEAST THE GAMMA = 1 CASE--
!               THE WORST DETECTED ERROR WAS AGREEMENT TO ONLY 3
!               SIGNIFICANT DIGITS (IN THEIR 8 SIGNIFICANT DIGIT TABLE)
!               FOR P = .999.)
!     REFERENCES--WILK, GNANADESIKAN, AND HUYETT, 'PROBABILITY
!                 PLOTS FOR THE GAMMA DISTRIBUTION',
!                 TECHNOMETRICS, 1962, PAGES 1-15,
!                 ESPECIALLY PAGES 3-5.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 257, FORMULA 6.1.41,
!                 AND PAGES 940-943.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 166-206.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 46-51.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DOUBLE PRECISION dp , dgamma
      DOUBLE PRECISION z , z2 , z3 , z4 , z5 , den , a , b , c , d , g
      DOUBLE PRECISION xmin0 , xmin , ai , xmax , dx , pcalc , xmid
      DOUBLE PRECISION xlower , xupper , xdel
      DOUBLE PRECISION sum , term , cut1 , cut2 , aj , cutoff , t
      DOUBLE PRECISION DEXP , DLOG
      DIMENSION d(10)
      DATA c/.918938533204672741D0/
      DATA d(1) , d(2) , d(3) , d(4) , d(5)/ + .833333333333333333D-1 , &
     &     -.277777777777777778D-2 , +.793650793650793651D-3 ,          &
     &     -.595238095238095238D-3 , +.841750841750841751D-3/
      DATA d(6) , d(7) , d(8) , d(9) , d(10)/ - .191752691752691753D-2 ,&
     &     +.641025641025641025D-2 , -.295506535947712418D-1 ,          &
     &     +.179644372368830573D0 , -.139243221690590111D1/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE CHSPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         Ppf = 0.0
         RETURN
      ELSEIF ( Nu<1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE CHSPPF SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99004) Nu
99004    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         Ppf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
!     EXPRESS THE CHI-SQUARED DISTRIBUTION PERCENT POINT
!     FUNCTION IN TERMS OF THE EQUIVALENT GAMMA
!     DISTRIBUTION PERCENT POINT FUNCTION,
!     AND THEN EVALUATE THE LATTER.
!
         anu = Nu
         gamma = anu/2.0
         dp = P
         dnu = Nu
         dgamma = dnu/2.0D0
         maxit = 10000
!
!     COMPUTE THE GAMMA FUNCTION USING THE ALGORITHM IN THE
!     NBS APPLIED MATHEMATICS SERIES REFERENCE.
!     THIS GAMMA FUNCTION NEED BE CALCULATED ONLY ONCE.
!     IT IS USED IN THE CALCULATION OF THE CDF BASED ON
!     THE TENTATIVE VALUE OF THE PPF IN THE ITERATION.
!
         z = dgamma
         den = 1.0D0
         DO WHILE ( z<10.0D0 )
            den = den*z
            z = z + 1.0D0
         ENDDO
         z2 = z*z
         z3 = z*z2
         z4 = z2*z2
         z5 = z2*z3
         a = (z-0.5D0)*DLOG(z) - z + c
         b = d(1)/z + d(2)/z3 + d(3)/z5 + d(4)/(z2*z5) + d(5)/(z4*z5)   &
     &       + d(6)/(z*z5*z5) + d(7)/(z3*z5*z5) + d(8)/(z5*z5*z5) + d(9)&
     &       /(z2*z5*z5*z5)
         g = DEXP(a+b)/den
!
!     DETERMINE LOWER AND UPPER LIMITS ON THE DESIRED 100P
!     PERCENT POINT.
!
         iloop = 1
         xmin0 = (dp*dgamma*g)**(1.0D0/dgamma)
         xmin = xmin0
         icount = 1
      ENDIF
 100  ai = icount
      xmax = ai*xmin0
      dx = xmax
      GOTO 500
 200  xmid = (xmin+xmax)/2.0D0
!
!     NOW ITERATE BY BISECTION UNTIL THE DESIRED ACCURACY IS ACHIEVED.
!
      iloop = 2
      xlower = xmin
      xupper = xmax
      icount = 0
 300  dx = xmid
      GOTO 500
 400  Ppf = 2.0D0*xmid
      RETURN
!
!********************************************************************
!     THIS SECTION BELOW IS LOGICALLY SEPARATE FROM THE ABOVE.
!     THIS SECTION COMPUTES A CDF VALUE FOR ANY GIVEN TENTATIVE
!     PERCENT POINT X VALUE AS DEFINED IN EITHER OF THE 2
!     ITERATION LOOPS IN THE ABOVE CODE.
!
!     COMPUTE T-SUB-Q AS DEFINED ON PAGE 4 OF THE WILK, GNANADESIKAN,
!     AND HUYETT REFERENCE
!
 500  sum = 1.0D0/dgamma
      term = 1.0D0/dgamma
      cut1 = dx - dgamma
      cut2 = dx*10000000000.0D0
      DO j = 1 , maxit
         aj = j
         term = dx*term/(dgamma+aj)
         sum = sum + term
         cutoff = cut1 + (cut2*term/sum)
         IF ( aj>cutoff ) GOTO 600
      ENDDO
      WRITE (ipr,99005) maxit
!
99005 FORMAT (' ','*****ERROR IN INTERNAL OPERATIONS IN THE CHSPPF ',   &
     &        'SUBROUTINE--THE NUMBER OF ITERATIONS EXCEEDS ',I7)
      WRITE (ipr,99006) P
99006 FORMAT (' ','     THE INPUT VALUE OF P     IS ',E15.8)
      WRITE (ipr,99007) Nu
99007 FORMAT (' ','     THE INPUT VALUE OF NU    IS ',I8)
      WRITE (ipr,99008)
99008 FORMAT (' ','     THE OUTPUT VALUE OF PPF HAS BEEN SET TO 0.0')
      Ppf = 0.0
      RETURN
!
 600  t = sum
      pcalc = (dx**dgamma)*(DEXP(-dx))*t/g
      IF ( iloop==1 ) THEN
         IF ( pcalc>=dp ) GOTO 200
         xmin = xmax
         icount = icount + 1
         IF ( icount>30000 ) GOTO 200
         GOTO 100
      ELSE
         IF ( pcalc==dp ) GOTO 400
         IF ( pcalc>dp ) THEN
            xupper = xmid
            xmid = (xmid+xlower)/2.0D0
         ELSE
            xlower = xmid
            xmid = (xmid+xupper)/2.0D0
         ENDIF
         xdel = xmid - xlower
         IF ( xdel<0.0D0 ) xdel = -xdel
         icount = icount + 1
         IF ( xdel>=0.0000000001D0 .AND. icount<=100 ) GOTO 300
         GOTO 400
      ENDIF
!
      END SUBROUTINE CHSPPF
!*==chsran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE CHSRAN(N,Nu,Iseed,X)
      IMPLICIT NONE
!*--CHSRAN2486
!*** Start of declarations inserted by SPAG
      REAL arg1 , arg2 , pi , sum , X , y , z
      INTEGER i , ipr , Iseed , j , N , Nu
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT CHSRAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE CHI-SQUARED DISTRIBUTION
!              WITH INTEGER DEGREES OF FREEDOM PARAMETER = NU.
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!                     --NU     = THE INTEGER DEGREES OF FREEDOM
!                                (PARAMETER) FOR THE CHI-SQUARED
!                                DISTRIBUTION.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE CHI-SQUARED DISTRIBUTION
!             WITH DEGREES OF FREEDOM PARAMETER = NU.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!                 --NU SHOULD BE A POSITIVE INTEGER VARIABLE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG, SQRT, SIN, COS.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     REFERENCES--TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 34-35.
!               --MOOD AND GRABLE, INTRODUCTION TO THE
!                 THEORY OF STATISTICS, 1963, PAGES 226-227.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGE 171.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGE 48.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82/7
!     ORIGINAL VERSION--FEBRUARY  1975.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
      DIMENSION y(2) , z(2)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
!-----DATA STATEMENTS-------------------------------------------------
!
      DATA pi/3.14159265359/
!
      ipr = 6
!
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE CHSRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99003) N
         RETURN
      ELSEIF ( Nu<=0 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE CHSRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99003) Nu
         RETURN
      ELSE
!
!     GENERATE N CHI-SQUARED RANDOM NUMBERS
!     USING THE DEFINITION THAT
!     A CHI-SQUARED VARIATE WITH NU DEGREES OF FREEDOM
!     EQUALS THE SUM OF NU SQUARED NORMAL VARIATES.
!     FIRST GENERATE 2 UNIFORM (0,1) RANDOM NUMBERS,
!     THEN GENERATE 2 NORMAL RANDOM NUMBERS,
!     THEN FORM THE SUM OF SQUARED NORMAL RANDOM NUMBERS.
!
         DO i = 1 , N
            sum = 0.0
            DO j = 1 , Nu , 2
               CALL UNIRAN(2,Iseed,y)
               arg1 = -2.0*ALOG(y(1))
               arg2 = 2.0*pi*y(2)
               z(1) = (SQRT(arg1))*(COS(arg2))
               z(2) = (SQRT(arg1))*(SIN(arg2))
               sum = sum + z(1)*z(1)
               IF ( j/=Nu ) sum = sum + z(2)*z(2)
            ENDDO
            X(i) = sum
         ENDDO
      ENDIF
99003 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
!
      END SUBROUTINE CHSRAN
!*==code.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE CODE(X,N,Y)
      IMPLICIT NONE
!*--CODE2619
!*** Start of declarations inserted by SPAG
      REAL ai , DISt , hold , WS , X , Y
      INTEGER i , ipr , iupper , j , N , numdis
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT CODE
!
!     PURPOSE--THIS SUBROUTINE CODES THE ELEMENTS
!              OF THE INPUT VECTOR X
!              AND PUTS THE CODED VALUES INTO THE OUTPUT VECTOR Y.
!              THE CODING IS AS FOLLOWS--
!              THE MINIMUM IS CODED AS 1.0.
!              THE NEXT LARGER VALUE AS 2.0,
!              THE NEXT LARGER VALUE AS 3.0,
!              ETC.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR
!                                OF OBSERVATIONS TO BE CODED.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!     OUTPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR
!                                INTO WHICH THE CODED VALUES
!                                WILL BE PLACED.
!     OUTPUT--THE SINGLE PRECISION VECTOR Y
!             WHICH WILL CONTAIN THE CODED VALUES
!             CORRESPONDING TO THE OBSERVATIONS IN
!             THE VECTOR X.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 15000.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--ALL OCCURRANCES OF THE MINIMUM ARE CODED AS 1.0;
!              ALL OCCURANCES OF THE NEXT LARGER VALUE
!              ARE CODED AS 2.0;
!              ALL OCCURANCES OF THE NEXT LARGER VALUE
!              ARE CODED AS 3.0, ETC.
!     COMMENT--THE INPUT VECTOR X REMAINS UNALTERED.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--OCTOBER  1975.
!     UPDATED         --NOVEMBER 1975.
!     UPDATED         --JUNE     1977.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1) , Y(1)
      DIMENSION DISt(15000)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (DISt(1),WS(1))
!
      ipr = 6
      iupper = 15000
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE CODE   SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE CODE&
     &   SUBROUTINE HAS THE VALUE 1 *****')
            Y(1) = 1.0
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE CODE   SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            DO i = 1 , N
               Y(i) = i
            ENDDO
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
!     PERFORM THE CODING--
!     PULL OUT THE DISTINCT VALUES,
!     THEN SORT (AND ESSENTIALLY RANK) THE DISTINCT VALUES,
!     THEN APPLY THE RANKS TO ALL THE VALUES.
!
 50      numdis = 1
         DISt(numdis) = X(1)
         DO i = 2 , N
            DO j = 1 , numdis
               IF ( X(i)==DISt(j) ) GOTO 100
            ENDDO
            numdis = numdis + 1
            DISt(numdis) = X(i)
 100     ENDDO
!
         CALL SORT(DISt,numdis,DISt)
!
         DO i = 1 , N
            DO j = 1 , numdis
               IF ( X(i)==DISt(j) ) GOTO 120
            ENDDO
            WRITE (ipr,99005)
99005       FORMAT (' ','*****INTERNAL ERROR IN CODE SUBROUTINE')
            WRITE (ipr,99006) i , X(i)
99006       FORMAT (' ','NO CODE FOUND FOR ELEMENT NUMBER ',I5,' = ',   &
     &              F15.7)
            RETURN
 120        Y(i) = j
         ENDDO
!
!     WRITE OUT A FEW LINES OF SUMMARY INFORMATION ABOUT THE CODING.
!
         WRITE (ipr,99011)
         WRITE (ipr,99007)
99007    FORMAT (' ','OUTPUT FROM THE CODE SUBROUTINE')
         WRITE (ipr,99008) numdis
99008    FORMAT (' ','NUMBER OF DISTINCT CODE VALUES = ',I8)
         WRITE (ipr,99011)
         WRITE (ipr,99009)
99009    FORMAT (' ',8X,'VALUE     CODED VALUE')
         DO i = 1 , numdis
            ai = i
            WRITE (ipr,99010) DISt(i) , ai
99010       FORMAT (' ',F15.7,6X,F6.0)
         ENDDO
      ENDIF
99011 FORMAT (' ')
!
      END SUBROUTINE CODE
!*==copy.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE COPY(X,N,Y)
      IMPLICIT NONE
!*--COPY2766
!*** Start of declarations inserted by SPAG
      REAL hold , X , Y
      INTEGER i , ipr , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT COPY
!
!     PURPOSE--THIS SUBROUTINE COPIES THE CONTENTS
!              OF THE SINGLE PRECISION VECTOR X INTO THE
!              SINGLE PRECISION VECTOR Y.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                OBSERVATIONS TO BE COPIED.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!     OUTPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR
!                                INTO WHICH THE COPIED DATA VALUES
!                                FROM X WILL BE SEQUENTIALLY PLACED.
!     OUTPUT--THE SINGLE PRECISION VECTOR Y.
!             WHICH WILL HAVE ITS
!             FIRST N ELEMENTS IDENTICAL
!             TO THE SINGLE PRECISION VECTOR X.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--THE FIRST ELEMENT OF X IS COPIED INTO THE FIRST
!              ELEMENT OF Y; THE SECOND ELEMENT OF X IS COPIED INTO
!              THE SECOND ELEMENT OF Y, ETC.
!     COMMENT--THE INPUT VECTOR X REMAINS UNALTERED.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1972.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1) , Y(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE COPY   SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE COPY&
     &   SUBROUTINE HAS THE VALUE 1 *****')
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE COPY   SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      DO i = 1 , N
            Y(i) = X(i)
         ENDDO
      ENDIF
!
      END SUBROUTINE COPY
!*==corr.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE CORR(X,Y,N,Iwrite,C)
      IMPLICIT NONE
!*--CORR2852
!*** Start of declarations inserted by SPAG
      REAL an , C , hold , sum1 , sum2 , sum3 , X , xbar , Y , ybar
      INTEGER i , iflag , ipr , Iwrite , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT CORR
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE CORRELATION COEFFICIENT
!              BETWEEN THE 2 SETS OF DATA IN THE INPUT VECTORS X AND Y.
!              THE SAMPLE CORRELATION COEFFICIENT WILL BE A SINGLE
!              PRECISION VALUE BETWEEN -1.0 AND 1.0 (INCLUSIVELY).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED) OBSERVATIONS
!                                WHICH CONSTITUTE THE FIRST SET
!                                OF DATA.
!                     --Y      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED) OBSERVATIONS
!                                WHICH CONSTITUTE THE SECOND SET
!                                OF DATA.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X, OR EQUIVALENTLY,
!                                THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR Y.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE CORRELATION COEFFICIENT
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE CORRELATION COEFFICIENT
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--C      = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE CORRELATION COEFFICIENT
!                                BETWEEN THE 2 SETS OF DATA
!                                IN THE INPUT VECTORS X AND Y.
!                                THIS SINGLE PRECISION VALUE
!                                WILL BE BETWEEN -1.0 AND 1.0
!                                (INCLUSIVELY).
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE CORRELATION COEFFICIENT BETWEEN THE 2 SETS
!             OF DATA IN THE INPUT VECTORS X AND Y.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGES 235-236.
!               --KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 2, EDITION 1, 1961, PAGES 292-293.
!               --SNEDECOR AND COCHRAN, STATISTICAL METHODS,
!                 EDITION 6, 1967, PAGES 172-198.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1) , Y(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      an = N
      C = 0.0
      iflag = 0
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE CORR   SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE THIRD  INPUT ARGUMENT TO THE CORR&
     &   SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE CORR   SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
         iflag = 1
 50      hold = Y(1)
         DO i = 2 , N
            IF ( Y(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99005) hold
99005    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT (A VECTOR) &
     &TO THE CORR   SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
         iflag = 1
 100     IF ( iflag==1 ) RETURN
!
!-----START POINT-----------------------------------------------------
!
         xbar = 0.0
         ybar = 0.0
         DO i = 1 , N
            xbar = xbar + X(i)
            ybar = ybar + Y(i)
         ENDDO
         xbar = xbar/an
         ybar = ybar/an
!
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (X(i)-xbar)*(Y(i)-ybar)
            sum2 = sum2 + (X(i)-xbar)**2
            sum3 = sum3 + (Y(i)-ybar)**2
         ENDDO
         sum2 = SQRT(sum2)
         sum3 = SQRT(sum3)
         C = sum1/(sum2*sum3)
!
         IF ( Iwrite/=0 ) WRITE (ipr,99006) N , C
99006    FORMAT (' ',                                                   &
     &     'THE LINEAR        CORRELATION COEFFICIENT OF THE 2 SETS OF '&
     &     ,I6,' OBSERVATIONS IS ',F14.5)
      ENDIF
      END SUBROUTINE CORR
!*==count.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE COUNT(X,N,Xmin,Xmax,Iwrite,Xcount)
      IMPLICIT NONE
!*--COUNT3000
!*** Start of declarations inserted by SPAG
      REAL an , hold , X , Xcount , Xmax , Xmin
      INTEGER i , ipr , isum , Iwrite , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT COUNT
!
!     PURPOSE--THIS SUBROUTINE COMPUTES
!              THE NUMBER OF OBSERVATIONS
!              BETWEEN XMIN AND XMAX (INCLUSIVELY)
!              IN THE INPUT VECTOR X.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --XMIN   = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES THE LOWER LIMIT
!                                (INCLUSIVELY) OF THE REGION
!                                OF INTEREST.
!                     --XMAX   = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES THE UPPER LIMIT
!                                (INCLUSIVELY) OF THE REGION
!                                OF INTEREST.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE COUNT
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE COUNT
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XCOUNT = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE COUNT.
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE COUNT.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--SNEDECOR AND COCHRAN, STATISTICAL METHODS,
!                 EDITION 6, 1967, PAGES 207-213.
!               --DIXON AND MASSEY, INTRODUCTION TO STATISTICAL
!                 ANALYSIS, EDITION 2, 1957, PAGES 81-82, 228-231.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE COUNT  SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE COUN&
     &T  SUBROUTINE HAS THE VALUE 1 *****')
         Xcount = 0.0
         RETURN
      ELSE
         IF ( Xmin==Xmax ) THEN
            WRITE (ipr,99004)
99004       FORMAT (' ','***** FATAL ERROR--THE THIRD AND FOURTH INPUT '&
     &              ,'ARGUMENTS TO THE COUNT  SUBROUTINE ARE IDENTICAL')
            WRITE (ipr,99005) Xmin
99005       FORMAT (' ','***** THE VALUE OF THE ARGUMENTS ARE ',E15.7,  &
     &              ' *****')
            Xcount = 0.0
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99006) hold
99006       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE COUNT  SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
            Xcount = 0.0
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
         Xcount = 0.0
         isum = 0
         DO i = 1 , N
            IF ( X(i)>=Xmin .AND. Xmax>=X(i) ) isum = isum + 1
         ENDDO
         Xcount = isum
!
         IF ( Iwrite==0 ) RETURN
         WRITE (ipr,99007)
99007    FORMAT (' ')
         WRITE (ipr,99008) N , Xmin , Xmax , Xcount
99008    FORMAT (' ','THE NUMBER (OUT OF THE ',I6,                      &
     &           ' OBSERVATIONS) IN THE INTERVAL ',E15.7,' TO ',E15.7,  &
     &           ' IS ',E15.7)
      ENDIF
      END SUBROUTINE COUNT
!*==decomp.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE DECOMP(N,K,Eta,Tol,Irank,Insing)
      IMPLICIT NONE
!*--DECOMP3127
!*** Start of declarations inserted by SPAG
      REAL D , dis , dn , DUM1 , DUM2 , Eta , hold , Q , R , risj ,     &
     &     Tol , tol2 , WS
      INTEGER i , Insing , ip , IPIvot , iqarg , iqarg1 , iqarg2 ,      &
     &        Irank , irarg , irarg1 , irarg2 , is , ism1 , isp1 , j ,  &
     &        K , l , m , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT DECOMP
      EXTERNAL DOT
!
!     PURPOSE--THIS SUBROUTINE DECOMPOSES THE WEIGHTED DATA
!     MATRIX Q WHICH ORIGINALLY = THE N BY K DATA MATRIX X
!     TIMES THE SQUARE ROOT OF THE WEIGHTS (IN W).
!     THE ORIGINAL Q IS DECOMPOSED INTO A NEW Q TIMES THE
!     INVERSE OF A DIAGONAL MATRIX D TIMES THE DIAGONAL MATRIX D
!     TIMES AN UPPER TRIANGULAR MATRIX R.
!     THE NEW N BY K Q HAS ORTHOGONAL COLUMNS.
!     A SECOND OUTPUT FROM THIS SUBROUTINE IS THE RANK AND
!     STATUS (NON-SINGULAR OR SINGULAR) OF THE DATA MATRIX X.
!     A THIRD OURPUT FROM THIS SUBROUTINE IS THE NUMERICALLY
!     OPTIMAL PIVOT POINTS FOR THE DECOMPOSITION.
!     X--NOT USED
!     Q--USED AND CHANGED
!     R--DEFINED
!     D--PERMANENTLY DEFINED
!     IPIVOT--PERMANENTLY DEFINED
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      LOGICAL fsum
      DIMENSION Q(10000) , R(2500) , D(50) , IPIvot(50)
      COMMON /BLOCK2/ WS(15000)
      COMMON /BLOCK3/ DUM1(3000) , DUM2(3000)
      EQUIVALENCE (Q(1),WS(1))
      EQUIVALENCE (R(1),WS(10001))
      EQUIVALENCE (D(1),WS(12501))
      EQUIVALENCE (IPIvot(1),WS(12551))
!
!-----START POINT-----------------------------------------------------
!
!     ZERO-OUT SOME VARIABLES, VECTORS, AND ARRAYS
!
      Insing = 0
      Irank = 0
      DO j = 1 , K
         D(j) = 0.0
         DO i = 1 , K
            irarg = (i-1)*K + j
            R(irarg) = 0.0
         ENDDO
      ENDDO
!
      tol2 = Tol*Tol
      DO j = 1 , K
         IPIvot(j) = j
      ENDDO
      DO is = 1 , K
!
!     BEGIN STEP NUMBER      IS      IN THE DECOMPOSITION
!
         IF ( is==1 ) fsum = .TRUE.
 50      dis = 0.0
         ip = is
!
!     BEGIN THE PIVOT SEARCH
!
         DO j = is , K
            m = IPIvot(j)
            IF ( fsum ) THEN
               DO l = 1 , N
                  iqarg = (l-1)*K + m
                  DUM1(l) = Q(iqarg)
                  DUM2(l) = Q(iqarg)
               ENDDO
!
               CALL DOT(DUM1,DUM2,1,N,0.0,D(j))
            ENDIF
!
            IF ( dis<D(j) ) THEN
               dis = D(j)
               ip = j
            ENDIF
         ENDDO
!
!     END THE PIVOT SEARCH
!
         m = IPIvot(ip)
         IF ( fsum ) dn = dis
         IF ( dis<Eta*dn ) THEN
            fsum = .TRUE.
         ELSE
            fsum = .FALSE.
         ENDIF
         IF ( fsum ) GOTO 50
         IF ( ip/=is ) THEN
!
!     BEGIN COLUMN INTERCHANGES
!
            D(ip) = D(is)
            IPIvot(ip) = IPIvot(is)
            IPIvot(is) = m
            IF ( is/=1 ) THEN
               ism1 = is - 1
               DO i = 1 , ism1
                  irarg1 = (i-1)*K + ip
                  irarg2 = (i-1)*K + is
                  hold = R(irarg1)
                  R(irarg1) = R(irarg2)
                  R(irarg2) = hold
               ENDDO
            ENDIF
         ENDIF
!
!     END COLUMN INTERCHANGES
!
         DO l = 1 , N
            iqarg = (l-1)*K + m
            DUM1(l) = Q(iqarg)
            DUM2(l) = Q(iqarg)
         ENDDO
!
         CALL DOT(DUM1,DUM2,1,N,0.0,D(is))
!
         dis = D(is)
         IF ( dis<=tol2*D(1) ) RETURN
         IF ( dis/=0.0 ) THEN
            isp1 = is + 1
            IF ( isp1<=K ) THEN
!
!     BEGIN ORTHOGONALIZATION
!
               DO j = isp1 , K
                  ip = IPIvot(j)
                  DO l = 1 , N
                     iqarg1 = (l-1)*K + m
                     iqarg2 = (l-1)*K + ip
                     DUM1(l) = Q(iqarg1)
                     DUM2(l) = Q(iqarg2)
                  ENDDO
!
                  irarg = (is-1)*K + j
                  CALL DOT(DUM1,DUM2,1,N,0.0,R(irarg))
                  R(irarg) = R(irarg)/dis
!
                  risj = R(irarg)
                  DO i = 1 , N
                     iqarg1 = (i-1)*K + ip
                     iqarg2 = (i-1)*K + m
                     Q(iqarg1) = Q(iqarg1) - risj*Q(iqarg2)
                  ENDDO
                  D(j) = D(j) - dis*risj*risj
               ENDDO
            ENDIF
!
!     END ORTHOGONALIZATION
!
            Irank = is
         ELSE
            Insing = 0
            RETURN
         ENDIF
      ENDDO
!
!     END STEP NUMBER     IS     INTHE DECOMPOSITION
!
      Insing = 1
      END SUBROUTINE DECOMP
!*==define.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE DEFINE(X,N,Xnew)
      IMPLICIT NONE
!*--DEFINE3301
!*** Start of declarations inserted by SPAG
      INTEGER i , ipr , N
      REAL X , Xnew
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT DEFINE
!
!     PURPOSE--THIS SUBROUTINE SETS ALL OF THE ELEMENTS
!              IN THE SINGLE PRECISION VECTOR X
!              EQUAL TO XNEW.
!              THIS SUBROUTINE IS USEFUL IN DEFINING A
!              VECTOR OF CONSTANTS.
!              FOR EXAMPLE, IF THE DATA ANALYST WISHES
!              TO TREAT THE EQUAL WEIGHTS CASE IN DOING
!              A POLYNOMIAL REGRESSION, THIS COULD
!              BE DONE BY DEFINING AS, SAY, 1.0
!              THE INPUT WEIGHT VECTOR W TO THE
!              DATAPAC POLY SUBROUTINE;
!              SUCH DEFINING COULD BE DONE
!              BY USE OF THE DEFINE SUBROUTINE
!              WITH XNEW = 1.0.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --XNEW   = THE SINGLE PRECISION VALUE
!                                TO WHICH ALL OF THE
!                                OBSERVATIONS IN THE VECTOR X
!                                WILL BE SET.
!     OUTPUT--THE SINGLE PRECISION VECTOR X
!             EVERY ELEMENT OF WHICH
!             WILL BE EQUAL TO XNEW.
!             ALSO, 3 LINES OF SUMMARY INFORMATION
!             WILL BE GENERATED INDICATING
!             1) WHAT THE SAMPLE SIZE WAS (N);
!             2) WHAT THE DEFINING CONSTANT WAS (XNEW);
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED  VERSION--JULY      1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE DEFINE SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE DEFI&
     &NE SUBROUTINE HAS THE VALUE 1 *****')
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
         DO i = 1 , N
            X(i) = Xnew
         ENDDO
!
!     WRITE OUT A BRIEF SUMMARY
!
         WRITE (ipr,99004)
99004    FORMAT (' ')
         WRITE (ipr,99005)
99005    FORMAT (' ','OUTPUT FROM THE DEFINE SUBROUTINE--')
         WRITE (ipr,99006) N
99006    FORMAT (' ',7X,'THE INPUT  NUMBER OF OBSERVATIONS  IS ',I6)
         WRITE (ipr,99007) Xnew
99007    FORMAT (' ',7X,'THE DEFINING CONSTANT IS ',E15.8)
      ENDIF
!
      END SUBROUTINE DEFINE
!*==delete.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE DELETE(X,N,Xmin,Xmax,Newn)
      IMPLICIT NONE
!*--DELETE3400
!*** Start of declarations inserted by SPAG
      REAL hold , pointl , pointu , X , Xmax , Xmin
      INTEGER i , ipr , k , N , ndel , Newn , newnp1 , nold
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT DELETE
!
!     PURPOSE--THIS SUBROUTINE DELETES ALL OBSERVATIONS IN THE
!              SINGLE PRECISION VECTOR X WHICH ARE INSIDE
!              THE CLOSED (INCLUSIVE) INTERVAL
!              DEFINED BY XMIN AND XMAX,
!              WHILE RETAINING ALL OBSERVATIONS OUTSIDE OF
!              THIS INTERVAL.
!              THUS ALL OBSERVATIONS IN X WHICH ARE LARGER
!              THAN OR EQUAL TO XMIN AND SMALLER THAN OR
!              EQUAL TO XMAX ARE DELETED FROM X.
!              THIS SUBROUTINE (AND THE
!              REPLAC AND RETAIN SUBROUTINES)
!              GIVES THE DATA ANALYST THE ABILITY TO
!              EASILY 'CLEAN UP' A DATA SET WHICH HAS
!              MISSING AND/OR OUTLYING OBSERVATIONS
!              SO THAT A MORE APPROPRIATE SUBSEQUENT
!              DATA ANALYSIS MAY BE PERFORMED.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --XMIN   = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES THE LOWER LIMIT
!                                (INCLUSIVELY) OF THE PARTICULAR
!                                INTERVAL OF INTEREST TO BE DELETED.
!                     --XMAX   = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES THE UPPER LIMIT
!                                (INCLUSIVELY) OF THE PARTICULAR
!                                INTERVAL OF INTEREST TO BE DELETED.
!     OUTPUT ARGUMENTS--NEWN   = THE INTEGER NUMBER OF OBSERVATIONS
!                                REMAINING IN X AFTER ALL
!                                OF THE OBSERVATIONS INSIDE
!                                (INCLUSIVELY) THE INTERVAL
!                                OF INTEREST HAVE BEEN DELETED.
!     OUTPUT--THE SINGLE PRECISION VECTOR X
!             IN WHICH ALL THOSE VALUES INSIDE
!             (INCLUSIVELY) THE INTERVAL OF INTEREST
!             HAVE BEEN DELETED, AND
!             THE INTEGER VALUE NEWN
!             WHICH GIVES THE NUMBER OF
!             OBSERVATIONS REMAINING IN X.
!             ALSO, 6 LINES OF SUMMARY INFORMATION
!             WILL BE GENERATED INDICATING
!             1) WHAT THE INTERVAL OF INTEREST WAS;
!             2) HOW MANY OBSERVATIONS WERE DELETED;
!             3) WHAT THE OLD (ORIGINAL) SAMPLE SIZE WAS (N);
!             4) WHAT THE NEW SAMPLE SIZE IS (NEWN).
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--IN THE END, AFTER THIS SUBROUTINE HAS
!              MADE WHATEVER DELETIONS ARE APPROPRIATE,
!              THE OUTPUT VECTOR X WILL BE 'PACKED';
!              THAT IS, NO 'HOLES' WILL EXIST IN THE
!              VECTOR X--ALL OF THE RETAINED ELEMENTS
!              OF X WILL BE PACKED INTO THE FIRST AVAILABLE
!              LOCATIONS IN X, WHILE THE REMAINDER
!              OF THE N LOCATIONS IN X WILL BE ZERO-FILLED.
!     COMMENT--IN THE MAIN (CALLING) ROUTINE, IT IS
!              PERMISSABLE (IF THE ANALYST SO DESIRES)
!              TO USE THE SAME VARIABLE NAME
!              IN THE FIFTH ARGUMENT AS USED IN THE SECOND
!              ARGUMENT IN THE CALLING SEQUENCE TO THIS
!              DELETE SUBROUTINE--NO CONFLICT WILL RESULT
!              IN THE INTERNAL OPERATION OF THE     DELETE
!              SUBROUTINE.  FOR EXAMPLE, IT IS PERMISSIBLE
!              TO HAVE     CALL DELETE(X,N,-10.0,10.0,N)
!              IN WHICH THE VARIABLE NAME      N    IS USED
!              AS BOTH THE SECOND AND FIFTH ARGUMENTS.
!     COMMENT--THIS IS ONE OF THE FEW SUBROUTINES IN DATAPAC
!              IN WHICH THE INPUT VECTOR X IS ALTERED.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JULY      1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE DELETE SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE DELE&
     &TE SUBROUTINE HAS THE VALUE 1 *****')
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE DELETE SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      pointl = Xmin
         pointu = Xmax
         IF ( Xmin>Xmax ) pointl = Xmax
         IF ( Xmin>Xmax ) pointu = Xmin
!
         nold = N
         k = 0
         DO i = 1 , nold
            IF ( pointl>X(i) .OR. X(i)>pointu ) THEN
               k = k + 1
               X(k) = X(i)
            ENDIF
         ENDDO
         Newn = k
         ndel = nold - Newn
!
         newnp1 = Newn + 1
         IF ( newnp1<=nold ) THEN
            DO i = newnp1 , nold
               X(i) = 0.0
            ENDDO
         ENDIF
!
!     WRITE OUT A BRIEF SUMMARY
!
         WRITE (ipr,99005)
99005    FORMAT (' ')
         WRITE (ipr,99006)
99006    FORMAT (' ','OUTPUT FROM THE DELETE SUBROUTINE--')
         WRITE (ipr,99007) pointl , pointu
99007    FORMAT (' ',7X,'ALL OBSERVATIONS BETWEEN ',E15.8,' AND ',E15.8)
         WRITE (ipr,99008)
99008    FORMAT (' ',7X,'(INCLUSIVE) HAVE BEEN DELETED.')
         WRITE (ipr,99009)
99009    FORMAT (' ',7X,'ALL OBSERVATIONS OUTSIDE OF THIS INTERVAL')
         WRITE (ipr,99010)
99010    FORMAT (' ',7X,'HAVE BEEN RETAINED.')
         WRITE (ipr,99011) nold
99011    FORMAT (' ',7X,'THE INPUT  NUMBER OF OBSERVATIONS (IN X) IS ', &
     &           I6)
         WRITE (ipr,99012) Newn
99012    FORMAT (' ',7X,'THE OUTPUT NUMBER OF OBSERVATIONS (IN X) IS ', &
     &           I6)
         WRITE (ipr,99013) ndel
99013    FORMAT (' ',7X,'THE NUMBER OF OBSERVATIONS DELETED       IS ', &
     &           I6)
      ENDIF
!
      END SUBROUTINE DELETE
!*==demod.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE DEMOD(X,N,F)
      IMPLICIT NONE
!*--DEMOD3578
!*** Start of declarations inserted by SPAG
      REAL ai , aiflag , aimax2 , alen1 , alen2 , an , del , F , fest , &
     &     fmin , hold , pi , range , slopeh , sloper , sum , WS , X ,  &
     &     Y1 , Y2
      REAL Z , zmax , zmin , znew
      INTEGER i , iend , iendp1 , iflag , ilower , imax1 , imax2 ,      &
     &        imax2m , ip1 , ipr , istart , iupper , j , lenma1 ,       &
     &        lenma2 , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT DEMOD
!
!     PURPOSE--THIS SUBROUTINE PERFORMS A COMPLEX DEMODULATION
!              ON THE DATA IN THE INPUT VECTOR X
!              AT THE INPUT DEMODULATION FREQUENCY = F.
!              THE COMPLEX DEMODULATION CONSISTS OF THE FOLLOWING--
!              1) AN AMPLITUDE VERSUS TIME PLOT;
!              2) A PHASE VERSUS TIME PLOT;
!              3) AN UPDATED DEMODULATION FREQUENCY ESTIMATE
!                 TO ASSIST THE ANALYST IN DETERMINING A
!                 MORE APPROPRIATE FREQUENCY AT WHICH
!                 TO DEMODULATE IN CASE THE SPECIFIED
!                 INPUT DEMODULATION FREQUENCY F
!                 DOES NOT FLATTEN SUFFICIENTLY THE
!                 PHASE PLOT.
!
!              THE ALLOWABLE RANGE OF THE INPUT DEMODULATION
!              FREQUENCY F IS 0.0 TO 0.5 (EXCLUSIVELY).
!              THE INPUT DEMODULATION FREQUENCY F IS MEASURED  OF
!              IN UNITS OF CYCLES PER 'DATA POINT' OR,
!              MORE PRECISELY, IN CYCLES PER UNIT TIME WHERE
!              'UNIT TIME' IS DEFINED AS THE
!              ELAPSED TIME BETWEEN ADJACENT OBSERVATIONS.
!
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED) OBSERVATIONS.
!                      N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!                      F      = THE SINGLE PRECISION
!                               DEMODULATION FREQUENCY.
!                               F IS IN UNITS OF CYCLES PER DATA POINT.
!                               F IS BETWEEN 0.0 AND 0.5 (EXCLUSIVELY).
!     OUTPUT--2 PAGES OF AUTOMATIC PRINTOUT--
!             1) AN AMPLITUDE PLOT;
!             2) A PHASE PLOT; AND
!             3) AN UPDATED DEMODULATION FREQUENCY ESTIMATE.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 5000.
!                 --THE SAMPLE SIZE N MUST BE GREATER
!                   THAN OR EQUAL TO 3.
!                 --THE INPUT FREQUENCY F MUST BE
!                   GREATER THAN OR EQUAL TO 2/(N-2).
!                 --THE INPUT FREQUENCY F MUST BE
!                   SMALLER THAN 0.5.
!     OTHER DATAPAC   SUBROUTINES NEEDED--PLOTX.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, SIN, COS, ATAN.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--IN ORDER THAT THE RESULTS OF THE COMPLEX DEMODULATION
!              BE VALID AND PROPERLY INTERPRETED, THE INPUT DATA
!              IN X SHOULD BE EQUI-SPACED IN TIME
!              (OR WHATEVER VARIABLE CORRESPONDS TO TIME).
!            --IF THE INPUT OBSERVATIONS IN X ARE CONSIDERED
!              TO HAVE BEEN COLLECTED 1 SECOND APART IN TIME,
!              THEN THE DEMODULATION FREQUENCY F
!              WOULD BE IN UNITS OF HERTZ
!              (= CYCLES PER SECOND).
!            --A FREQUENCY OF 0.0 CORRESPONDS TO A CYCLE
!              IN THE DATA OF INFINITE (= 1/(0.0))
!              LENGTH OR PERIOD.
!              A FREQUENCY OF 0.5 CORRESPONDS TO A CYCLE
!              IN THE DATA OF LENGTH = 1/(0.5) = 2 DATA POINTS.
!            --IN EXAMINING THE AMPLITUDE AND PHASE PLOTS,
!              ATTENTION SHOULD BE PAID NOT ONLY TO THE
!              STRUCTURE OF THE PHASE PLOT
!              (NEAR-ZERO SLOPE VERSUS NON-ZERO SLOPE)
!              BUT ALSO TO THE RANGE
!              OF VALUES ON THE VERTICAL AXIS.
!              A PLOT WITH MUCH STRUCTURE BUT
!              WITH A SMALL RANGE ON THE VERTICAL AXIS
!              IS USUALLY MORE INDICATIVE OF A
!              DEFINITE CYCLIC COMPONENT AT THE
!              SPECIFIED INPUT DEMODULATION FREQUENCY,
!              THAN IS A PLOT WITH LESS STRUCTURE BUT
!              A WIDER RANGE ON THE VERTICAL AXIS.
!            --INTERNAL TO THIS SUBROUTINE, 2 MOVING
!              AVERAGES ARE APPLIED, EACH OF LENGTH 1/F.
!              HENCE THE AMPLITUDE AND PHASE PLOTS
!              HAVE N - 2/F VALUES
!              (RATHER THAN N VALUES) ALONG THE
!              HORIZONTAL (TIME) AXIS.
!              IN ORDER THAT THE AMPLITUDE AND PHASE
!              PLOTS BE NON-EMPTY, AN INPUT
!              REQUIREMENT ON F FOR THIS SUBROUTINE
!              IS THAT THE SAMPLE SIZE N
!              AND THE DEMODULATION FREQUENCY F
!              MUST BE SUCH THAT
!              N - 2/F BE GREATER THAN ZERO.
!              FURTHER, SINCE A PLOT WITH BUT
!              1 POINT IS MEANINGLESS
!              AND OUGHT ALSO BE EXCLUDED,
!              THE REQUIREMENT IS EXTENDED
!              SO THAT N - 2/F MUST BE GREATER THAN 1.
!     REFERENCES--GRANGER AND HATANAKA, PAGES 170 TO 189,
!                 ESPECIALLY PAGES 173, 177, AND 182.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1972.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y1(5000) , Y2(5000) , Z(5000)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y1(1),WS(1))
      EQUIVALENCE (Y2(1),WS(5001))
      EQUIVALENCE (Z(1),WS(10001))
      DATA pi/3.141592653/
!
      ipr = 6
      ilower = 3
      iupper = 5000
      an = N
      fmin = 2.0/(an-2.0)
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<ilower .OR. N>iupper ) THEN
         WRITE (ipr,99001) ilower , iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE DEMOD  SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (',I6,',',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( F<=fmin .OR. F>=0.5 ) THEN
            WRITE (ipr,99003) fmin
99003       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE THIRD INPUT ARGUMENT TO THE  DEMOD  SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (',F10.8,',0.5) ','INTERVAL *****')
            WRITE (ipr,99004) F
99004       FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,    &
     &              ' *****')
            WRITE (ipr,99005) fmin , N
99005       FORMAT (' ','                   THE ABOVE LOWER LIMIT (',   &
     &              F10.8,                                              &
     &              ') = 2/(N-2) WHERE N = THE INPUT SAMPLE SIZE = ',I8)
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99006) hold
99006       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE DEMOD  SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
!     FORM THE COSINE AND SINE SERIES
!
 50      DO i = 1 , N
            ai = i
            Y1(i) = X(i)*COS(6.2831853*F*ai)
            Y2(i) = X(i)*SIN(6.2831853*F*ai)
         ENDDO
!
!     DEFINE THE LENGTH OF THE 2 MOVING AVERAGES
!
         lenma1 = 1.0/F
         lenma2 = 1.0/F
         alen1 = lenma1
         alen2 = lenma2
         imax1 = N - lenma1
         imax2 = imax1 - lenma2
!
!     FORM THE FIRST MOVING AVERAGE FOR THE COSINE SERIES
!
         DO i = 1 , imax1
            istart = i + 1
            iend = i + lenma1 - 1
            iendp1 = i + lenma1
            sum = 0.0
            DO j = istart , iend
               sum = sum + Y1(j)
            ENDDO
            sum = sum + Y1(i)/2.0 + Y1(iendp1)/2.0
            Z(i) = sum/alen1
         ENDDO
!
!     FORM THE SECOND MOVING AVERAGE FOR THE COSINE SERIES
!
         DO i = 1 , imax2
            istart = i + 1
            iend = i + lenma2 - 1
            iendp1 = i + lenma2
            sum = 0.0
            DO j = istart , iend
               sum = sum + Z(j)
            ENDDO
            sum = sum + Z(i)/2.0 + Z(iendp1)/2.0
            Y1(i) = sum/alen2
         ENDDO
!
!     FORM THE FIRST MOVING AVERAGE FOR THE SINE SERIES
!
         DO i = 1 , imax1
            istart = i + 1
            iend = i + lenma1 - 1
            iendp1 = i + lenma1
            sum = 0.0
            DO j = istart , iend
               sum = sum + Y2(j)
            ENDDO
            sum = sum + Y2(i)/2.0 + Y2(iendp1)/2.0
            Z(i) = sum/alen1
         ENDDO
!
!     FORM THE SECOND MOVING AVERAGE FOR THE SINE SERIES
!
         DO i = 1 , imax2
            istart = i + 1
            iend = i + lenma1 - 1
            iendp1 = i + lenma1
            sum = 0.0
            DO j = istart , iend
               sum = sum + Z(j)
            ENDDO
            sum = sum + Z(i)/2.0 + Z(iendp1)/2.0
            Y2(i) = sum/alen2
         ENDDO
!
!
!     FORM THE AMPLITUDES AND PLOT THEM
!
         DO i = 1 , imax2
            Z(i) = 2.0*SQRT(Y1(i)*Y1(i)+Y2(i)*Y2(i))
         ENDDO
         CALL PLOTX(Z,imax2)
         WRITE (ipr,99007) F
!
99007    FORMAT (' ',30X,                                               &
     &           'AMPLITUDE PLOT FOR THE DEMODULATION FREQUENCY = ',    &
     &           F8.6,' CYCLES PER UNIT TIME')
!
!     COMPUTE THE DIFFERENCE BETWEEN THE MAX AND MIN AMPLITUDES AND WRITE IT OUT
!
         zmin = Z(1)
         zmax = Z(1)
         DO i = 1 , imax2
            IF ( Z(i)<zmin ) zmin = Z(i)
            IF ( Z(i)>zmax ) zmax = Z(i)
         ENDDO
         range = zmax - zmin
         WRITE (ipr,99008) zmin , zmax , range
99008    FORMAT (' ',9X,'MINIMUM AMPLITUDE = ',E15.8,5X,                &
     &           'MAXIMUM AMPLITUDE = ',E15.8,5X,                       &
     &           'RANGE OF AMPLITUDES = ',E15.8)
!
!     FORM THE PHASES AND PLOT THEM
!
         DO i = 1 , imax2
            Z(i) = ATAN(Y1(i)/Y2(i))
         ENDDO
         CALL PLOTX(Z,imax2)
         WRITE (ipr,99009) F
99009    FORMAT (' ',32X,'PHASE PLOT FOR THE DEMODULATION FREQUENCY = ',&
     &           F8.6,' CYCLES PER UNIT TIME')
!
!     COMPUTE A NEW ESTIMATE FOR THE DEMODULATION FREQUENCY AND WRITE IT OUT
!
         aimax2 = imax2
         imax2m = imax2 - 1
         iflag = 0
         zmin = Z(1)
         zmax = Z(1)
         DO i = 1 , imax2m
            ip1 = i + 1
            del = Z(ip1) - Z(i)
            IF ( del>2.5 ) iflag = iflag - 1
            IF ( del<-2.5 ) iflag = iflag + 1
            aiflag = iflag
            znew = Z(ip1) + aiflag*pi
            IF ( znew<zmin ) zmin = znew
            IF ( znew>zmax ) zmax = znew
         ENDDO
         range = zmax - zmin
         sloper = range/aimax2
         slopeh = sloper/(2.0*pi)
         fest = F + slopeh
         WRITE (ipr,99010) zmin , zmax , range
99010    FORMAT (' ',3X,'MINIMUM PHASE = ',E15.8,' RADIANS   ',         &
     &           'MAXIMUM PHASE = ',E15.8,' RADIANS   ',                &
     &           'RANGE OF PHASES = ',E15.8,' RADIANS')
         WRITE (ipr,99011) sloper , slopeh , fest
99011    FORMAT (' ','SLOPE = ',E14.8,' RADIANS = ',E14.6,              &
     &           ' CYCLES PER UNIT TIME    EST. OF NEW DEMOD. FREQ. = ',&
     &           E15.8,' CYC./UNIT TIME')
      ENDIF
!
      END SUBROUTINE DEMOD
!*==dexcdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE DEXCDF(X,Cdf)
      IMPLICIT NONE
!*--DEXCDF3893
!*** Start of declarations inserted by SPAG
      REAL Cdf , X
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT DEXCDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR THE DOUBLE EXPONENTIAL
!              (LAPLACE) DISTRIBUTION WITH MEAN = 0 AND
!              STANDARD DEVIATION = SQRT(2).
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = 0.5*EXP(-ABS(X)).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF.
!     PRINTING--NONE.
!     RESTRICTIONS--NONE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 22-36.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS.
!     NO INPUT ARGUMENT ERRORS POSSIBLE
!     FOR THIS DISTRIBUTION.
!
!-----START POINT-----------------------------------------------------
!
      IF ( X<=0.0 ) Cdf = 0.5*EXP(X)
      IF ( X>0.0 ) Cdf = 1.0 - (0.5*EXP(-X))
!
      END SUBROUTINE DEXCDF
!*==dexpdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE DEXPDF(X,Pdf)
      IMPLICIT NONE
!*--DEXPDF3949
!*** Start of declarations inserted by SPAG
      REAL arg , Pdf , X
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT DEXPDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PROBABILITY DENSITY
!              FUNCTION VALUE FOR THE DOUBLE EXPONENTIAL
!              (LAPLACE) DISTRIBUTION WITH MEAN = 0 AND
!              STANDARD DEVIAITON = SQRT(2).
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = 0.5*EXP(-ABS(X)).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE PROBABILITY DENSITY
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--PDF    = THE SINGLE PRECISION PROBABILITY
!                                DENSITY FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PROBABILITY DENSITY
!             FUNCTION VALUE PDF.
!     PRINTING--NONE.
!     RESTRICTIONS--NONE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 22-36.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --SEPTEMBER 1978.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS.
!     NO INPUT ARGUMENT ERRORS POSSIBLE
!     FOR THIS DISTRIBUTION.
!
!-----START POINT-----------------------------------------------------
!
      arg = X
      IF ( X<0.0 ) arg = -X
      Pdf = 0.5*EXP(-arg)
!
      END SUBROUTINE DEXPDF
!*==dexplt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE DEXPLT(X,N)
      IMPLICIT NONE
!*--DEXPLT4007
!*** Start of declarations inserted by SPAG
      REAL an , cc , hold , q , sum1 , sum2 , sum3 , tau , W , wbar ,   &
     &     WS , X , Y , ybar , yint , yslope
      INTEGER i , ipr , iupper , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT DEXPLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES A DOUBLE EXPONENTIAL (LAPLACE)
!              PROBABILITY PLOT.
!              THE PROTOTYPE DOUBLE EXPONENTIAL DISTRIBUTION USED HEREIN
!              HAS MEAN = 0 AND STANDARD DEVIATION = SQRT(2).
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = 0.5 * EXP(-ABS(X)).
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE DOUBLE EXPONENTIAL PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE DOUBLE EXPONENTIAL DISTRIBUTION.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!     OUTPUT--A ONE-PAGE DOUBLE EXPONENTIAL PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 22-36.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
!
      DATA tau/1.76862179/
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE DEXPLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE DEXP&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE DEXPLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     COMPUTE DOUBLE EXPONENTIAL ORDER STATISTIC MEDIANS
!
         DO i = 1 , N
            q = W(i)
            IF ( q<=0.5 ) W(i) = ALOG(2.0*q)
            IF ( q>0.5 ) W(i) = -ALOG(2.0*(1.0-q))
         ENDDO
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         WRITE (ipr,99005) tau , N
!
99005    FORMAT (' ','DOUBLE EXPONENTIAL PROBABILITY PLOT (TAU = ',     &
     &           E15.8,')',44X,'THE SAMPLE SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
         ENDDO
         ybar = sum1/an
         wbar = 0.0
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + W(i)*Y(i)
            sum3 = sum3 + W(i)*W(i)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99006) cc , yint , yslope
99006    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
!
      END SUBROUTINE DEXPLT
!*==dexppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE DEXPPF(P,Ppf)
      IMPLICIT NONE
!*--DEXPPF4168
!*** Start of declarations inserted by SPAG
      INTEGER ipr
      REAL P , Ppf
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT DEXPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE DOUBLE EXPONENTIAL
!              (LAPLACE) DISTRIBUTION WITH MEAN = 0 AND
!              STANDARD DEVIATION = SQRT(2).
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = 0.5*EXP(-ABS(X)).
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT
!             FUNCTION VALUE PPF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0 AND 1.0, EXCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 22-36.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE DEXPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         IF ( P<=0.5 ) Ppf = ALOG(2.0*P)
         IF ( P>0.5 ) Ppf = -ALOG(2.0*(1.0-P))
      ENDIF
!
      END SUBROUTINE DEXPPF
!*==dexran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE DEXRAN(N,Istart,X)
      IMPLICIT NONE
!*--DEXRAN4244
!*** Start of declarations inserted by SPAG
      INTEGER i , ipr , Istart , N
      REAL q , X
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT DEXRAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE DOUBLE EXPONENTIAL
!              (LAPLACE) DISTRIBUTION WITH MEAN = 0 AND
!              STANDARD DEVIATION = SQRT(2).
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = 0.5*EXP(-ABS(X)).
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!                     --ISTART = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL START THE
!                                GENERATOR OVER AND HENCE
!                                PRODUCE THE SAME RANDOM SAMPLE
!                                OVER AND OVER AGAIN
!                                UPON SUCCESSIVE CALLS TO
!                                THIS SUBROUTINE WITHIN A RUN; OR
!                                (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0,
!                                LIKE, SAY, 1) WILL ALLOW
!                                THE GENERATOR TO CONTINUE
!                                FROM WHERE IT STOPPED
!                                AND HENCE PRODUCE DIFFERENT
!                                RANDOM SAMPLES UPON
!                                SUCCESSIVE CALLS TO
!                                THIS SUBROUTINE WITHIN A RUN.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE DOUBLE EXPONENTIAL
!             (LAPLACE) DISTRIBUTION WITH MEAN = 0 AND
!             STANDARD DEVIATION = SQRT(2).
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 14-15.
!               --HAMMERSLEY AND HANDSCOMB, MONTE CARLO METHODS,
!                 1964, PAGE 36.
!               --FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGE 231.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 22-36.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE DEXRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
!     GENERATE N UNIFORM (0,1) RANDOM NUMBERS;
!
         CALL UNIRAN(N,Istart,X)
!
!     GENERATE N DOUBLE EXPONENTIAL RANDOM NUMBERS
!     USING THE PERCENT POINT FUNCTION TRANSFORMATION METHOD.
!
         DO i = 1 , N
            q = X(i)
            IF ( q<=0.5 ) X(i) = ALOG(2.0*q)
            IF ( q>0.5 ) X(i) = -ALOG(2.0*(1.0-q))
         ENDDO
      ENDIF
!
      END SUBROUTINE DEXRAN
!*==dexsf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE DEXSF(P,Sf)
      IMPLICIT NONE
!*--DEXSF4352
!*** Start of declarations inserted by SPAG
      INTEGER ipr
      REAL P , Sf
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT DEXSF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE SPARSITY
!              FUNCTION VALUE FOR THE DOUBLE EXPONENTIAL
!              (LAPLACE) DISTRIBUTION WITH MEAN = 0 AND
!              STANDARD DEVIATION = SQRT(2).
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = 0.5*EXP(-ABS(X)).
!              NOTE THAT THE SPARSITY FUNCTION OF A DISTRIBUTION
!              IS THE DERIVATIVE OF THE PERCENT POINT FUNCTION,
!              AND ALSO IS THE RECIPROCAL OF THE PROBABILITY
!              DENSITY FUNCTION (BUT IN UNITS OF P RATHER THAN X).
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                AT WHICH THE SPARSITY
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--SF     = THE SINGLE PRECISION
!                                SPARSITY FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION SPARSITY
!             FUNCTION VALUE SF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0 AND 1.0, EXCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 22-36.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE DEXSF  SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         IF ( P<=0.5 ) Sf = 1.0/P
         IF ( P>0.5 ) Sf = 1.0/(1.0-P)
      ENDIF
!
      END SUBROUTINE DEXSF
!*==discr2.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE DISCR2(X,N,Numcla,Y)
      IMPLICIT NONE
!*--DISCR24429
!*** Start of declarations inserted by SPAG
      REAL ai , anuml , classm , cmax , cmin , hold , p , X , xdel ,    &
     &     xmax , xmin , Y
      INTEGER i , icount , ip , ipr , iupncl , N , Numcla
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT DISCR2
!
!     PURPOSE--THIS SUBROUTINE 'DISCRETIZES' THE DATA
!              OF THE SINGLE PRECISION VECTOR X
!              INTO NUMCLA CLASSES.
!              ALL VALUES IN THE VECTOR X WITHIN A GIVEN CLASS
!              WILL BE MAPPED INTO THE MIDPOINT OF THAT CLASS.
!              THE SAMPLE MINIMUM AND SAMPLE MAXIMUM
!              ARE AUTOMATICALLY COMPUTED INTERNALLY
!              AND THE CLASS WIDTH (XDEL) IS COMPUTED AS
!              THE (SAMPLE MAX - SAMPLE MIN)/NUMCLA.
!              THE FIRST CLASS INTERVAL IS FROM
!              THE SAMPLE MIN TO THE SAMPLE MIN + XDEL;
!              THE SECOND CLASS INTERVAL IS FROM
!              THE SAMPLE MIN + XDEL TO
!              THE SAMPLE MIN + 2*XDEL;
!              ...;
!              THE LAST CLASS INTERVAL IS FROM
!              THE SAMPLE MAX - XDEL TO THE SAMPLE MAX.
!              THE USE OF THIS SUBROUTINE
!              (AND THE DISCRE AND DISCR3 SUBROUTINES)
!              GIVES THE DATA ANALYST THE CAPABILITY OF
!              CONSTRUCTING A DISCRETE VARIATE FROM
!              A CONTINUOUS ONE.
!              THE RESULTING DISCRETE VARIATE MIGHT THEN
!              (FOR EXAMPLE) BE ANALYZED IN ITSELF FOR
!              GROSS STRUCTURE, OR FOR ADHERENCE TO SOME
!              THEROETICAL DISCRETE PROBABILITY MODEL,
!              OR THE DISCRETE VARIATE MIGHT BE USED
!              AS A SUBSET DEFINITION VECTOR FOR SOME
!              OTHER VARIATE.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                                TO BE DISCRETIZED.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --NUMLEV = THE INTEGER NUMBER OF CLASSES
!                                DESIRED IN THE DISCRETIZATION.
!     OUTPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR OF
!                                DISCRETIZED VALUES (= THE CLASS
!                                MIDPOINTS) CORRESPONDING TO
!                                THE CONTINUOUS VALUES IN THE VECTOR X.
!                                THERE WILL RESULT N SUCH DISCRETIZED
!                                VALUES.
!     OUTPUT--THE SINGLE PRECISION VECTOR Y
!             WHICH CONTAINS N DISCRETIZED VALUES
!             (= THE CLASS MIDPOINTS)
!             CORRESPONDING TO THE N
!             CONTINUOUS VALUES IN THE
!             INPUT VECTOR X.
!             ALSO, (NUMCLA+5) LINES OF SUMMARY INFORMATION
!             WILL BE GENERATED INDICATING
!             1) WHAT THE SAMPLE SIZE IS (N);
!             2) WHAT THE NUMBER OF CLASSES IS (NUMCLA).
!             3) WHAT THE CLASS BOUNDARIES AND
!                THE NUMBER OF OBSERVATIONS
!                FALLING IN EACH CLASS ARE.
!     PRINTING--YES
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!                 --NUMCLA SHOULD BE POSITIVE AND NOT EXCEED 1000
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--THIS SUBROUTINE DIFFERS FROM THE DISCR3
!              SUBROUTINE INASMUCH AS THIS SUBROUTINE
!              PERFORMS ITS DISCRETIZATION BY OUTPUTING
!              CLASS MIDPOINTS, WHEREAS THE DISCR3
!              SUBROUTINE OUTPUTS CLASS NUMBERS
!              (1, 2, ... , NUMCLA).
!     COMMENT--THE INPUT VECTOR X REMAINS UNALTERED.
!     COMMENT--IN THE MAIN (CALLING) ROUTINE, IT IS
!              PERMISSABLE (IF THE ANALYST SO DESIRES)
!              TO USE THE SAME VARIABLE NAME
!              IN THE FOURTH ARGUMENT AS USED IN THE FIRST
!              ARGUMENT IN THE CALLING SEQUENCE TO THIS
!              DISCR2 SUBROUTINE--NO CONFLICT WILL RESULT
!              IN THE INTERNAL OPERATION OF THE     DISCR2
!              SUBROUTINE.  FOR EXAMPLE, IT IS PERMISSIBLE
!              TO HAVE        CALL DISCR2(X,N,10,X)
!              IN WHICH THE VARIABLE NAME      X    IS USED
!              AS BOTH THE FIRST AND FOURTH ARGUMENTS.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1974.
!     UPDATED         --APRIL     1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1) , Y(1)
      DIMENSION icount(1000)
      DIMENSION classm(1000)
!
      ipr = 6
      iupncl = 1000
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE DISCR2 SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99015) N
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE DISC&
     &R2 SUBROUTINE HAS THE VALUE 1 *****')
         Y(1) = X(1)
         RETURN
      ELSEIF ( Numcla<1 .OR. Numcla>iupncl ) THEN
         WRITE (ipr,99003) iupncl
99003    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE DISCR2 SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99015) Numcla
         DO i = 1 , N
            Y(i) = 0.0
         ENDDO
         RETURN
      ELSE
         IF ( Numcla==1 ) THEN
            WRITE (ipr,99004)
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE THIRD  INPUT ARGUMENT TO THE DISC&
     &R2 SUBROUTINE HAS THE VALUE 1 *****')
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99005) hold
99005       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE DISCR2 SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
            DO i = 1 , N
               Y(i) = X(i)
            ENDDO
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      anuml = Numcla
!
!     ZERO OUT THE COUNT VECTOR (ICOUNT)
!
         DO i = 1 , Numcla
            icount(i) = 0
         ENDDO
!
!     COMPUTE THE SAMPLE MINIMUM AND MAXIMUM,
!     THEN COMPUTE THE CLASS WIDTH.
!
         xmin = X(1)
         xmax = X(1)
         DO i = 1 , N
            IF ( X(i)<xmin ) xmin = X(i)
            IF ( X(i)>xmax ) xmax = X(i)
         ENDDO
         xdel = (xmax-xmin)/anuml
!
!     COMPUTE THE CLASS MIDPOINT FOR EACH CLASS
!
         DO i = 1 , Numcla
            ai = i
            classm(i) = xmin + (ai-0.5)*xdel
         ENDDO
!
!     PERFORM THE DISCRETIZING TRANSFORMATION.
!     ALSO, KEEP A FREQUENCY COUNT FOR EACH CLASS.
!
         DO i = 1 , N
            p = (X(i)-xmin)/(xmax-xmin)
            p = p*anuml + 1.0
            ip = p
            IF ( ip<1 ) ip = 1
            IF ( ip>Numcla ) ip = Numcla
            Y(i) = classm(ip)
            icount(ip) = icount(ip) + 1
         ENDDO
!
!     COMPUTE CLASS LIMITS AND WRITE OUT SUMMARY INFORMATION.
!
         WRITE (ipr,99016)
         WRITE (ipr,99006)
!
99006    FORMAT (' ','OUTPUT FROM THE DISCR2 SUBROUTINE--')
         WRITE (ipr,99016)
         WRITE (ipr,99007) N
99007    FORMAT (' ',7X,'NUMBER OF OBSERVATIONS            = ',I8)
         WRITE (ipr,99008) Numcla
99008    FORMAT (' ',7X,'SPECIFIED NUMBER OF LEVELS        = ',I8)
         WRITE (ipr,99009) xmin
99009    FORMAT (' ',7X,'COMPUTED  LOWER BOUND OF INTERVAL = ',F15.7)
         WRITE (ipr,99010) xdel
99010    FORMAT (' ',7X,'COMPUTED  CLASS WIDTH             = ',F15.7)
         WRITE (ipr,99011) xmax
99011    FORMAT (' ',7X,'COMPUTED  UPPER BOUND OF INTERVAL = ',F15.7)
         WRITE (ipr,99016)
         WRITE (ipr,99012)
99012    FORMAT (' ',                                                   &
     &           '       CLASS     MINIMUM       MIDPOINT      MAXIMUM',&
     &           '      COUNT')
         WRITE (ipr,99013)
99013    FORMAT (' ',                                                   &
     &           '       -------------------------------------------',  &
     &           '-------------')
         DO i = 1 , Numcla
            ai = i
            cmin = xmin + (ai-1.0)*xdel
            cmax = xmin + ai*xdel
            WRITE (ipr,99014) i , cmin , classm(i) , cmax , icount(i)
99014       FORMAT (' ',4X,I6,2X,3F14.7,I8)
         ENDDO
      ENDIF
99015 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
99016 FORMAT (' ')
!
      END SUBROUTINE DISCR2
!*==discr3.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE DISCR3(X,N,Numcla,Y)
      IMPLICIT NONE
!*--DISCR34667
!*** Start of declarations inserted by SPAG
      REAL ai , anuml , cmax , cmin , hold , p , X , xdel , xmax ,      &
     &     xmin , Y
      INTEGER i , icount , ip , ipr , iupncl , N , Numcla
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT DISCR3
!
!     PURPOSE--THIS SUBROUTINE 'DISCRETIZES' THE DATA
!              ON THE SINGLE PRECISION VECTOR X
!              INTO NUMCLA CLASSES.
!              ALL VALUES IN THE VECTOR X WITHIN A GIVEN CLASS
!              WILL BE MAPPED INTO THE CLASS NUMBER
!              (1, 2, ... , NUMCLA).
!              THUS ALL THE ELEMENTS IN THE LOWERMOST CLASS
!              WILL BE MAPPED INTO THE VALUE 1.0;
!              ALL THE ELEMENTS OF X IN THE NEXT HIGHER CLASS
!              WILL BE MAPPED INTO 2.0;
!              ETC.
!              THE SAMPLE MINIMUM AND SAMPLE MAXIMUM
!              ARE AUTOMATICALLY COMPUTED INTERNALLY
!              AND THE CLASS WIDTH (XDEL) IS COMPUTED AS
!              THE (SAMPLE MAX - SAMPLE MIN)/NUMCLA.
!              THE FIRST CLASS INTERVAL IS FROM
!              THE SAMPLE MIN TO THE SAMPLE MIN + XDEL;
!              THE SECOND CLASS INTERVAL IS FROM
!              THE SAMPLE MIN + XDEL TO
!              THE SAMPLE MIN + 2*XDEL;
!              ...;
!              THE LAST CLASS INTERVAL IS FROM
!              THE SAMPLE MAX - XDEL TO THE SAMPLE MAX.
!              THE USE OF THIS SUBROUTINE
!              (AND THE DISCRE AND DISCR2 SUBROUTINES)
!              GIVES THE DATA ANALYST THE CAPABILITY OF
!              CONSTRUCTING A DISCRETE VARIATE FROM
!              A CONTINUOUS ONE.
!              THE RESULTING DISCRETE VARIATE MIGHT THEN
!              (FOR EXAMPLE) BE ANALYZED IN ITSELF FOR
!              GROSS STRUCTURE, OR FOR ADHERENCE TO SOME
!              THEROETICAL DISCRETE PROBABILITY MODEL,
!              OR THE DISCRETE VARIATE MIGHT BE USED
!              AS A SUBSET DEFINITION VECTOR FOR SOME
!              OTHER VARIATE.
!              THIS DISCR3 SUBROUTINE IS PARTICULARLY
!              SUITED TO THIS LAST PURPOSE INASMUCH
!              AS IT OUTPUT'S 1'S, 2'S, ETC.
!              RATHER THAN MIDPOINTS.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                                TO BE DISCRETIZED.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --NUMLEV = THE INTEGER NUMBER OF CLASSES
!                                DESIRED IN THE DISCRETIZATION.
!     OUTPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR OF
!                                DISCRETIZED VALUES CORRESPONDING TO
!                                THE CONTINUOUS VALUES IN THE VECTOR X.
!                                THERE WILL RESULT N SUCH DISCRETIZED
!                                VALUES.
!     OUTPUT--THE SINGLE PRECISION VECTOR Y
!             WHICH CONTAINS N DISCRETIZED VALUES
!             CORRESPONDING TO THE N
!             CONTINUOUS VALUES IN THE
!             INPUT VECTOR X.
!             ALSO, (NUMCLA+5) LINES OF SUMMARY INFORMATION
!             WILL BE GENERATED INDICATING
!             1) WHAT THE SAMPLE SIZE IS (N);
!             2) WHAT THE NUMBER OF CLASSES IS (NUMCLA).
!             3) WHAT THE CLASS BOUNDARIES AND
!                THE NUMBER OF OBSERVATIONS
!                FALLING IN EACH CLASS ARE.
!     PRINTING--YES
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!                 --NUMCLA SHOULD BE POSITIVE AND NOT EXCEED 1000
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--THIS SUBROUTINE DIFFERS FROM THE DISCR2
!              SUBROUTINE INASMUCH AS THIS SUBROUTINE
!              PERFORMS ITS DISCRETIZATION BY OUTPUTING
!              CLASS NUMBERS (1, 2,, ..., NUMCLA);
!              WHEREAS THE DISCR2 SUBROUTINE
!              OUTPUTS CLASS MIDPOINTS.
!     COMMENT--THE INPUT VECTOR X REMAINS UNALTERED.
!     COMMENT--IN THE MAIN (CALLING) ROUTINE, IT IS
!              PERMISSABLE (IF THE ANALYST SO DESIRES)
!              TO USE THE SAME VARIABLE NAME
!              IN THE FOURTH ARGUMENT AS USED IN THE FIRST
!              ARGUMENT IN THE CALLING SEQUENCE TO THIS
!              DISCR3 SUBROUTINE--NO CONFLICT WILL RESULT
!              IN THE INTERNAL OPERATION OF THE     DISCR3
!              SUBROUTINE.  FOR EXAMPLE, IT IS PERMISSIBLE
!              TO HAVE        CALL DISCR3(X,N,10,X)
!              IN WHICH THE VARIABLE NAME      X    IS USED
!              AS BOTH THE FIRST AND FOURTH ARGUMENTS.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1974.
!     UPDATED         --APRIL     1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1) , Y(1)
      DIMENSION icount(1000)
!
      ipr = 6
      iupncl = 1000
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE DISCR3 SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99015) N
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE DISC&
     &R3 SUBROUTINE HAS THE VALUE 1 *****')
         Y(1) = X(1)
         RETURN
      ELSEIF ( Numcla<1 .OR. Numcla>iupncl ) THEN
         WRITE (ipr,99003) iupncl
99003    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE DISCR3 SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99015) Numcla
         DO i = 1 , N
            Y(i) = 0.0
         ENDDO
         RETURN
      ELSE
         IF ( Numcla==1 ) THEN
            WRITE (ipr,99004)
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE THIRD  INPUT ARGUMENT TO THE DISC&
     &R3 SUBROUTINE HAS THE VALUE 1 *****')
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99005) hold
99005       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE DISCR3 SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
            DO i = 1 , N
               Y(i) = X(i)
            ENDDO
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      anuml = Numcla
!
!     ZERO OUT THE COUNT VECTOR (ICOUNT)
!
         DO i = 1 , Numcla
            icount(i) = 0
         ENDDO
!
!     COMPUTE THE SAMPLE MINIMUM AND MAXIMUM,
!     THEN COMPUTE THE CLASS WIDTH.
!
         xmin = X(1)
         xmax = X(1)
         DO i = 1 , N
            IF ( X(i)<xmin ) xmin = X(i)
            IF ( X(i)>xmax ) xmax = X(i)
         ENDDO
         xdel = (xmax-xmin)/anuml
!
!     PERFORM THE DISCRETIZING TRANSFORMATION.
!     ALSO, KEEP A FREQUENCY COUNT FOR EACH CLASS.
!
         DO i = 1 , N
            p = (X(i)-xmin)/(xmax-xmin)
            p = p*anuml + 1.0
            ip = p
            IF ( ip<1 ) ip = 1
            IF ( ip>Numcla ) ip = Numcla
            Y(i) = ip
            icount(ip) = icount(ip) + 1
         ENDDO
!
!     COMPUTE CLASS LIMITS AND WRITE OUT SUMMARY INFORMATION.
!
         WRITE (ipr,99016)
         WRITE (ipr,99006)
!
99006    FORMAT (' ','OUTPUT FROM THE DISCR3 SUBROUTINE--')
         WRITE (ipr,99016)
         WRITE (ipr,99007) N
99007    FORMAT (' ',7X,'NUMBER OF OBSERVATIONS            = ',I8)
         WRITE (ipr,99008) Numcla
99008    FORMAT (' ',7X,'SPECIFIED NUMBER OF LEVELS        = ',I8)
         WRITE (ipr,99009) xmin
99009    FORMAT (' ',7X,'COMPUTED  LOWER BOUND OF INTERVAL = ',F15.7)
         WRITE (ipr,99010) xdel
99010    FORMAT (' ',7X,'COMPUTED  CLASS WIDTH             = ',F15.7)
         WRITE (ipr,99011) xmax
99011    FORMAT (' ',7X,'COMPUTED  UPPER BOUND OF INTERVAL = ',F15.7)
         WRITE (ipr,99016)
         WRITE (ipr,99012)
99012    FORMAT (' ','       LEVEL     MINIMUM       MAXIMUM      COUNT'&
     &           )
         WRITE (ipr,99013)
99013    FORMAT (' ','       ------------------------------------------'&
     &           )
         DO i = 1 , Numcla
            ai = i
            cmin = xmin + (ai-1.0)*xdel
            cmax = xmin + ai*xdel
            WRITE (ipr,99014) i , cmin , cmax , icount(i)
99014       FORMAT (' ',4X,I6,2X,2F14.7,I8)
         ENDDO
      ENDIF
99015 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
99016 FORMAT (' ')
!
      END SUBROUTINE DISCR3
!*==discre.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE DISCRE(X,N,Xmin,Xdel,Xmax,Y)
      IMPLICIT NONE
!*--DISCRE4903
!*** Start of declarations inserted by SPAG
      REAL ai , clasml , clasmu , classm , cmax , cmin , hold , pointl ,&
     &     pointu , totdel , X , Xdel , Xmax , Xmin , Y
      INTEGER i , icounl , icount , icounu , ip , ipr , N , numcla
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT DISCRE
!
!     PURPOSE--THIS SUBROUTINE 'DISCRETIZES' THE DATA
!              OF THE SINGLE PRECISION VECTOR X.
!              THE FIRST CLASS INTERVAL IS FROM
!              XMIN TO XMIN + XDEL;
!              THE SECOND CLASS INTERVAL IS FROM
!              XMIN+ XDEL TO XMIN + 2*XDEL;
!              ETC.
!              ALL VALUES IN THE VECTOR X WITHIN A GIVEN CLASS
!              WILL BE MAPPED INTO THE MIDPOINT OF THAT CLASS.
!              ALL VALUES IN THE VECTOR X SMALLER THAN XMIN
!              WILL BE MAPPED INTO XMIN - (XDEL/2.0).
!              ALL VALUES IN THE VECTOR X LARGER THAN XMAX
!              WILL BE MAPPED INTO XMAX + (XDEL/2.0).
!              THE USE OF THIS SUBROUTINE
!              (AND THE DISCR2 AND DISCR3 SUBROUTINES)
!              GIVES THE DATA ANALYST THE CAPABILITY OF
!              CONSTRUCTING A DISCRETE VARIATE FROM
!              A CONTINUOUS ONE.
!              THE RESULTING DISCRETE VARIATE MIGHT THEN
!              (FOR EXAMPLE) BE ANALYZED IN ITSELF FOR
!              GROSS STRUCTURE, OR FOR ADHERENCE TO SOME
!              THEROETICAL DISCRETE PROBABILITY MODEL,
!              OR THE DISCRETE VARIATE MIGHT BE USED
!              AS A SUBSET DEFINITION VECTOR FOR SOME
!              OTHER VARIATE.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                                TO BE DISCRETIZED.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --XMIN   = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES THE LOWER BOUNDARY
!                                (INCLUSIVELY) OF THE LOWERMOST
!                                CLASS.
!                     --XDEL   = THE SINGLE PRECISION VALUE
!                                OF THE CLASS WIDTH.
!                     --XMAX   = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES THE UPPER BOUNDARY
!                                (INCLUSIVELY) OF THE UPPERMOST
!                                CLASS.
!     OUTPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR OF
!                                DISCRETIZED VALUES (= CLASS
!                                MIDPOINTS) CORRESPONDING TO
!                                THE CONTINUOUS VALUES IN THE VECTOR X.
!                                THERE WILL RESULT N SUCH DISCRETIZED
!                                VALUES.
!     OUTPUT--THE SINGLE PRECISION VECTOR Y
!             WHICH CONTAINS N DISCRETIZED VALUES
!             (= CLASS MIDPOINTS)
!             CORRESPONDING TO THE N
!             CONTINUOUS VALUES IN THE
!             INPUT VECTOR X.
!             ALSO, A FEW LINES LINES OF SUMMARY INFORMATION
!             WILL BE GENERATED INDICATING
!             1) WHAT THE SAMPLE SIZE IS (N);
!             2) WHAT THE NUMBER OF CLASSES IS (NUMCLA).
!             3) WHAT THE CLASS BOUNDARIES AND
!                THE NUMBER OF OBSERVATIONS
!                FALLING IN EACH CLASS ARE.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!                 --XDEL SHOULD BE POSITIVE.
!                 --(XMAX-XMIN)/XDEL SHOULD NOT EXCEED 999.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--IT IS SUGGESTED THAT XMIN, XDEL,
!              AND XMAX HAVE AT LEAST 1 MORE
!              DECIMAL PLACE THAN THE DATA VALUES
!              IN THE VECTOR X SO AS TO HELP ASSURE
!              A UNIQUE DISCRETIZATION MAPPING;
!              THAT IS, TO HELP ASSURE THAT
!              NO DATA VALUE WILL FALL
!              EXACTLY ON THE BOUNDARY POINT
!              BETWEEN 2 ADJACENT CLASSES.
!     COMMENT--IN THE MAIN (CALLING) ROUTINE, IT IS
!              PERMISSABLE (IF THE ANALYST SO DESIRES)
!              TO USE THE SAME VARIABLE NAME
!              IN THE SIXTH ARGUMENT AS USED IN THE FIRST
!              ARGUMENT IN THE CALLING SEQUENCE TO THIS
!              DISCRE SUBROUTINE--NO CONFLICT WILL RESULT
!              IN THE INTERNAL OPERATION OF THE     DISCRE
!              SUBROUTINE.  FOR EXAMPLE, IT IS PERMISSIBLE
!              TO HAVE     CALL DISCRE(X,N,0.5,1.0,20.5,X)
!              IN WHICH THE VARIABLE NAME      X    IS USED
!              AS BOTH THE FIRST AND SIXTH ARGUMENTS.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1974.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1) , Y(1)
      DIMENSION icount(1000)
      DIMENSION classm(1000)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE DISCRE SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE DISC&
     &RE SUBROUTINE HAS THE VALUE 1 *****')
         Y(1) = X(1)
         RETURN
      ELSEIF ( Xdel<=0.0 ) THEN
         WRITE (ipr,99004)
99004    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FOURTH INPUT ARGUMENT TO THE DISCRE SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99005) Xdel
99005    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.7,       &
     &           ' *****')
         DO i = 1 , N
            Y(i) = 0.0
         ENDDO
         RETURN
      ELSE
         IF ( Xmin==Xmax ) THEN
            WRITE (ipr,99006)
99006       FORMAT (' ','***** FATAL ERROR--THE THIRD AND FIFTH INPUT ',&
     &              'ARGUMENTS TO THE DISCRE SUBROUTINE ARE IDENTICAL')
            WRITE (ipr,99007) Xmin
99007       FORMAT (' ','***** THE VALUE OF THE ARGUMENTS ARE ',E15.7,  &
     &              ' *****')
            DO i = 1 , N
               Y(i) = 0.0
            ENDDO
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99008) hold
99008       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE DISCRE SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
            DO i = 1 , N
               Y(i) = X(i)
            ENDDO
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
!     DETERMINE THE TRUE INTERVAL MIN AND MAX;
!     THEN DETERMINE THE NUMBER OF CLASSES
!     WITHIN THE SPECIFIED MIN AND MAX.
!
 50      pointl = Xmin
         pointu = Xmax
         IF ( Xmin>Xmax ) pointl = Xmax
         IF ( Xmin>Xmax ) pointu = Xmin
         totdel = pointu - pointl
         numcla = (totdel/Xdel) + 0.999
!
!     ZERO OUT THE COUNT VECTOR (ICOUNT)
!     AND THE LOWER AND UPPER COUNT VARIABLES.
!
         DO i = 1 , numcla
            icount(i) = 0
         ENDDO
         icounl = 0
         icounu = 0
!
!     COMPUTE THE CLASS MIDPOINT FOR EACH CLASS.
!
         DO i = 1 , numcla
            ai = i
            cmin = Xmin + (ai-1.0)*Xdel
            cmax = Xmin + ai*Xdel
            classm(i) = (cmin+cmax)/2.0
         ENDDO
         cmax = pointu
         classm(numcla) = (cmin+cmax)/2.0
!
!     PERFORM THE DISCRETIZING TRANSFORMATION.
!
         DO i = 1 , N
            IF ( X(i)>=pointl .AND. X(i)<=pointu ) THEN
               ip = (X(i)-pointl)/Xdel
               ip = ip + 1
               IF ( ip>numcla ) ip = numcla
               Y(i) = classm(ip)
               icount(ip) = icount(ip) + 1
            ELSEIF ( X(i)<pointl ) THEN
               clasml = pointl - (Xdel/2.0)
               Y(i) = clasml
               icounl = icounl + 1
            ELSEIF ( X(i)>pointu ) THEN
               clasmu = pointu + (Xdel/2.0)
               Y(i) = clasmu
               icounu = icounu + 1
            ENDIF
         ENDDO
!
!     COMPUTE CLASS LIMITS AND WRITE OUT SUMMARY INFORMATION.
!
         WRITE (ipr,99020)
         WRITE (ipr,99009)
!
99009    FORMAT (' ','OUTPUT FROM THE DISCRE SUBROUTINE--')
         WRITE (ipr,99020)
         WRITE (ipr,99010) N
99010    FORMAT (' ',7X,'NUMBER OF OBSERVATIONS            = ',I8)
         WRITE (ipr,99011) Xmin
99011    FORMAT (' ',7X,'SPECIFIED LOWER BOUND OF INTERVAL = ',F15.7)
         WRITE (ipr,99012) Xdel
99012    FORMAT (' ',7X,'SPECIFIED CLASS WIDTH             = ',F15.7)
         WRITE (ipr,99013) Xmax
99013    FORMAT (' ',7X,'SPECIFIED UPPER BOUND OF INTERVAL = ',F15.7)
         WRITE (ipr,99014) numcla
99014    FORMAT (' ',7X,'COMPUTED  NUMBER OF LEVELS        = ',I8)
         WRITE (ipr,99020)
         WRITE (ipr,99015)
99015    FORMAT (' ',                                                   &
     &           '       CLASS     MINIMUM       MIDPOINT      MAXIMUM',&
     &           '      COUNT')
         WRITE (ipr,99016)
99016    FORMAT (' ',                                                   &
     &           '       -------------------------------------------',  &
     &           '-------------')
         IF ( icounl>=1 ) WRITE (ipr,99017) clasml , pointl , icounl
99017    FORMAT (' ',4X,'   BELOW     -INFINITY',2F14.7,I8)
         DO i = 1 , numcla
            ai = i
            cmin = pointl + (ai-1.0)*Xdel
            cmax = pointl + ai*Xdel
            IF ( cmax>pointu ) cmax = pointu
            WRITE (ipr,99018) i , cmin , classm(i) , cmax , icount(i)
99018       FORMAT (' ',4X,I6,2X,3F14.7,I8)
         ENDDO
         IF ( icounu>=1 ) WRITE (ipr,99019) pointu , clasmu , icounu
99019    FORMAT (' ',4X,'   ABOVE',2F14.7,'     +INFINITY',I8)
      ENDIF
99020 FORMAT (' ')
!
      END SUBROUTINE DISCRE
!*==dot.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE DOT(A,B,Imin,Imax,Parpro,Dotpro)
      IMPLICIT NONE
!*--DOT5171
!*** Start of declarations inserted by SPAG
      REAL A , B , Dotpro , Parpro
      INTEGER i , Imax , Imin
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT DOT
!     PURPOSE--TO COMPUTE THE DOT PRODUCT BETWEEN 2 VECTORS--A AND B.
!     ONLY ELEMENTS IMIN THROUGH IMAX OF THE 2 VECTORS ARE CONSIDERED.
!     THE COMPUTED DOT PRODUCT IS ADDED TO THE INPUT VALUE PARPRO
!     TO YIELD A FINAL ANSWER FOR DOTPRO.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DOUBLE PRECISION sum , prod , dparpr
      DIMENSION A(1) , B(1)
!
!-----START POINT-----------------------------------------------------
!
      dparpr = Parpro
      sum = 0.0D0
      IF ( Imin<=Imax ) THEN
         DO i = Imin , Imax
            prod = A(i)*B(i)
            sum = sum + prod
         ENDDO
      ENDIF
      Dotpro = sum + dparpr
!
      END SUBROUTINE DOT
!*==ev1cdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE EV1CDF(X,Cdf)
      IMPLICIT NONE
!*--EV1CDF5205
!*** Start of declarations inserted by SPAG
      REAL Cdf , X
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT EV1CDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR THE EXTREME VALUE TYPE 1
!              DISTRIBUTION.
!              THE EXTREME VALUE TYPE 1 DISTRIBUTION USED
!              HEREIN HAS MEAN = EULER'S NUMBER = 0.57721566
!              AND STANDARD DEVIATION = PI/SQRT(6) = 1.28254983.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (EXP(-X)) * (EXP(-(EXP(-X))))
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE
!                                AT WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF FOR THE EXTREME VALUE TYPE 1
!             DISTRIBUTION WITH MEAN = EULER'S NUMBER = 0.57721566
!             AND STANDARD DEVIATION = PI/SQRT(6) = 1.28254983.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--NONE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 272-295.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS.
!     NO INPUT ARGUMENT ERRORS POSSIBLE
!     FOR THIS DISTRIBUTION.
!
!-----START POINT-----------------------------------------------------
!
      Cdf = 1.0 - EXP(-(EXP(-X)))
!
      END SUBROUTINE EV1CDF
!*==ev1plt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE EV1PLT(X,N)
      IMPLICIT NONE
!*--EV1PLT5262
!*** Start of declarations inserted by SPAG
      REAL an , cc , hold , sum1 , sum2 , sum3 , tau , W , wbar , WS ,  &
     &     X , Y , ybar , yint , yslope
      INTEGER i , ipr , iupper , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT EV1PLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES AN EXTREME VALUE TYPE 1
!              PROBABILITY PLOT.
!              THE PROTOTYPE EXTREME VALUE TYPE 1 DISTRIBUTION USED HERE
!              HAS MEAN = EULER'S NUMBER = 0.57721566
!              AND STANDARD DEVIATION = PI/SQRT(6) = 1.28254983.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (EXP(-X)) * (EXP(-(EXP(-X))))
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE EXTREME VALUE TYPE 1 PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE EXTREME VALUE TYPE 1 DISTRIBUTION.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!     OUTPUT--A ONE-PAGE EXTREME VALUE TYPE 1 PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 272-295.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
!
      DATA tau/1.56186687/
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE EV1PLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE EV1P&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE EV1PLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     COMPUTE EXTREME VALUE TYPE 1 ORDER STATISTIC MEDIANS
!
         DO i = 1 , N
            W(i) = -ALOG(ALOG(1.0/W(i)))
         ENDDO
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         WRITE (ipr,99005) tau , N
!
99005    FORMAT (' ',                                                   &
     &'EXTREME VALUE TYPE 1 (EXPONENTIAL TYPE) PROBABILITY PLOT (TAU = '&
     &,E15.8,')',23X,'THE SAMPLE SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         sum2 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
            sum2 = sum2 + W(i)
         ENDDO
         ybar = sum1/an
         wbar = sum2/an
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + (Y(i)-ybar)*(W(i)-wbar)
            sum3 = sum3 + (W(i)-wbar)*(W(i)-wbar)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99006) cc , yint , yslope
99006    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
!
      END SUBROUTINE EV1PLT
!*==ev1ppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE EV1PPF(P,Ppf)
      IMPLICIT NONE
!*--EV1PPF5425
!*** Start of declarations inserted by SPAG
      INTEGER ipr
      REAL P , Ppf
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT EV1PPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE EXTREME VALUE TYPE 1
!              DISTRIBUTION.
!              THE EXTREME VALUE TYPE 1 DISTRIBUTION USED
!              HEREIN HAS MEAN = EULER'S NUMBER = 0.57721566
!              AND STANDARD DEVIATION = PI/SQRT(6) = 1.28254983.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (EXP(-X)) * (EXP(-(EXP(-X))))
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 (EXCLUSIVELY)
!                                AND 1.0 (EXCLUSIVELY))
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT FUNCTION .
!             VALUE PPF FOR THE EXTREME VALUE TYPE 1 DISTRIBUTION
!             WITH MEAN = EULER'S NUMBER = 0.57721566
!             AND STANDARD DEVIATION = PI/SQRT(6) = 1.28254983.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0 (EXCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 272-295.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE EV1PPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         Ppf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         Ppf = -ALOG(ALOG(1.0/P))
      ENDIF
!
      END SUBROUTINE EV1PPF
!*==ev1ran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE EV1RAN(N,Iseed,X)
      IMPLICIT NONE
!*--EV1RAN5499
!*** Start of declarations inserted by SPAG
      INTEGER i , ipr , Iseed , N
      REAL X
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT EV1RAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE EXTREME VALUE TYPE 1 DISTRIBUTION.
!              THE PROTOTYPE EXTREME VALUE TYPE 1 DISTRIBUTION USED
!              HEREIN HAS MEAN = EULER'S NUMBER = 0.57721566
!              AND STANDARD DEVIATION = PI/SQRT(6) = 1.28254983.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (EXP(-X)) * (EXP(-(EXP(-X))))
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE EXTREME VALUE TYPE 1 DISTRIBUTION
!             WITH MEAN = EULER'S NUMBER = 0.57721566
!             AND STANDARD DEVIATION = PI/SQRT(6) = 1.28254983.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     REFERENCES--TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 14-15.
!               --HAMMERSLEY AND HANDSCOMB, MONTE CARLO METHODS,
!                 1964, PAGE 36.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 272-295.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82/7
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
      ipr = 6
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE EV1RAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
!
!     GENERATE N UNIFORM (0,1) RANDOM NUMBERS;
!
         CALL UNIRAN(N,Iseed,X)
!
!     GENERATE N EXTREME VALUE TYPE 1 RANDOM NUMBERS
!     USING THE PERCENT POINT FUNCTION TRANSFORMATION METHOD.
!
         DO i = 1 , N
            X(i) = -ALOG(ALOG(1.0/X(i)))
         ENDDO
      ENDIF
!
      END SUBROUTINE EV1RAN
!*==ev2cdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE EV2CDF(X,Gamma,Cdf)
      IMPLICIT NONE
!*--EV2CDF5604
!*** Start of declarations inserted by SPAG
      REAL Cdf , Gamma , X
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT EV2CDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR THE EXTREME VALUE TYPE 2
!              DISTRIBUTION WITH SINGLE PRECISION
!              TAIL LENGTH PARAMETER = GAMMA.
!              THE EXTREME VALUE TYPE 2 DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL NON-NEGATIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = GAMMA * (X**(-GAMMA-1)) * EXP(-(X**(-GAMMA))).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE
!                                AT WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!                                X SHOULD BE NON-NEGATIVE.
!                     --GAMMA  = THE SINGLE PRECISION VALUE
!                                OF THE TAIL LENGTH PARAMETER.
!                                GAMMA SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF FOR THE EXTREME VALUE TYPE 2
!             DISTRIBUTION WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--GAMMA SHOULD BE POSITIVE.
!                 --X SHOULD BE NON-NEGATIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 272-295.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( X<0.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE EV2C&
     &DF SUBROUTINE IS NEGATIVE *****')
         WRITE (ipr,99003) X
         Cdf = 0.0
         RETURN
      ELSEIF ( Gamma<=0.0 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE EV2CDF SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99003) Gamma
         Cdf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         Cdf = 0.0
         IF ( X==0.0 ) RETURN
         Cdf = EXP(-(X**(-Gamma)))
      ENDIF
99003 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
      END SUBROUTINE EV2CDF
!*==ev2plt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE EV2PLT(X,N,Gamma)
      IMPLICIT NONE
!*--EV2PLT5684
!*** Start of declarations inserted by SPAG
      REAL an , cc , Gamma , hold , pp0025 , pp025 , pp975 , pp9975 ,   &
     &     q , sum1 , sum2 , sum3 , tau , W , wbar , WS , X , Y , ybar ,&
     &     yint
      REAL yslope
      INTEGER i , ipr , iupper , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT EV2PLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES A EXTREME VALUE TYPE 2
!              PROBABILITY PLOT
!              (WITH TAIL LENGTH PARAMETER VALUE = GAMMA).
!              THE PROTOTYPE EXTREME VALUE TYPE 2 DISTRIBUTION USED     N
!              HEREIN IS DEFINED FOR ALL NON-NEGATIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = GAMMA * (X**(-GAMMA-1)) * EXP(-(X**(-GAMMA))).
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE EXTREME VALUE TYPE 2 PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE  EXTREME VALUE TYPE 2 DISTRIBUTION
!              WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --GAMMA  = THE SINGLE PRECISION VALUE OF THE
!                                TAIL LENGTH PARAMETER.
!                                GAMMA SHOULD BE POSITIVE.
!     OUTPUT--A ONE-PAGE EXTREME VALUE TYPE 2 PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!                 --GAMMA SHOULD BE POSITIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 272-295.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--DECEMBER  1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE EV2PLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE EV2P&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         IF ( Gamma<=0.0 ) THEN
            WRITE (ipr,99004)
99004       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE EV2PLT SUBROU&
     &TINE IS NON-POSITIVE *****')
            WRITE (ipr,99005) Gamma
99005       FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,    &
     &              ' *****')
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99006) hold
99006       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE EV2PLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     COMPUTE EXREME VALUE TYPE 2 DISTRIBUTION ORDER STATISTIC MEDIANS
!
         DO i = 1 , N
            W(i) = (-ALOG(W(i)))**(-1.0/Gamma)
         ENDDO
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     COMPUTE THE TAIL LENGTH MEASURE OF THE DISTRIBUTION.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         q = .9975
         pp9975 = (-ALOG(q))**(-1.0/Gamma)
         q = .0025
         pp0025 = (-ALOG(q))**(-1.0/Gamma)
         q = .975
         pp975 = (-ALOG(q))**(-1.0/Gamma)
         q = .025
         pp025 = (-ALOG(q))**(-1.0/Gamma)
         tau = (pp9975-pp0025)/(pp975-pp025)
         WRITE (ipr,99007) Gamma , tau , N
!
99007    FORMAT (' ',                                                   &
     & 'EXTREME VALUE TYPE 2 (CAUCHY TYPE) PROB. PLOT WITH EXP. PAR. = '&
     & ,E17.10,1X,'(TAU = ',E15.8,')',1X,'SAMPLE SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         sum2 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
            sum2 = sum2 + W(i)
         ENDDO
         ybar = sum1/an
         wbar = sum2/an
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + (Y(i)-ybar)*(W(i)-wbar)
            sum3 = sum3 + (W(i)-wbar)*(W(i)-wbar)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99008) cc , yint , yslope
99008    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
!
      END SUBROUTINE EV2PLT
!*==ev2ppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE EV2PPF(P,Gamma,Ppf)
      IMPLICIT NONE
!*--EV2PPF5873
!*** Start of declarations inserted by SPAG
      REAL Gamma , P , Ppf
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT EV2PPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE EXTREME VALUE TYPE 2
!              DISTRIBUTION WITH SINGLE PRECISION
!              TAIL LENGTH PARAMETER = GAMMA.
!              THE EXTREME VALUE TYPE 2 DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL NON-NEGATIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = GAMMA * (X**(-GAMMA-1)) * EXP(-(X**(-GAMMA))).
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 (EXCLUSIVELY)
!                                AND 1.0 (EXCLUSIVELY))
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!                     --GAMMA  = THE SINGLE PRECISION VALUE
!                                OF THE TAIL LENGTH PARAMETER.
!                                GAMMA SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT FUNCTION .
!             VALUE PPF FOR THE EXTREME VALUE TYPE 2 DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--GAMMA SHOULD BE POSITIVE.
!                 --P SHOULD BE BETWEEN 0.0 (EXCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 272-295.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE EV2PPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99003) P
         Ppf = 0.0
         RETURN
      ELSEIF ( Gamma<=0.0 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE EV2PPF SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99003) Gamma
         Ppf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         Ppf = (-ALOG(P))**(-1.0/Gamma)
      ENDIF
99003 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
      END SUBROUTINE EV2PPF
!*==ev2ran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE EV2RAN(N,Gamma,Iseed,X)
      IMPLICIT NONE
!*--EV2RAN5956
!*** Start of declarations inserted by SPAG
      REAL Gamma , X
      INTEGER i , ipr , Iseed , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT EV2RAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE EXTREME VALUE TYPE 2 DISTRIBUTION
!              WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!              THE PROTOTYPE EXTREME VALUE TYPE 2 DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL NON-NEGATIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = GAMMA * (X**(-GAMMA-1)) * EXP(-(X**(-GAMMA))).
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!                     --GAMMA  = THE SINGLE PRECISION VALUE OF THE
!                                TAIL LENGTH PARAMETER.
!                                GAMMA SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE EXTREME VALUE TYPE 2 DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!                 --GAMMA SHOULD BE POSITIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     REFERENCES--TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 14-15.
!               --HAMMERSLEY AND HANDSCOMB, MONTE CARLO METHODS,
!                 1964, PAGE 36.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 272-295.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82/7
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
      ipr = 6
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE EV2RAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( Gamma<=0.0 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE EV2RAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99004) Gamma
99004    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!     GENERATE N UNIFORM (0,1) RANDOM NUMBERS;
!
         CALL UNIRAN(N,Iseed,X)
!
!     GENERATE N EXTREME VALUE TYPE 2 DISTRIBUTION RANDOM NUMBERS
!     USING THE PERCENT POINT FUNCTION TRANSFORMATION METHOD.
!
         DO i = 1 , N
            X(i) = (-ALOG(X(i)))**(-1.0/Gamma)
         ENDDO
      ENDIF
!
      END SUBROUTINE EV2RAN
!*==expcdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE EXPCDF(X,Cdf)
      IMPLICIT NONE
!*--EXPCDF6072
!*** Start of declarations inserted by SPAG
      REAL Cdf , X
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT EXPCDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR THE EXPONENTIAL DISTRIBUTION
!              WITH MEAN = 1 AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL NON-NEGATIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = EXP(-X).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--X SHOULD BE NON-NEGATIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 207-232.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( X<0.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE EXPC&
     &DF SUBROUTINE IS NEGATIVE *****')
         WRITE (ipr,99002) X
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         Cdf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         Cdf = 1.0 - EXP(-X)
      ENDIF
!
      END SUBROUTINE EXPCDF
!*==exppdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE EXPPDF(X,Pdf)
      IMPLICIT NONE
!*--EXPPDF6137
!*** Start of declarations inserted by SPAG
      INTEGER ipr
      REAL Pdf , X
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT EXPPDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PROBABILITY DENSITY
!              FUNCTION VALUE FOR THE EXPONENTIAL DISTRIBUTION
!              WITH MEAN = 1 AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL NON-NEGATIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = EXP(-X).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE PROBABILITY DENSITY
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--PDF    = THE SINGLE PRECISION PROBABILITY
!                                DENSITY FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PROBABILITY DENSITY
!             FUNCTION VALUE PDF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--X SHOULD BE NON-NEGATIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 207-232.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( X<0.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE EXPP&
     &DF SUBROUTINE IS NEGATIVE *****')
         WRITE (ipr,99002) X
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         Pdf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         Pdf = EXP(-X)
      ENDIF
!
      END SUBROUTINE EXPPDF
!*==expplt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE EXPPLT(X,N)
      IMPLICIT NONE
!*--EXPPLT6202
!*** Start of declarations inserted by SPAG
      REAL an , cc , hold , sum1 , sum2 , sum3 , tau , W , wbar , WS ,  &
     &     X , Y , ybar , yint , yslope
      INTEGER i , ipr , iupper , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT EXPPLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES AN EXPONENTIAL
!              PROBABILITY PLOT.
!              THE PROTOTYPE EXPONENTIAL DISTRIBUTION USED HEREIN
!              HAS MEAN = 1 AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL NON-NEGATIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X)=EXP(-X).
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE EXPONENTIAL PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE EXPONENTIAL DISTRIBUTION.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!     OUTPUT--A ONE-PAGE EXPONENTIAL PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 207-232.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
!
      DATA tau/1.63473745/
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE EXPPLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE EXPP&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE EXPPLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     COMPUTE EXPONENTIAL ORDER STATISTIC MEDIANS
!
         DO i = 1 , N
            W(i) = -ALOG(1.0-W(i))
         ENDDO
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         WRITE (ipr,99005) tau , N
!
99005    FORMAT (' ','EXPONENTIAL PROBABILITY PLOT (TAU = ',E15.8,')',  &
     &           51X,'THE SAMPLE SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         sum2 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
            sum2 = sum2 + W(i)
         ENDDO
         ybar = sum1/an
         wbar = sum2/an
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + (Y(i)-ybar)*(W(i)-wbar)
            sum3 = sum3 + (W(i)-wbar)*(W(i)-wbar)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99006) cc , yint , yslope
99006    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
!
      END SUBROUTINE EXPPLT
!*==expppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE EXPPPF(P,Ppf)
      IMPLICIT NONE
!*--EXPPPF6363
!*** Start of declarations inserted by SPAG
      INTEGER ipr
      REAL P , Ppf
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT EXPPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE EXPONENTIAL DISTRIBUTION
!              WITH MEAN = 1 AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL NON-NEGATIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = EXP(-X).
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT
!             FUNCTION VALUE PPF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0 (INCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 207-232.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE EXPPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         Ppf = -ALOG(1.0-P)
      ENDIF
!
      END SUBROUTINE EXPPPF
!*==expran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE EXPRAN(N,Iseed,X)
      IMPLICIT NONE
!*--EXPRAN6438
!*** Start of declarations inserted by SPAG
      INTEGER i , ipr , Iseed , N
      REAL X
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT EXPRAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE EXPONENTIAL DISTRIBUTION
!              WITH MEAN = 1 AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL NON-NEGATIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = EXP(-X).
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE EXPONENTIAL DISTRIBUTION
!             WITH MEAN = 1 AND STANDARD DEVIATION = 1.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     REFERENCES--TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 14, 35-36.
!               --HAMMERSLEY AND HANDSCOMB, MONTE CARLO METHODS,
!                 1964, PAGE 36.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 207-232.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGE 58.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82/7
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --JULY      1976.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
      ipr = 6
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE EXPRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
!
!     GENERATE N UNIFORM (0,1) RANDOM NUMBERS;
!
         CALL UNIRAN(N,Iseed,X)
!
!     GENERATE N EXPONENTIAL RANDOM NUMBERS
!     USING THE PERCENT POINT FUNCTION TRANSFORMATION METHOD.
!
         DO i = 1 , N
            X(i) = -ALOG(X(i))
         ENDDO
      ENDIF
!
      END SUBROUTINE EXPRAN
!*==expsf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE EXPSF(P,Sf)
      IMPLICIT NONE
!*--EXPSF6549
!*** Start of declarations inserted by SPAG
      INTEGER ipr
      REAL P , Sf
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT EXPSF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE SPARSITY
!              FUNCTION VALUE FOR THE EXPONENTIAL DISTRIBUTION
!              WITH MEAN = 1 AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL NON-NEGATIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = EXP(-X).
!              NOTE THAT THE SPARSITY FUNCTION OF A DISTRIBUTION
!              IS THE DERIVATIVE OF THE PERCENT POINT FUNCTION,
!              AND ALSO IS THE RECIPROCAL OF THE PROBABILITY
!              DENSITY FUNCTION (BUT IN UNITS OF P RATHER THAN X).
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                AT WHICH THE SPARSITY
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--SF     = THE SINGLE PRECISION
!                                SPARSITY FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION SPARSITY
!             FUNCTION VALUE SF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0 (INCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 207-232.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE EXPSF  SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         Sf = 1.0/(1.0-P)
      ENDIF
!
      END SUBROUTINE EXPSF
!*==extrem.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE EXTREM(X,N)
      IMPLICIT NONE
!*--EXTREM6625
!*** Start of declarations inserted by SPAG
      REAL a , aindex , am , an , arg , cc , corr , corrmx , gamtab ,   &
     &     h , hold , p , r , scrat , sum1 , sum2 , sum3 , sy , t , w
      REAL wbar , WS , X , xmax , xmin , Y , ybar , yi , yint , ys ,    &
     &     yslope , Z
      INTEGER i , idis , idismx , ipr , iupper , j , jskip , k , N ,    &
     &        numam , numdis , numdm1
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT EXTREM
!
!     PURPOSE--THIS SUBROUTINE PERFORMS AN EXTREME VALUE ANALYSIS
!              ON THE DATA IN THE INPUT VECTOR X.
!              THIS ANALYSIS CONSISTS OF DETERMINING THAT PARTICULAR
!              EXTREME VALUE TYPE 1 OR EXTREME VALUE TYPE 2 DISTRIBUTION
!              WHICH BEST FITS THE DATA SET.
!              THE GOODNESS OF FIT CRITERION IS THE MAXIMUM PROBABILITY
!              PLOT CORRELATION COEFFICIENT CRITERION.
!              AFTER THE BEST-FIT DISTRIBUTION IS DETERMINED,
!              ESTIMATES ARE COMPUTED AND PRINTED OUT FOR THE
!              LOCATION AND SCALE PARAMETERS.
!              TWO PROBABILITY PLOTS ARE ALSO PRINTED OUT--
!              THE BEST-FIT TYPE 2 PROBABILITY PLOT
!              (IF THE BEST FIT WAS IN FACT A TYPE 2),
!              AND THE TYPE 1 PROBABILITY PLOT.
!              PREDICTED EXTREMES FOR VARIOUS RETURN PERIODS ARE
!              ALSO COMPUTED AND PRINTED OUT.
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS.
!                      N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--6 PAGES OF AUTOMATIC PRINTOUT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, EV1PLT,
!                                         EV2PLT, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN (1972), 'TECHNIQUES FOR TAIL LENGTH
!                 ANALYSIS', PROCEEDINGS OF THE EIGHTEENTH
!                 CONFERENCE ON THE DESIGN OF EXPERIMENTS IN
!                 ARMY RESEARCH AND TESTING, PAGES 425-450.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 UNPUBLISHED MANUSCRIPT.
!               --JOHNSON AND KOTZ (1970), CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS-1, 1970, PAGES 272-295.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --DECEMBER  1974.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --MAY       1976.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 blank , alpham , alphaa , alphax
      CHARACTER*4 alphai , alphan , alphaf , alphat , alphay
      CHARACTER*4 alphag , equal
!
      CHARACTER*4 iflag1
      CHARACTER*4 iflag2
      CHARACTER*4 iflag3
!
      DIMENSION w(3000)
      DIMENSION X(1)
      DIMENSION Y(7500) , Z(7500)
      DIMENSION gamtab(50) , corr(50)
      DIMENSION yi(50) , ys(50) , t(50)
      DIMENSION iflag1(50) , iflag2(50) , iflag3(50)
!CCCC DIMENSION C(10)
      DIMENSION am(50)
      DIMENSION scrat(50)
!
      DIMENSION aindex(50)
!CCCC DIMENSION P0(10)
      DIMENSION h(60,2)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (Z(1),WS(7501))
      DATA blank , alpham , alphaa , alphax/' ' , 'M' , 'A' , 'X'/
      DATA alphai , alphan , alphaf , alphat , alphay/'I' , 'N' , 'F' , &
     &     'T' , 'Y'/
      DATA alphag , equal/'G' , '='/
      DATA gamtab(1) , gamtab(2) , gamtab(3) , gamtab(4) , gamtab(5) ,  &
     &     gamtab(6) , gamtab(7) , gamtab(8) , gamtab(9) , gamtab(10) , &
     &     gamtab(11) , gamtab(12) , gamtab(13) , gamtab(14) ,          &
     &     gamtab(15) , gamtab(16) , gamtab(17) , gamtab(18) ,          &
     &     gamtab(19) , gamtab(20) , gamtab(21) , gamtab(22) ,          &
     &     gamtab(23) , gamtab(24) , gamtab(25)/1. , 2. , 3. , 4. , 5. ,&
     &     6. , 7. , 8. , 9. , 10. , 11. , 12. , 13. , 14. , 15. , 16. ,&
     &     17. , 18. , 19. , 20. , 21. , 22. , 23. , 24. , 25./
      DATA gamtab(26) , gamtab(27) , gamtab(28) , gamtab(29) ,          &
     &     gamtab(30) , gamtab(31) , gamtab(32) , gamtab(33) ,          &
     &     gamtab(34) , gamtab(35) , gamtab(36) , gamtab(37) ,          &
     &     gamtab(38) , gamtab(39) , gamtab(40) , gamtab(41) ,          &
     &     gamtab(42)/30. , 35. , 40. , 45. , 50. , 60. , 70. , 80. ,   &
     &     90. , 100. , 150. , 200. , 250. , 350. , 500. , 750. , 1000./
!CCCC DATA C(1),C(2),C(3),C(4),C(5),C(6),C(7),C(8),C(9),C(10)
!CCCC1/60.,75.,100.,150.,250.,500.,1000.,10000.,100000.,1000000./
!CCCC DATA P0(1),P0(2),P0(3),P0(4),P0(5),P0(6),P0(7),P0(8),P0(9),P0(10)
!CCCC1/.0,.5,.75,.9,.95,.975,.99,.999,.9999,.99999/
      DATA t(1) , t(2) , t(3) , t(4) , t(5) , t(6) , t(7) , t(8) ,      &
     &     t(9) , t(10) , t(11) , t(12) , t(13) , t(14) , t(15) ,       &
     &     t(16) , t(17) , t(18) , t(19) , t(20) , t(21) , t(22) ,      &
     &     t(23) , t(24) , t(25)/10.18011 , 3.39672 , 2.47043 ,         &
     &     2.14609 , 1.98712 , 1.89429 , 1.83394 , 1.79175 , 1.76069 ,  &
     &     1.73691 , 1.71814 , 1.70297 , 1.69045 , 1.67996 , 1.67103 ,  &
     &     1.66335 , 1.65667 , 1.65082 , 1.64564 , 1.64102 , 1.63689 ,  &
     &     1.63316 , 1.62979 , 1.62672 , 1.62391/
      DATA t(26) , t(27) , t(28) , t(29) , t(30) , t(31) , t(32) ,      &
     &     t(33) , t(34) , t(35) , t(36) , t(37) , t(38) , t(39) ,      &
     &     t(40) , t(41) , t(42) , t(43)/1.61287 , 1.60516 , 1.59947 ,  &
     &     1.59510 , 1.59164 , 1.58651 , 1.58289 , 1.58019 , 1.57811 ,  &
     &     1.57645 , 1.57152 , 1.56908 , 1.56763 , 1.56666 , 1.56546 ,  &
     &     1.56377 , 1.56330 , 1.56187/
      DATA aindex(1) , aindex(2) , aindex(3) , aindex(4) , aindex(5) ,  &
     &     aindex(6) , aindex(7) , aindex(8) , aindex(9) , aindex(10) , &
     &     aindex(11) , aindex(12) , aindex(13) , aindex(14) ,          &
     &     aindex(15) , aindex(16) , aindex(17) , aindex(18) ,          &
     &     aindex(19) , aindex(20) , aindex(21) , aindex(22) ,          &
     &     aindex(23) , aindex(24) , aindex(25)/1. , 2. , 3. , 4. , 5. ,&
     &     6. , 7. , 8. , 9. , 10. , 11. , 12. , 13. , 14. , 15. , 16. ,&
     &     17. , 18. , 19. , 20. , 21. , 22. , 23. , 24. , 25./
      DATA aindex(26) , aindex(27) , aindex(28) , aindex(29) ,          &
     &     aindex(30) , aindex(31) , aindex(32) , aindex(33) ,          &
     &     aindex(34) , aindex(35) , aindex(36) , aindex(37) ,          &
     &     aindex(38) , aindex(39) , aindex(40) , aindex(41) ,          &
     &     aindex(42) , aindex(43) , aindex(44) , aindex(45) ,          &
     &     aindex(46) , aindex(47) , aindex(48) , aindex(49) ,          &
     &     aindex(50)/26. , 27. , 28. , 29. , 30. , 31. , 32. , 33. ,   &
     &     34. , 35. , 36. , 37. , 38. , 39. , 40. , 41. , 42. , 43. ,  &
     &     44. , 45. , 46. , 47. , 48. , 49. , 50./
!
      ipr = 6
      iupper = 7500
      numdis = 43
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE EXTREM SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE EXTR&
     &EM SUBROUTINE HAS THE VALUE 1 *****')
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE EXTREM SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     COMPUTE THE SAMPLE MINIMUM AND SAMPLE MAXIMUM
!
         xmin = X(1)
         xmax = X(1)
         DO i = 2 , N
            IF ( X(i)<xmin ) xmin = X(i)
            IF ( X(i)>xmax ) xmax = X(i)
         ENDDO
!
!     COMPUTE THE PROB PLOT CORRELATION COEFFICIENTS FOR THE VARIOUS VALUES
!     OF GAMMA
!
         CALL SORT(X,N,Y)
         CALL UNIMED(N,Z)
!
         DO idis = 1 , numdis
            IF ( idis==numdis ) THEN
               DO i = 1 , N
                  w(i) = -ALOG(ALOG(1.0/Z(i)))
               ENDDO
            ELSE
               a = gamtab(idis)
               DO i = 1 , N
                  w(i) = (-ALOG(Z(i)))**(-1.0/a)
               ENDDO
            ENDIF
!
            sum1 = 0.0
            sum2 = 0.0
            DO i = 1 , N
               sum1 = sum1 + Y(i)
               sum2 = sum2 + w(i)
            ENDDO
            ybar = sum1/an
            wbar = sum2/an
            sum1 = 0.0
            sum2 = 0.0
            sum3 = 0.0
            DO i = 1 , N
               sum2 = sum2 + (Y(i)-ybar)*(w(i)-wbar)
               sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
               sum3 = sum3 + (w(i)-wbar)*(w(i)-wbar)
            ENDDO
            sy = SQRT(sum1/(an-1.0))
            cc = sum2/SQRT(sum3*sum1)
            yslope = sum2/sum3
            yint = ybar - yslope*wbar
            corr(idis) = cc
            yi(idis) = yint
            ys(idis) = yslope
         ENDDO
!
!     DETERMINE THAT DISTRIBUTION WITH THE MAX PROB PLOT CORR COEFFICIENT
!
         idismx = 1
         corrmx = corr(1)
         DO idis = 1 , numdis
            IF ( corr(idis)>corrmx ) idismx = idis
            IF ( corr(idis)>corrmx ) corrmx = corr(idis)
         ENDDO
         DO idis = 1 , numdis
            iflag1(idis) = blank
            iflag2(idis) = blank
            iflag3(idis) = blank
            IF ( idis==idismx ) THEN
               iflag1(idis) = alpham
               iflag2(idis) = alphaa
               iflag3(idis) = alphax
            ENDIF
         ENDDO
!
!     WRITE OUT THE TABLE OF PROB PLOT CORR COEFFICIENTS FOR VARIOUS GAMMA
!
         WRITE (ipr,99028)
         WRITE (ipr,99005)
99005    FORMAT (' ',40X,'EXTREME VALUE ANALYSIS')
         WRITE (ipr,99029)
         WRITE (ipr,99006) N
99006    FORMAT (' ',37X,'THE SAMPLE SIZE N = ',I7)
         WRITE (ipr,99007) ybar
99007    FORMAT (' ',34X,'THE SAMPLE MEAN = ',F14.7)
         WRITE (ipr,99008) sy
99008    FORMAT (' ',28X,'THE SAMPLE STANDARD DEVIATION = ',F14.7)
         WRITE (ipr,99009) xmin
99009    FORMAT (' ',32X,'THE SAMPLE MINIMUM = ',F14.7)
         WRITE (ipr,99010) xmax
99010    FORMAT (' ',32X,'THE SAMPLE MAXIMUM = ',F14.7)
         WRITE (ipr,99029)
         WRITE (ipr,99011)
99011    FORMAT (' ',                                                   &
     &'     EXTREME VALUE      PROBABILITY PLOT     LOCATION         SCA&
     &LE       TAIL LENGTH')
         WRITE (ipr,99012)
99012    FORMAT (' ',                                                   &
     &'  TYPE 2 TAIL LENGTH      CORRELATION        ESTIMATE        ESTI&
     &MATE       MEASURE')
         WRITE (ipr,99013)
99013    FORMAT (' ','   PARAMETER (GAMMA)      COEFFICIENT')
         WRITE (ipr,99029)
!
         numdm1 = numdis - 1
         IF ( numdm1>=1 ) THEN
            DO i = 1 , numdm1
               WRITE (ipr,99014) gamtab(i) , corr(i) , iflag1(i) ,      &
     &                           iflag2(i) , iflag3(i) , yi(i) , ys(i) ,&
     &                           t(i)
99014          FORMAT (' ',3X,F10.2,13X,F8.5,1X,3A1,2X,F14.7,2X,F14.7,  &
     &                 3X,F10.5)
            ENDDO
         ENDIF
         i = numdis
         WRITE (ipr,99015) alphai , alphan , alphaf , alphai , alphan , &
     &                     alphai , alphat , alphay , corr(i) ,         &
     &                     iflag1(i) , iflag2(i) , iflag3(i) , yi(i) ,  &
     &                     ys(i) , t(i)
99015    FORMAT (' ',5X,8A1,13X,F8.5,1X,3A1,2X,F14.7,2X,F14.7,3X,F10.5)
!
!     PLOT THE PROB PLOT CORR COEFFICIENT VERSUS GAMMA VALUE INDEX
!
         CALL PLOT(corr,aindex,numdis)
         WRITE (ipr,99016) alphag , alphaa , alpham , alpham , alphaa , &
     &                     equal , gamtab(1) , gamtab(12) , gamtab(23) ,&
     &                     gamtab(34) , alphai , alphan , alphaf ,      &
     &                     alphai , alphan , alphai , alphat , alphay
99016    FORMAT (' ',12X,5A1,1X,A1,F14.7,11X,F14.7,11X,F14.7,11X,F14.7, &
     &           15X,8A1)
         WRITE (ipr,99029)
         WRITE (ipr,99017)
99017    FORMAT (' ',                                                   &
     &'THE ABOVE IS A PLOT OF THE 46 PROBABILITY PLOT CORRELATION COEFFI&
     &CIENTS (FROM THE PREVIOUS PAGE)')
         WRITE (ipr,99018)
99018    FORMAT (' ',16X,'VERSUS THE 46 EXTREME VALUE DISTRIBUTIONS')
!
!     IF THE OPTIMAL GAMMA IS FINITE, PLOT OUT THE EXTREME VALUE
!     TYPE 2 PROBABILITY PLOT FOR THE OPTIMAL VALUE
!     OF GAMMA.
!
         IF ( idismx<numdis ) CALL EV2PLT(X,N,gamtab(idismx))
!
!     PLOT OUT AN EXTREME VALUE TYPE 1 PROBABILITY PLOT
!
         CALL EV1PLT(X,N)
!
!     FORM THE VARIOUS RETURN PERIOD VALUES
!
         k = 0
         DO i = 1 , 4
            DO j = 1 , 9
               k = k + 1
               am(k) = j*(10**(i-1))
            ENDDO
         ENDDO
         k = k + 1
         am(k) = 10000.
         k = k + 1
         am(k) = 50000.
         k = k + 1
         am(k) = 100000.
         k = k + 1
         am(k) = 500000.
         k = k + 1
         am(k) = 1000000.
         k = k + 1
         am(k) = N
         numam = k
         CALL SORT(am,numam,scrat)
         DO i = 1 , numam
            am(i) = scrat(i)
         ENDDO
!
!     IF THE OPTIMAL GAMMA IS FINITE, COMPUTE THE
!     PREDICTED EXTREME (= F(1-(1/M)) FOR VARIOUS RETURN PERIODS M
!     FOR THE OPTIMAL EXTREME VALUE TYPE 2 DISTRIBUTION.
!
         IF ( idismx/=numdis ) THEN
            a = gamtab(idismx)
            yint = yi(idismx)
            yslope = ys(idismx)
            DO i = 2 , numam
               r = 1.0/am(i)
               p = 1.0 - r
               arg = -ALOG(p)
               IF ( arg>0.0 ) h(i,1) = yint + yslope*(arg**(-1.0/a))
            ENDDO
         ENDIF
!
!     COMPUTE THE PREDICTED EXTREME (= F(1-(1/M)) FOR VARIOUS RETURN
!     PERIODS M FOR THE EXTREME VALUE TYPE 1 DISTRIBUTION.
!
         yint = yi(numdis)
         yslope = ys(numdis)
         DO i = 2 , numam
            r = 1.0/am(i)
            p = 1.0 - r
            arg = -ALOG(p)
            IF ( arg>0.0 ) h(i,2) = yint + yslope*(-ALOG(arg))
         ENDDO
!
!     WRITE OUT THE PAGE WITH THE RETURN PERIODS AND THE PREDICTED EXTREMES
!     FOR THE 2 DISTRIBUTIONS--OPTIMAL EXTREME VALUE TYPE 2, AND EXTREME
!     VALUE TYPE 1.
!
         WRITE (ipr,99028)
         IF ( idismx==numdis ) THEN
!
            WRITE (ipr,99019)
99019       FORMAT (' ','   RETURN PERIOD     PREDICTED EXTREME WIND')
            WRITE (ipr,99020)
99020       FORMAT (' ','    (IN YEARS)              BASED ON')
            WRITE (ipr,99021)
99021       FORMAT (' ','                      EXTREME VALUE TYPE 1')
            WRITE (ipr,99022)
99022       FORMAT (' ','                          DISTRIBUTION')
            WRITE (ipr,99029)
            DO i = 2 , numam
               WRITE (ipr,99030) am(i) , h(i,2)
               j = i - 1
               jskip = j - 5*(j/5)
               IF ( jskip==0 ) WRITE (ipr,99029)
            ENDDO
            GOTO 99999
         ENDIF
      ENDIF
      WRITE (ipr,99023)
99023 FORMAT (' ','   RETURN PERIOD     PREDICTED EXTREME WIND',        &
     &        '     PREDICTED EXTREME WIND')
      WRITE (ipr,99024)
99024 FORMAT (' ','    (IN YEARS)          BASED ON OPTIMAL   ',        &
     &        '            BASED ON')
      WRITE (ipr,99025)
99025 FORMAT (' ','                      EXTREME VALUE TYPE 2',         &
     &        '       EXTREME VALUE TYPE 1')
      WRITE (ipr,99026)
99026 FORMAT (' ','                          DISTRIBUTION     ',        &
     &        '          DISTRIBUTION')
      WRITE (ipr,99027) gamtab(idismx)
99027 FORMAT (' ','                     (GAMMA = ',F12.5,')')
      WRITE (ipr,99029)
      DO i = 2 , numam
         WRITE (ipr,99030) am(i) , h(i,1) , h(i,2)
         j = i - 1
         jskip = j - 5*(j/5)
         IF ( jskip==0 ) WRITE (ipr,99029)
      ENDDO
      RETURN
!
99028 FORMAT ('1')
99029 FORMAT (' ')
99030 FORMAT (' ',2X,F9.1,13X,F10.2,17X,F10.2)
!
99999 END SUBROUTINE EXTREM
!*==fcdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE FCDF(X,Nu1,Nu2,Cdf)
      IMPLICIT NONE
!*--FCDF7056
!*** Start of declarations inserted by SPAG
      REAL amean , ccdf , Cdf , gcdf , sd , t1 , t2 , t3 , u , X ,      &
     &     zratio
      INTEGER i , ibran , ievodd , iflag1 , iflag2 , imax , imin , ipr ,&
     &        m , n , Nu1 , Nu2 , nucut1 , nucut2
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT FCDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR THE F DISTRIBUTION
!              WITH INTEGER DEGREES OF FREEDOM
!              PARAMETERS = NU1 AND NU2.
!              THIS DISTRIBUTION IS DEFINED FOR ALL NON-NEGATIVE X.
!              THE PROBABILITY DENSITY FUNCTION IS GIVEN
!              IN THE REFERENCES BELOW.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!                                X SHOULD BE NON-NEGATIVE.
!                     --NU1    = THE INTEGER DEGREES OF FREEDOM
!                                FOR THE NUMERATOR OF THE F RATIO.
!                                NU1 SHOULD BE POSITIVE.
!                     --NU2    = THE INTEGER DEGREES OF FREEDOM
!                                FOR THE DENOMINATOR OF THE F RATIO.
!                                NU2 SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF FOR THE F DISTRIBUTION
!             WITH DEGREES OF FREEDOM
!             PARAMETERS = NU1 AND NU2.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--X SHOULD BE NON-NEGATIVE.
!                 --NU1 SHOULD BE A POSITIVE INTEGER VARIABLE.
!                 --NU2 SHOULD BE A POSITIVE INTEGER VARIABLE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NORCDF,CHSCDF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--DSQRT, DATAN.
!     MODE OF INTERNAL OPERATIONS--DOUBLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGES 946-947,
!                 FORMULAE 26.6.4, 26.6.5, 26.6.8, AND 26.6.15.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGE 83, FORMULA 20,
!                 AND PAGE 84, THIRD FORMULA.
!               --PAULSON, AN APPROXIMATE NORMAILIZATION
!                 OF THE ANALYSIS OF VARIANCE DISTRIBUTION,
!                 ANNALS OF MATHEMATICAL STATISTICS, 1942,
!                 NUMBER 13, PAGES 233-135.
!               --SCHEFFE AND TUKEY, A FORMULA FOR SAMPLE SIZES
!                 FOR POPULATION TOLERANCE LIMITS, 1944,
!                 NUMBER 15, PAGE 217.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--AUGUST    1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --OCTOBER   1976.
!
!---------------------------------------------------------------------
!
      DOUBLE PRECISION dx , pi , anu1 , anu2 , z , sum , term , ai ,    &
     &                 coef1 , coef2 , arg
      DOUBLE PRECISION coef
      DOUBLE PRECISION theta , sinth , costh , a , b
      DOUBLE PRECISION DSQRT , DATAN
      DOUBLE PRECISION dfact1 , dfact2 , dnum , dden
      DOUBLE PRECISION dpow1 , dpow2
      DOUBLE PRECISION dnu1 , dnu2
      DOUBLE PRECISION term1 , term2 , term3
      DATA pi/3.14159265358979D0/
      DATA dpow1 , dpow2/0.33333333333333D0 , 0.66666666666667D0/
      DATA nucut1 , nucut2/100 , 1000/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( Nu1<=0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE FCDF   SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99006) Nu1
         Cdf = 0.0
         RETURN
      ELSE
         IF ( Nu2<=0 ) THEN
            WRITE (ipr,99002)
99002       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE FCDF   SUBROU&
     &TINE IS NON-POSITIVE *****')
            WRITE (ipr,99006) Nu2
            Cdf = 0.0
            RETURN
         ELSE
            IF ( X<0.0 ) THEN
               WRITE (ipr,99003)
99003          FORMAT (' ',                                             &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE FCDF&
     &   SUBROUTINE IS NEGATIVE *****')
               WRITE (ipr,99004) X
99004          FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8, &
     &                 ' *****')
               Cdf = 0.0
               RETURN
            ELSE
!
!-----START POINT-----------------------------------------------------
!
               dx = X
               m = Nu1
               n = Nu2
               anu1 = Nu1
               anu2 = Nu2
               dnu1 = Nu1
               dnu2 = Nu2
!
!     IF X IS NON-POSITIVE, SET CDF = 0.0 AND RETURN.
!     IF NU2 IS 5 THROUGH 9 AND X IS MORE THAN 3000
!     STANDARD DEVIATIONS BELOW THE MEAN,
!     SET CDF = 0.0 AND RETURN.
!     IF NU2 IS 10 OR LARGER AND X IS MORE THAN 150
!     STANDARD DEVIATIONS BELOW THE MEAN,
!     SET CDF = 0.0 AND RETURN.
!     IF NU2 IS 5 THROUGH 9 AND X IS MORE THAN 3000
!     STANDARD DEVIATIONS ABOVE THE MEAN,
!     SET CDF = 1.0 AND RETURN.
!     IF NU2 IS 10 OR LARGER AND X IS MORE THAN 150
!     STANDARD DEVIATIONS ABOVE THE MEAN,
!     SET CDF = 1.0 AND RETURN.
!
               IF ( X>0.0 ) THEN
                  IF ( Nu2<=4 ) GOTO 50
                  t1 = 2.0/anu1
                  t2 = anu2/(anu2-2.0)
                  t3 = (anu1+anu2-2.0)/(anu2-4.0)
                  amean = t2
                  sd = SQRT(t1*t2*t2*t3)
                  zratio = (X-amean)/sd
                  IF ( Nu2>=10 .OR. zratio>=-3000.0 ) THEN
                     IF ( Nu2<10 .OR. zratio>=-150.0 ) THEN
                        IF ( Nu2<10 .AND. zratio>3000.0 ) GOTO 20
                        IF ( Nu2<10 .OR. zratio<=150.0 ) GOTO 50
                        GOTO 20
                     ENDIF
                  ENDIF
               ENDIF
               Cdf = 0.0
               RETURN
            ENDIF
 20         Cdf = 1.0
            RETURN
         ENDIF
!
!     DISTINGUISH BETWEEN 6 SEPARATE REGIONS
!     OF THE (NU1,NU2) SPACE.
!     BRANCH TO THE PROPER COMPUTATIONAL METHOD
!     DEPENDING ON THE REGION.
!     NUCUT1 HAS THE VALUE 100.
!     NUCUT2 HAS THE VALUE 1000.
!
 50      IF ( Nu1<nucut2 .AND. Nu2<nucut2 ) THEN
!
!     TREAT THE CASE WHEN NU1 AND NU2
!     ARE BOTH SMALL OR MODERATE
!     (THAT IS, BOTH ARE SMALLER THAN 1000).
!     METHOD UTILIZED--EXACT FINITE SUM
!     (SEE AMS 55, PAGE 946, FORMULAE 26.6.4, 26.6.5,
!     AND 26.6.8).
!
            z = anu2/(anu2+anu1*dx)
            iflag1 = Nu1 - 2*(Nu1/2)
            iflag2 = Nu2 - 2*(Nu2/2)
            IF ( iflag1==0 ) THEN
!
!     DO THE NU1 EVEN AND NU2 EVEN OR ODD CASE
!
               sum = 0.0D0
               term = 1.0D0
               imax = (m-2)/2
               IF ( imax>0 ) THEN
                  DO i = 1 , imax
                     ai = i
                     coef1 = 2.0D0*(ai-1.0D0)
                     coef2 = 2.0D0*ai
                     term = term*((anu2+coef1)/coef2)*(1.0D0-z)
                     sum = sum + term
                  ENDDO
               ENDIF
!
               sum = sum + 1.0D0
               sum = (z**(anu2/2.0D0))*sum
               Cdf = 1.0D0 - sum
               RETURN
            ELSEIF ( iflag2==0 ) THEN
!
!     DO THE NU1 ODD AND NU2 EVEN CASE
!
               sum = 0.0D0
               term = 1.0D0
               imax = (n-2)/2
               IF ( imax>0 ) THEN
                  DO i = 1 , imax
                     ai = i
                     coef1 = 2.0D0*(ai-1.0D0)
                     coef2 = 2.0D0*ai
                     term = term*((anu1+coef1)/coef2)*z
                     sum = sum + term
                  ENDDO
               ENDIF
!
               sum = sum + 1.0D0
               Cdf = ((1.0D0-z)**(anu1/2.0D0))*sum
               RETURN
            ELSE
!
!     DO THE NU1 ODD AND NU2 ODD CASE
!
               sum = 0.0D0
               term = 1.0D0
               arg = DSQRT((anu1/anu2)*dx)
               theta = DATAN(arg)
               sinth = arg/DSQRT(1.0D0+arg*arg)
               costh = 1.0D0/DSQRT(1.0D0+arg*arg)
               IF ( n/=1 ) THEN
                  IF ( n/=3 ) THEN
                     imax = n - 2
                     DO i = 3 , imax , 2
                        ai = i
                        coef1 = ai - 1.0D0
                        coef2 = ai
                        term = term*(coef1/coef2)*(costh*costh)
                        sum = sum + term
                     ENDDO
                  ENDIF
!
                  sum = sum + 1.0D0
                  sum = sum*sinth*costh
               ENDIF
!
               a = (2.0D0/pi)*(theta+sum)
               sum = 0.0D0
               term = 1.0D0
               IF ( m==1 ) b = 0.0D0
               IF ( m/=1 ) THEN
                  IF ( m/=3 ) THEN
                     imax = m - 3
                     DO i = 1 , imax , 2
                        ai = i
                        coef1 = ai
                        coef2 = ai + 2.0D0
                        term = term*((anu2+coef1)/coef2)*(sinth*sinth)
                        sum = sum + term
                     ENDDO
                  ENDIF
!
                  sum = sum + 1.0D0
                  sum = sum*sinth*(costh**n)
                  coef = 1.0D0
                  ievodd = n - 2*(n/2)
                  imin = 3
                  IF ( ievodd==0 ) imin = 2
                  IF ( imin<=n ) THEN
                     DO i = imin , n , 2
                        ai = i
                        coef = ((ai-1.0D0)/ai)*coef
                     ENDDO
                  ENDIF
!
                  coef = coef*anu2
                  IF ( ievodd/=0 ) coef = coef*(2.0D0/pi)
!
                  b = coef*sum
               ENDIF
!
               Cdf = a - b
               RETURN
            ENDIF
         ELSEIF ( Nu1<nucut2 .OR. Nu2<nucut2 ) THEN
            IF ( Nu1<nucut1 .AND. Nu2>=nucut2 ) THEN
!
!     TREAT THE CASE WHEN NU1 IS SMALL
!     AND NU2 IS LARGE
!     (THAT IS, WHEN NU1 IS SMALLER THAN 100,
!     AND NU2 IS EQUAL TO OR LARGER THAN 1000).
!     METHOD UTILIZED--SHEFFE-TUKEY APPROXIMATION
!     (SEE JOHNSON AND KOTZ, VOLUME 2, PAGE 84, THIRD FORMULA).
!
               term1 = dnu1
               term2 = (dnu1/dnu2)*(0.5D0*dnu1-1.0D0)
               term3 = -(dnu1/dnu2)*0.5D0
               u = (term1+term2)/((1.0D0/dx)-term3)
               CALL CHSCDF(u,Nu1,ccdf)
               Cdf = ccdf
               RETURN
            ELSEIF ( Nu1<nucut1 .OR. Nu2<nucut2 ) THEN
               IF ( Nu1>=nucut2 .AND. Nu2<nucut1 ) THEN
!
!     TREAT THE CASE WHEN NU2 IS SMALL
!     AND NU1 IS LARGE
!     (THAT IS, WHEN NU2 IS SMALLER THAN 100,
!     AND NU1 IS EQUAL TO OR LARGER THAN 1000).
!     METHOD UTILIZED--SHEFFE-TUKEY APPROXIMATION
!     (SEE JOHNSON AND KOTZ, VOLUME 2, PAGE 84, THIRD FORMULA).
!
                  term1 = dnu2
                  term2 = (dnu2/dnu1)*(0.5D0*dnu2-1.0D0)
                  term3 = -(dnu2/dnu1)*0.5D0
                  u = (term1+term2)/(dx-term3)
                  CALL CHSCDF(u,Nu2,ccdf)
                  Cdf = 1.0 - ccdf
                  GOTO 99999
               ELSEIF ( Nu1<nucut2 .OR. Nu2<nucut1 ) THEN
                  ibran = 5
                  WRITE (ipr,99005) ibran
99005             FORMAT (' ',                                          &
     &                    '*****INTERNAL ERROR IN   FCDF SUBROUTINE--', &
     &                  'IMPOSSIBLE BRANCH CONDITION AT BRANCH POINT = '&
     &                  ,I8)
                  RETURN
               ENDIF
            ENDIF
         ENDIF
      ENDIF
!
!     TREAT THE CASE WHEN NU1 AND NU2
!     ARE BOTH LARGE
!     (THAT IS, BOTH ARE EQUAL TO OR LARGER THAN 1000);
!     OR WHEN NU1 IS MODERATE AND NU2 IS LARGE
!     (THAT IS, WHEN NU1 IS EQUAL TO OR GREATER THAN 100
!     BUT SMALLER THAN 1000,
!     AND NU2 IS EQUAL TO OR LARGER THAN 1000);
!     OR WHEN NU2 IS MODERATE AND NU1 IS LARGE
!     (THAT IS WHEN NU2 IS EQUAL TO OR GREATER THAN 100
!     BUT SMALLER THAN 1000,
!     AND NU1 IS EQUAL TO OR LARGER THAN 1000).
!     METHOD UTILIZED--PAULSON APPROXIMATION
!     (SEE AMS 55, PAGE 947, FORMULA 26.6.15).
!
      dfact1 = 1.0D0/(4.5D0*dnu1)
      dfact2 = 1.0D0/(4.5D0*dnu2)
      dnum = ((1.0D0-dfact2)*(dx**dpow1)) - (1.0D0-dfact1)
      dden = DSQRT((dfact2*(dx**dpow2))+dfact1)
      u = dnum/dden
      CALL NORCDF(u,gcdf)
      Cdf = gcdf
      RETURN
99006 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
!
99999 END SUBROUTINE FCDF
!*==fourie.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE FOURIE(X,N)
      IMPLICIT NONE
!*--FOURIE7415
!*** Start of declarations inserted by SPAG
      REAL A , ai , amp , an , angdeg , angrad , B , conmsq , del ,     &
     &     ffreq , hold , percon , period , phase1 , phase2 , pi , sum ,&
     &     suma , sumb , t
      REAL vbias , WS , X , xbar
      INTEGER i , ievodd , ilower , ipage , ipr , iskip , iupper , j ,  &
     &        maxpag , N , nhalf , nnpage
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT FOURIE
!
!     PURPOSE--THIS SUBROUTINE PERFORMS A FOURIER ANALYSIS
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE ANALYSIS CONSISTS OF THE FOLLOWING--
!              1) COMPUTING (AND PRINTING)
!                 (FOR EACH OF THE HARMONIC FREQUENCIES
!                 1/N, 2/N, 3/N, ..., 1/2)
!                 THE CORRESPONDING FOURIER COEFICIENTS,
!                 THE AMPLITUDE, THE PHASE,
!                 THE CONTRIBUTION TO THE TOTAL VARIANCE,
!                 AND THE RELATIVE CONTRIBUTION TO THE TOTAL
!                 VARIANCE.
!              2) PLOTTING OUT A FOURIER LINE SPECTRUM =
!                 THE PERIODOGRAM = THE PLOT OF RELATIVE
!                 CONTRIBUTION TO TOTAL VARIANCE
!                 (AT EACH FOURIER FREQUENCY) VERSUS
!                 THE FOURIER FREQUENCY.
!
!              IN ORDER THAT THE RESULTS OF THE FOURIER ANALYSIS
!              BE VALID AND PROPERLY INTERPRETED, THE INPUT DATA
!              IN X SHOULD BE EQUI-SPACED IN TIME
!              (OR WHATEVER VARIABLE CORRESPONDS TO TIME).
!
!              THE HORIZONTAL AXIS OF THE SPECTRA PRODUCED
!              BY THIS SUBROUTINE IS FREQUENCY.
!              THIS FREQUENCY IS MEASURED IN UNITS OF
!              CYCLES PER 'DATA POINT' OR, MORE PRECISELY, IN
!              CYCLES PER UNIT TIME WHERE
!              'UNIT TIME' IS DEFINED AS THE
!              ELAPSED TIME BETWEEN ADJACENT OBSERVATIONS.
!              THE RANGE OF THE FREQUENCY AXIS IS 0.0 TO 0.5.
!
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED) OBSERVATIONS.
!                      N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--2 TO 10 PAGES (DEPENDING ON
!             THE INPUT SAMPLE SIZE) OF
!             AUTOMATIC PRINTOUT--
!             1) A LISTING OF THE AMPLITUDE,
!                PHASE, CONTRIBUTION TO THE
!                TOTAL VARIANCE, AND RELATIVE
!                CONTRIBUTION TO THE TOTAL
!                VARIANCE FOR EACH OF THE
!                FOURIER FREQUENCIES
!                (1/N, 2/N, 3/N, ..., 1/2).
!                THIS LISTING MAY TAKE AS LITTLE AS 1
!                PAGE OR AS MANY AS N/100 PAGES
!                (THE EXACT NUMBER DEPENDING ON
!                THE INPUT SAMPLE SIZE N).
!                THIS LISTING IS TERMINATED
!                AFTER AT MOST 8 COMPUTER PAGES.
!                IF MORE PAGES ARE DESIRED,
!                CHANGE THE VALUE OF THE
!                VARIABLE     MAXPAG
!                WITHIN THIS SUBROUTINE
!                FROM 8 TO WHATEVER DESIRED.
!             2) A PLOT OF THE RELATIVE
!                CONTRIBUTION TO THE
!                TOTAL VARIANCE VERSUS FREQUENCY.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 15000.
!                 --THE SAMPLE SIZE N MUST BE GREATER
!                   THAN OR EQUAL TO 3.
!     OTHER DATAPAC   SUBROUTINES NEEDED--PLOTSP AND CHSPPF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, SIN, COS, ATAN.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--FOURIER ANALYSIS DIFFERS FROM SPECTRAL ANALYSIS
!              (AS, FOR EXAMPLE, PRODUCED BY THE DATAPAC
!              TIMESE SUBROUTINE) IN THAT A
!              FOURIER ANALYSIS DOES NO SMOOTHING ON
!              THE SPECTRAL ESTIMATES WHEREAS A SPECRRAL
!              ANALYSIS DOES SMOOTH THE SPECTRAL ESTIMATES.
!              THE NET RESULT IS THAT THE SPECTRAL
!              ESTIMATES OBTAINED FROM A FOURIER
!              ANALYSIS ARE ALMOST ALWAYS MORE
!              VARIABLE THAN THOSE OBTAINED IN A
!              SPECTRAL ANALYSIS.
!              THE PRACTICAL CONCLUSION IS THAT
!              WHEN THE DATA ANALYST HAS A CHOICE
!              OF WHETHER TO PERFORM A FOURIER
!              ANALYSIS OR A SPECTRAL ANALYSIS,
!              THE SPECTRAL ANALYSIS SHOULD
!              ALMOST ALWAYS BE PREFERRED.
!            --THE MAXIMUM NUMBER OF FOURIER FREQUENCIES
!              FOR WHICH THE FOURIER COEFFICIENTS IS
!              COMPUTED (AND LISTED) IS N/2 WHERE N IS
!              THE SAMPLE SIZE (LENGTH OF THE
!              DATA RECORD IN THE VECTOR X).
!              THIS RULE IS OVERRIDDEN
!              (FOR LISTING PURPOSES ONLY)
!              IN LARGE DATA SETS AND IS REPLACED
!              BY THE RULE THAT THE MAXIMUM
!              NUMBER OF LAGS LISTED = 800
!              (WHICH CORRESPONDS TO AN
!              8-PAGE LISTING OF FOURIER COEFFICIENTS.
!              IF MORE PAGES ARE DESIRED,
!              CHANGE THE VALUE OF THE
!              VARIABLE     MAXPAG
!              WITHIN THIS SUBROUTINE
!              FROM 8 TO WHATEVER DESIRED.
!            --IF THE INPUT OBSERVATIONS IN X ARE CONSIDERED
!              TO HAVE BEEN COLLECTED 1 SECOND APART IN TIME,
!              THEN THE FREQUENCY AXIS OF THE RESULTING
!              SPECTRA WOULD BE IN UNITS OF HERTZ
!              (= CYCLES PER SECOND).
!            --THE FREQUENCY OF 0.0 CORRESPONDS TO A CYCLE
!              IN THE DATA OF INFINITE (= 1/(0.0))
!              LENGTH OR PERIOD.
!              THE FREQUENCY OF 0.5 CORRESPONDS TO A CYCLE
!              IN THE DATA OF LENGTH = 1/(0.5) = 2 DATA POINTS.
!            --ANY EQUI-SPACED FOURIER ANALYSIS IS
!              INTRINSICALLY LIMITED TO DETECTING FREQUENCIES
!              NO LARGER THAN 0.5 CYCLES PER DATA POINT;
!              THIS CORRESPONDS TO THE FACT THAT THE
!              SMALLEST DETECTABLE CYCLE IN THE DATA
!              IS 2 DATA POINTS PER CYCLE.
!     REFERENCES--JENKINS AND WATTS, ESPECIALLY PAGE 290.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1972.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 alperc
      DIMENSION X(1)
      DIMENSION A(7500) , B(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (A(1),WS(1))
      EQUIVALENCE (B(1),WS(7501))
      DATA pi/3.14159265358979/
      DATA alperc/'%'/
!
      ipr = 6
      ilower = 3
      iupper = 15000
      maxpag = 8
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<ilower .OR. N>iupper ) THEN
         WRITE (ipr,99001) ilower , iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE FOURIE SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (',I6,',',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99003) hold
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE FOURIE SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
         RETURN
      ENDIF
!
!-----START POINT-----------------------------------------------------
!
 100  an = N
!
!     DETERMINE IF N IS ODD OR EVEN
!
      ievodd = N - 2*(N/2)
      del = (an+1.0)/2.0
      IF ( ievodd==0 ) del = (an+2.0)/2.0
!
!     COMPUTE THE SAMPLE MEAN
!
      sum = 0.0
      DO i = 1 , N
         sum = sum + X(i)
      ENDDO
      xbar = sum/an
!
!     COMPUTE THE BIASED SAMPLE VARIANCE
!
      sum = 0.0
      DO i = 1 , N
         sum = sum + (X(i)-xbar)**2
      ENDDO
      vbias = sum/an
!
!     COMPUTE THE FOURIER COSINE AND SINE COEFFICIENTS--THEY ARE PLACED
!     IN VECTORS A AND B, RESPECTIVELY.
!
      nhalf = N/2
      DO i = 1 , nhalf
         ai = i
         suma = 0.0
         sumb = 0.0
         DO j = 1 , N
            t = j
            suma = suma + X(j)*COS(2.0*pi*(ai/an)*(t-del))
            sumb = sumb + X(j)*SIN(2.0*pi*(ai/an)*(t-del))
         ENDDO
         A(i) = suma/an
         B(i) = sumb/an
      ENDDO
!
!     WRITE OUT THE SAMPLE SIZE, THE SAMPLE MEAN,
!     AND THE (BIASED) SAMPLE VARIANCE.
!
      WRITE (ipr,99013)
      WRITE (ipr,99004)
!
99004 FORMAT (' ',44X,'FOURIER ANALYSIS')
      WRITE (ipr,99014)
      WRITE (ipr,99014)
      WRITE (ipr,99005) N
99005 FORMAT (' ',40X,'THE SAMPLE SIZE N                      = ',I8)
      WRITE (ipr,99006) xbar
99006 FORMAT (' ',40X,'THE SAMPLE MEAN                        = ',F20.8)
      WRITE (ipr,99007) vbias
99007 FORMAT (' ',40X,'THE SAMPLE VARIANCE (WITH DIVISOR N-1) = ',F20.8)
      WRITE (ipr,99014)
!
!     COMPUTE THE HARMONIC CONTRIBUTION
!     AT EACH OF THE FOURIER FREQUENCIES.
!     THE FUNDAMENTAL FOURIER FREQUENCY
!     IS 1/N CYCLES PER DATA POINT
!     (WHERE N = THE INPUT SAMPLE SIZE).
!     THE OTHER FOURIER FREQUENCIES
!     ARE MULTIPLES OR HARMONICS
!     (2/N, 3/N, 4/N, ...1/2) OF THE FUNDAMENTAL.
!     COMPUTE AMPLITUDES, PHASES, AND
!     CONTRIBUTIONS TO THE VARIANCE AT EACH
!     OF THE FOURIER FREQUENCIES.
!     COMPUTE THE PERCENTAGE CONTRIBUTION
!     TO THE TOTAL VARIANCE AT EACH
!     OF THE FOURIER FREQUENCIES.
!     NOTE--TO SAVE STORAGE, ALSO COPY
!     THE PERCENTAGE CONTRIBUTIONS TO THE VARIANCE)
!     (WHICH WILL LATER BE PLOTTED OUT LIKE A SPECTRUM)
!     INTO THE VECTOR A; THIS WILL DESTROY
!     THE PREVIOUS CONTENTS OF THE VECTOR A.
!     WRITE OUT ALL OF THE ABOVE.
!
      nnpage = 50
      i = 0
      DO ipage = 1 , maxpag
         WRITE (ipr,99013)
         WRITE (ipr,99008)
99008    FORMAT (' ','     I   FOURIER   PERIOD      FOURIER  ',        &
     &           '      FOURIER       AMPLITUDE ',                      &
     &           '      PHASE          PHASE         VARIANCE   ',      &
     &           '  RELATIVE')
         WRITE (ipr,99009)
99009    FORMAT (' ','        FREQUENCY            COEFFICIENT    ',    &
     &           'COEFFICIENT',                                         &
     &     '                    RADIANS        DEGREES        COMPONENT'&
     &     ,'    VARIANCE')
         WRITE (ipr,99010)
99010    FORMAT (' ','     (CYCLES/POINT)             A(I)       ',     &
     &           '    B(I)      ',                                      &
     &           '                                                  ',  &
     &           '         COMPONENT (%)')
         DO j = 1 , nnpage
            i = i + 1
            ai = i
            ffreq = ai/an
            period = 1.0/ffreq
            angrad = (ai/an)*2.0*pi
            angdeg = (ai/an)*360.0
            amp = SQRT(A(i)*A(i)+B(i)*B(i))
            phase1 = ATAN(-B(i)/A(i))
            phase2 = phase1*360.0/(2.0*pi)
            conmsq = 2.0*amp*amp
            IF ( i==nhalf .AND. ievodd==0 ) conmsq = conmsq/2.0
            percon = 100.0*(conmsq/vbias)
            WRITE (ipr,99011) i , ffreq , period , A(i) , B(i) , amp ,  &
     &                        phase1 , phase2 , conmsq , percon , alperc
99011       FORMAT (' ',I6,2X,F8.6,1X,F8.2,6(1X,E14.7),2X,F6.2,A1)
            A(i) = percon
            IF ( i>=nhalf ) GOTO 200
            iskip = i - 10*(i/10)
            IF ( iskip==0 ) WRITE (ipr,99014)
         ENDDO
      ENDDO
!
!     PLOT OUT THE PERCENTAGE CONTRIBUTIONS
!     TO THE TOTAL VARIANCE AT
!     EACH OF THE FOURIER FREQUENCIES
!     (1/N, 2/N, 3/N, ..., 1/2).
!     THIS WILL CORRESPOND TO A SPECTRAL
!     PLOT IN SPECTRAL ANALYSIS.
!
 200  CALL PLOTSP(A,nhalf,0)
      WRITE (ipr,99012)
99012 FORMAT (' ',40X,                                                  &
     &        'PERIODOGRAM = FOURIER LINE SPECTRUM OF THE ORIGINAL DATA'&
     &        )
99013 FORMAT ('1')
99014 FORMAT (' ')
!
      END SUBROUTINE FOURIE
!*==fran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE FRAN(N,Nu1,Nu2,Istart,X)
      IMPLICIT NONE
!*--FRAN7735
!*** Start of declarations inserted by SPAG
      REAL anu1 , anu2 , arg1 , arg2 , chs1 , chs2 , pi , sum , X , y , &
     &     z
      INTEGER i , ipr , Istart , j , N , Nu1 , Nu2
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT FRAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE F DISTRIBUTION
!              WITH INTEGER DEGREES OF FREEDOM
!              PARAMETERS = NU1 AND NU2.
!              THIS DISTRIBUTION IS DEFINED FOR ALL NON-NEGATIVE X.
!              THE PROBABILITY DENSITY FUNCTION IS GIVEN
!              IN THE REFERENCES BELOW.
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!                     --NU1    = THE INTEGER DEGREES OF FREEDOM
!                                FOR THE NUMERATOR OF THE F RATIO.
!                     --NU2    = THE INTEGER DEGREES OF FREEDOM
!                                FOR THE DENOMINATOR OF THE F RATIO.
!                     --ISTART = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL START THE
!                                GENERATOR OVER AND HENCE
!                                PRODUCE THE SAME RANDOM SAMPLE
!                                OVER AND OVER AGAIN
!                                UPON SUCCESSIVE CALLS TO
!                                THIS SUBROUTINE WITHIN A RUN; OR
!                                (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0,
!                                LIKE, SAY, 1) WILL ALLOW
!                                THE GENERATOR TO CONTINUE
!                                FROM WHERE IT STOPPED
!                                AND HENCE PRODUCE DIFFERENT
!                                RANDOM SAMPLES UPON
!                                SUCCESSIVE CALLS TO
!                                THIS SUBROUTINE WITHIN A RUN.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE F DISTRIBUTION
!             WITH DEGREES OF FREEDOM
!             PARAMETERS = NU1 AND NU2.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!                 --NU1 SHOULD BE A POSITIVE INTEGER VARIABLE.
!                 --NU2 SHOULD BE A POSITIVE INTEGER VARIABLE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG, SQRT, SIN, COS.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--MOOD AND GRABLE, INTRODUCTION TO THE
!                 THEORY OF STATISTICS, 1963, PAGES 231-232.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 75-93.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGE 64.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION y(2) , z(2)
      DATA pi/3.14159265358979/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE FRAN   SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99004) N
         RETURN
      ELSEIF ( Nu1<=0 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE FRAN   SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99004) Nu1
         RETURN
      ELSEIF ( Nu2<=0 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE FRAN   SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99004) Nu2
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         CALL UNIRAN(1,Istart,y)
!
!     GENERATE N F RANDOM NUMBERS
!     USING THE DEFINITION THAT
!     A F VARIATE WITH NU1 AND NU2 DEGREES OF FREEDOM
!     EQUALS (CHS1/NU1)/(CHS2/NU2)
!     WHERE CHS1 IS A CHI-SQUARED VARIATE
!     WITH NU1 DEGREES OF FREEDOM,
!     AND   CHS2 IS A CHI-SQUARED VARIATE
!     WITH NU2 DEGREES OF FREEDOM.
!     FIRST GENERATE UNIFORM (0,1) RANDOM NUMBERS,
!     THEN GENERATE NORMAL RANDOM NUMBERS,
!     THEN CHI-SQUARED RANDOM NUMBERS WITH NU1 DEGREES
!     OF FREEDOM,
!     THEN CHI-SQUARED RANDOM NUMBERS WITH NU2 DEGREES
!     OF FREEDOM,
!     AND THEN FINALLY THE F RANDOM NUMBER.
!
         anu1 = Nu1
         anu2 = Nu2
         DO i = 1 , N
!
            sum = 0.0
            DO j = 1 , Nu1 , 2
               CALL UNIRAN(2,1,y)
               arg1 = -2.0*ALOG(y(1))
               arg2 = 2.0*pi*y(2)
               z(1) = (SQRT(arg1))*(COS(arg2))
               z(2) = (SQRT(arg1))*(SIN(arg2))
               sum = sum + z(1)*z(1)
               IF ( j/=Nu1 ) sum = sum + z(2)*z(2)
            ENDDO
            chs1 = sum
!
            sum = 0.0
            DO j = 1 , Nu2 , 2
               CALL UNIRAN(2,1,y)
               arg1 = -2.0*ALOG(y(1))
               arg2 = 2.0*pi*y(2)
               z(1) = (SQRT(arg1))*(COS(arg2))
               z(2) = (SQRT(arg1))*(SIN(arg2))
               sum = sum + z(1)*z(1)
               IF ( j/=Nu2 ) sum = sum + z(2)*z(2)
            ENDDO
            chs2 = sum
!
            X(i) = (chs1/anu1)/(chs2/anu2)
!
         ENDDO
      ENDIF
99004 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
!
      END SUBROUTINE FRAN
!*==freq.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE FREQ(X,N)
      IMPLICIT NONE
!*--FREQ7897
!*** Start of declarations inserted by SPAG
      REAL an , cfreq , dvalue , frq , hold , pcfreq , pfreq , s , sum ,&
     &     WS , X , xbar , Y
      INTEGER i , icfreq , iflag , ifreq , ip1 , ipr , iupper , N ,     &
     &        ndv , nm1 , numseq
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT FREQ
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE SAMPLE FREQUENCY
!              AND SAMPLE CUMULATIVE FREQUENCY
!              FOR THE DATA IN THE INPUT VECTOR X.
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS.
!                      N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--SEVERAL (FOR LARGE DATA SETS) PAGES OF AUTOMATIC
!             PRINTOUT (WITH APPROXIMATELY 55 VALUES PER PAGE)
!             CONSISTING OF AN ORDERED LISTING OF EACH DISTINCT
!             VALUE IN THE DATA SET ALONG WITH
!             THE FREQUENCY OF OCCURANCE OF THAT VALUE
!             AND THE CUMULATIVE FREQUENCY.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 15000.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGE 8.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--DECEMBER  1972.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(15000)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
!
      ipr = 6
      iupper = 15000
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE FREQ   SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--         THE SECOND INPUT ARGUMENT TO THE FREQ&
     &   SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE FREQ   SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     COMPUTE THE SAMPLE MEAN AND SAMPLE STANDARD DEVIATION
!
         sum = 0.0
         DO i = 1 , N
            sum = sum + X(i)
         ENDDO
         xbar = sum/an
         sum = 0.0
         DO i = 1 , N
            sum = sum + (X(i)-xbar)**2
         ENDDO
         s = SQRT(sum/(an-1.0))
!
         WRITE (ipr,99005)
99005    FORMAT ('1')
         WRITE (ipr,99006)
!
99006    FORMAT (' ',18X,                                               &
     &           'SAMPLE FREQUENCY AND SAMPLE CUMULATIVE FREQUENCY')
         WRITE (ipr,99014)
         WRITE (ipr,99007) N
99007    FORMAT (' ',27X,'THE SAMPLE SIZE N = ',I8)
         WRITE (ipr,99008) xbar
99008    FORMAT (' ',25X,'THE SAMPLE MEAN = ',E15.8)
         WRITE (ipr,99009) s
99009    FORMAT (' ',20X,'THE SAMPLE STANDARD DEVIATION = ',E15.8)
         WRITE (ipr,99014)
         WRITE (ipr,99014)
         WRITE (ipr,99010)
99010    FORMAT (' ',                                                   &
     &'    INDEX            VALUE       FREQUENCY    PERCENTAGE        C&
     &UMULATIVE    PERCENTAGE')
         WRITE (ipr,99011)
99011    FORMAT (' ',                                                   &
     &'                                              FREQUENCY         F&
     &REQUENCY     CUMULATIVE')
         WRITE (ipr,99012)
99012    FORMAT (' ',                                                   &
     &'                                                                 &
     &             FREQUENCY ')
         WRITE (ipr,99014)
!
         CALL SORT(X,N,Y)
         ndv = 0
         icfreq = 0
         numseq = 1
         nm1 = N - 1
         DO i = 1 , nm1
            ip1 = i + 1
            IF ( Y(i)==Y(ip1) ) numseq = numseq + 1
            IF ( Y(i)/=Y(ip1) ) THEN
               ndv = ndv + 1
               dvalue = Y(i)
               ifreq = numseq
               icfreq = icfreq + ifreq
               frq = ifreq
               cfreq = icfreq
               pfreq = 100.0*frq/an
               pcfreq = 100.0*cfreq/an
               WRITE (ipr,99013) ndv , dvalue , ifreq , pfreq , icfreq ,&
     &                           pcfreq
               iflag = ndv - 10*(ndv/10)
               IF ( iflag==0 ) WRITE (ipr,99014)
               numseq = 1
            ENDIF
         ENDDO
         ndv = ndv + 1
         dvalue = Y(N)
         ifreq = numseq
         icfreq = icfreq + ifreq
         frq = ifreq
         cfreq = icfreq
         pfreq = 100.0*frq/an
         pcfreq = 100.0*cfreq/an
         WRITE (ipr,99013) ndv , dvalue , ifreq , pfreq , icfreq ,      &
     &                     pcfreq
         iflag = ndv - 10*(ndv/10)
         IF ( iflag==0 ) WRITE (ipr,99014)
      ENDIF
99013 FORMAT (' ',I8,4X,E17.10,3X,I8,6X,F8.4,10X,I8,6X,F8.4)
99014 FORMAT (' ')
      END SUBROUTINE FREQ
!*==gamcdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE GAMCDF(X,Gamma,Cdf)
      IMPLICIT NONE
!*--GAMCDF8063
!*** Start of declarations inserted by SPAG
      REAL Cdf , Gamma , X
      INTEGER i , ipr , maxit
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT GAMCDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR THE GAMMA
!              DISTRIBUTION WITH SINGLE PRECISION
!              TAIL LENGTH PARAMETER = GAMMA.
!              THE GAMMA DISTRIBUTION USED
!              HEREIN HAS MEAN = GAMMA
!              AND STANDARD DEVIATION = SQRT(GAMMA).
!              THIS DISTRIBUTION IS DEFINED FOR ALL POSITIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/CONSTANT) * (X**(GAMMA-1)) * EXP(-X)
!              WHERE THE CONSTANT = THE GAMMA FUNCTION EVALUATED
!              AT THE VALUE GAMMA.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE
!                                AT WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!                                X SHOULD BE POSITIVE.
!                     --GAMMA  = THE SINGLE PRECISION VALUE
!                                OF THE TAIL LENGTH PARAMETER.
!                                GAMMA SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF FOR THE GAMMA DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--GAMMA SHOULD BE POSITIVE.
!                 --X SHOULD BE POSITIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--DEXP, DLOG.
!     MODE OF INTERNAL OPERATIONS--DOUBLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     ACCURACY--(ON THE UNIVAC 1108, EXEC 8 SYSTEM AT NBS)
!               COMPARED TO THE KNOWN GAMMA = 1 (EXPONENTIAL)
!               RESULTS, AGREEMENT WAS HAD OUT TO 7 SIGNIFICANT
!               DIGITS FOR ALL TESTED X.
!               THE TESTED X VALUES COVERED THE ENTIRE
!               RANGE OF THE DISTRIBUTION--FROM THE 0.00001
!               PERCENT POINT UP TO THE 99.99999 PERCENT POINT
!               OF THE DISTRIBUTION.
!     REFERENCES--WILK, GNANADESIKAN, AND HUYETT, 'PROBABILITY
!                 PLOTS FOR THE GAMMA DISTRIBUTION',
!                 TECHNOMETRICS, 1962, PAGES 1-15,
!                 ESPECIALLY PAGES 3-5.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 257, FORMULA 6.1.41.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 166-206.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 68-73.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DOUBLE PRECISION dx , dgamma , ai , term , sum , cut1 , cut2 ,    &
     &                 cutoff , t
      DOUBLE PRECISION z , z2 , z3 , z4 , z5 , den , a , b , c , d , g
      DOUBLE PRECISION DEXP , DLOG
      DIMENSION d(10)
      DATA c/.918938533204672741D0/
      DATA d(1) , d(2) , d(3) , d(4) , d(5)/ + .833333333333333333D-1 , &
     &     -.277777777777777778D-2 , +.793650793650793651D-3 ,          &
     &     -.595238095238095238D-3 , +.841750841750841751D-3/
      DATA d(6) , d(7) , d(8) , d(9) , d(10)/ - .191752691752691753D-2 ,&
     &     +.641025641025641025D-2 , -.295506535947712418D-1 ,          &
     &     +.179644372368830573D0 , -.139243221690590111D1/
!
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( X<=0.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE GAMC&
     &DF SUBROUTINE IS NON-POSITIVE *****')
         WRITE (ipr,99007) X
         Cdf = 0.0
         RETURN
      ELSEIF ( Gamma<=0.0 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE GAMCDF SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99007) Gamma
         Cdf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         dx = X
         dgamma = Gamma
         maxit = 10000
!
!     COMPUTE THE GAMMA FUNCTION USING THE ALGORITHM IN THE
!     NBS APPLIED MATHEMATICS SERIES REFERENCE.
!
         z = dgamma
         den = 1.0D0
         DO WHILE ( z<10.0D0 )
            den = den*z
            z = z + 1
         ENDDO
         z2 = z*z
         z3 = z*z2
         z4 = z2*z2
         z5 = z2*z3
         a = (z-0.5D0)*DLOG(z) - z + c
         b = d(1)/z + d(2)/z3 + d(3)/z5 + d(4)/(z2*z5) + d(5)/(z4*z5)   &
     &       + d(6)/(z*z5*z5) + d(7)/(z3*z5*z5) + d(8)/(z5*z5*z5) + d(9)&
     &       /(z2*z5*z5*z5)
         g = DEXP(a+b)/den
!
!     COMPUTE T-SUB-Q AS DEFINED ON PAGE 4 OF THE WILK, GNANADESIKAN,
!     AND HUYETT REFERENCE
!
         sum = 1.0D0/dgamma
         term = 1.0D0/dgamma
         cut1 = dx - dgamma
         cut2 = dx*10000000000.0D0
         DO i = 1 , maxit
            ai = i
            term = dx*term/(dgamma+ai)
            sum = sum + term
            cutoff = cut1 + (cut2*term/sum)
            IF ( ai>cutoff ) GOTO 50
         ENDDO
         WRITE (ipr,99003) maxit
!
99003    FORMAT (' ','*****ERROR IN INTERNAL OPERATIONS IN THE GAMCDF ',&
     &           'SUBROUTINE--THE NUMBER OF ITERATIONS EXCEEDS ',I7)
         WRITE (ipr,99004) X
99004    FORMAT (' ','     THE INPUT VALUE OF X     IS ',E15.8)
         WRITE (ipr,99005) Gamma
99005    FORMAT (' ','     THE INPUT VALUE OF GAMMA IS ',E15.8)
         WRITE (ipr,99006)
99006    FORMAT (' ','     THE OUTPUT VALUE OF CDF HAS BEEN SET TO 1.0')
         Cdf = 1.0
         RETURN
!
 50      t = sum
         Cdf = (dx**dgamma)*(DEXP(-dx))*t/g
      ENDIF
99007 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
      END SUBROUTINE GAMCDF
!*==gamplt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE GAMPLT(X,N,Gamma)
      IMPLICIT NONE
!*--GAMPLT8228
!*** Start of declarations inserted by SPAG
      REAL acount , aj , an , cc , cut1 , cut2 , cutoff , dgamma , dp , &
     &     dx , g , Gamma , hold , pcalc , pp0025 , pp025 , pp975 ,     &
     &     pp9975 , sum , sum1
      REAL sum2 , sum3 , t , tau , term , u , W , wbar , WS , X , xdel ,&
     &     xlower , xmax , xmid , xmin , xmin0 , xupper , Y , ybar ,    &
     &     yint
      REAL yslope
      INTEGER i , icount , iloop , ip1 , ipr , itail , iupper , j , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT GAMPLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES A GAMMA
!              PROBABILITY PLOT
!              (WITH TAIL LENGTH PARAMETER VALUE = GAMMA).
!              THE PROTOTYPE GAMMA DISTRIBUTION USED
!              HEREIN HAS MEAN = GAMMA
!              AND STANDARD DEVIATION = SQRT(GAMMA).
!              THIS DISTRIBUTION IS DEFINED FOR ALL POSITIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/CONSTANT) * (X**(GAMMA-1)) * EXP(-X)
!              WHERE THE CONSTANT = THE GAMMA FUNCTION EVALUATED
!              AT THE VALUE GAMMA.
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE GAMMA PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE  GAMMA DISTRIBUTION
!              WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --GAMMA  = THE SINGLE PRECISION VALUE OF THE
!                                TAIL LENGTH PARAMETER.
!                                GAMMA SHOULD BE POSITIVE.
!     OUTPUT--A ONE-PAGE GAMMA PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!                 --GAMMA SHOULD BE POSITIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, ABS, EXP, DEXP, DLOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION AND DOUBLE PRECISION
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--WILK, GNANADESIKAN, AND HUYETT, 'PROBABILITY
!                 PLOTS FOR THE GAMMA DISTRIBUTION',
!                 TECHNOMETRICS, 1962, PAGES 1-15.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 257, FORMULA 6.1.41.
!               --FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 166-206.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1974.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DOUBLE PRECISION z , z2 , z3 , z4 , z5 , den , a , b , c , d
      DOUBLE PRECISION DEXP , DLOG
      DIMENSION d(10)
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
      DATA c/.918938533204672741D0/
      DATA d(1) , d(2) , d(3) , d(4) , d(5)/ + .833333333333333333D-1 , &
     &     -.277777777777777778D-2 , +.793650793650793651D-3 ,          &
     &     -.595238095238095238D-3 , +.841750841750841751D-3/
      DATA d(6) , d(7) , d(8) , d(9) , d(10)/ - .191752691752691753D-2 ,&
     &     +.641025641025641025D-2 , -.295506535947712418D-1 ,          &
     &     +.179644372368830573D0 , -.139243221690590111D1/
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE GAMPLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE GAMP&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         IF ( Gamma<=0.0 ) THEN
            WRITE (ipr,99004)
99004       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE GAMPLT SUBROU&
     &TINE IS NON-POSITIVE *****')
            WRITE (ipr,99005) Gamma
99005       FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,    &
     &              ' *****')
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99006) hold
99006       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE GAMPLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
         dgamma = Gamma
!
!     COMPUTE THE GAMMA FUNCTION USING THE ALGORITHM IN THE
!     NBS APPLIED MATHEMATICS SERIES REFERENCE.
!     THIS GAMMA FUNCTION NEED BE CALCULATED ONLY ONCE.
!     IT IS USED IN THE CALCULATION OF THE CDF BASED ON
!     THE TENTATIVE VALUE OF THE PPF IN THE ITERATION.
!
         z = dgamma
         den = 1.0D0
         DO WHILE ( z<10.0D0 )
            den = den*z
            z = z + 1.0D0
         ENDDO
         z2 = z*z
         z3 = z*z2
         z4 = z2*z2
         z5 = z2*z3
         a = (z-0.5D0)*DLOG(z) - z + c
         b = d(1)/z + d(2)/z3 + d(3)/z5 + d(4)/(z2*z5) + d(5)/(z4*z5)   &
     &       + d(6)/(z*z5*z5) + d(7)/(z3*z5*z5) + d(8)/(z5*z5*z5) + d(9)&
     &       /(z2*z5*z5*z5)
         g = DEXP(a+b)/den
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     GENERATE GAMMA DISTRIBUTION ORDER STATISTIC MEDIANS
!
!     DETERMINE LOWER AND UPPER BOUNDS ON THE DESIRED I-TH GAMMA
!     ORDER STATISTIC MEDIAN.
!     FOR EACH I, A LOWER BOUND IS GIVEN BY
!     (Y(I)*GAMMA*THE GAMMA FUNCTION OF GAMMA)**(1.0/GAMMA)
!     WHERE Y(I) IS THE CORRESPONDING UNIFORM (0,1) ORDER STATISIC
!     MEDIAN.
!     FOR EACH I EXCEPT I = N, AN UPPER BOUND IS GIVEN BY THE
!     (I+1)-ST GAMMA ORDER STATISTIC MEDIAN (ASSUMEDLY ALREADY
!     CALCULTATED).
!     FOR I = N, AN UPPER BOUND IS DETERMINED BY COMPUTING
!     MULTIPLES OF THE LOWER BOUND FOR I = N UNTIL A LARGER
!     VALUE IS OBTAINED.
!     DUE TO THE ABOVE CONSIDERATIONS, THE GAMMA ORDER STATISTIC
!     MEDIANS WILL BE CALCULATED LARGEST TO SMALLEST, THAT IS,
!     IN THE FOLLOWING SEQUENCE:  W(N), W(N-1), ..., W(2), W(1).
!     NOTE ALSO THAT 1) THE CODE IS COMPLICATED SLIGHTLY BY THE
!     FACT THAT PERCENT POINT VALUES INVOLVED IN THE CALCULATION OF
!     THE TAIL LENGTH MEASURE TAU (SEE LABEL 605) ARE GOING ON
!     'SIMULATNEOUSLY'. AND 2) THE VECTOR W WILL AT VARIOUS TIMES
!     IN THE PROGRAM HAVE UNIFORM ORDER STATISTIC MEDIANS AND
!     THEN LATER GRADUALLY FILL UP WITH GAMMA ORDER STATISTIC
!     MEDIANS.
!
         i = N
         itail = 0
      ENDIF
 100  IF ( itail==0 ) u = W(i)
      dp = u
      xmin0 = (u*Gamma*g)**(1.0/Gamma)
      xmin = xmin0
      IF ( i==N .OR. itail>=1 ) THEN
         iloop = 1
         icount = 1
      ELSE
         ip1 = i + 1
         xmax = W(ip1)
         GOTO 300
      ENDIF
 200  acount = icount
      xmax = acount*xmin0
      dx = xmax
      GOTO 600
 300  xmid = (xmin+xmax)/2.0
!
!     AT THIS STAGE WE NOW HAVE LOWER AND UPPER LIMITS ON
!     THE DESIRED I-TH GAMMA ORDER STATISITC MEDIAN W(I).
!     NOW ITERATE BY BISECTION UNTIL THE DESIRED ACCURACY IS ACHIEVED
!     FOR THE I-TH GAMMA ORDER STATISITIC MEDIAN.
!
      iloop = 2
      xlower = xmin
      xupper = xmax
      icount = 0
 400  dx = xmid
      GOTO 600
 500  IF ( itail<1 ) THEN
         W(i) = xmid
         IF ( i<=1 ) THEN
!
!     AT THIS POINT, THE GAMMA ORDER STATISTIC MEDIANS ARE ALL COMPUTED.
!     NOW PLOT OUT THE GAMMA PROBABILITY PLOT
!
            CALL PLOT(Y,W,N)
         ELSE
            i = i - 1
            GOTO 100
         ENDIF
      ENDIF
!
!     COMPUTE THE TAIL LENGTH MEASURE OF THE DISTRIBUTION.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
      IF ( itail==0 ) THEN
         u = .9975
         itail = 1
         GOTO 100
      ELSEIF ( itail==1 ) THEN
         pp9975 = xmid
         u = .0025
         itail = 2
         GOTO 100
      ELSEIF ( itail==2 ) THEN
         pp0025 = xmid
         u = .975
         itail = 3
         GOTO 100
      ELSEIF ( itail==3 ) THEN
         pp975 = xmid
         u = .025
         itail = 4
         GOTO 100
      ELSE
         pp025 = xmid
         tau = (pp9975-pp0025)/(pp975-pp025)
         WRITE (ipr,99007) Gamma , tau , N
!
99007    FORMAT (' ','GAMMA PROBABILITY PLOT WITH SHAPE PARAMETER = ',  &
     &           E17.10,1X,'(TAU = ',E15.8,')',16X,'SAMPLE SIZE N = ',  &
     &           I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         sum2 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
            sum2 = sum2 + W(i)
         ENDDO
         ybar = sum1/an
         wbar = sum2/an
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + (Y(i)-ybar)*(W(i)-wbar)
            sum3 = sum3 + (W(i)-wbar)*(W(i)-wbar)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99008) cc , yint , yslope
99008    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
!
         RETURN
      ENDIF
!
!********************************************************************
!     THIS SECTION BELOW IS LOGICALLY SEPARATE FROM THE ABOVE.
!     THIS SECTION COMPUTES A CDF VALUE FOR ANY GIVEN TENTATIVE
!     PERCENT POINT X VALUE AS DEFINED IN EITHER OF THE 2
!     ITERATION LOOPS IN THE ABOVE CODE.
!
!     COMPUTE T-SUB-Q AS DEFINED ON PAGE 4 OF THE WILK, GNANADESIKAN,
!     AND HUYETT REFERENCE
!
 600  sum = 1.0/dgamma
      term = 1.0/dgamma
      cut1 = dx - dgamma
      cut2 = dx*10000000.0
      DO j = 1 , 1000
         aj = j
         term = dx*term/(dgamma+aj)
         sum = sum + term
         cutoff = cut1 + (cut2*term/sum)
         IF ( aj>cutoff ) GOTO 700
      ENDDO
      WRITE (ipr,99009)
99009 FORMAT (' ','*****ERROR IN INTERNAL OPERATIONS IN THE GAMPLT ',   &
     &        'SUBROUTINE--THE NUMBER OF CDF ITERATIONS EXCEEDS 1000')
      WRITE (ipr,99010) Gamma
99010 FORMAT (' ','     THE INPUT VALUE OF GAMMA IS ',E15.8)
 700  t = sum
      pcalc = (dx**dgamma)*(EXP(-dx))*t/g
      IF ( iloop==1 ) THEN
         IF ( pcalc>=dp ) GOTO 300
         xmin = xmax
         icount = icount + 1
         IF ( icount>30000 ) GOTO 300
         GOTO 200
      ELSE
         IF ( pcalc==dp ) GOTO 500
         IF ( pcalc>dp ) THEN
            xupper = xmid
            xmid = (xmid+xlower)/2.0
         ELSE
            xlower = xmid
            xmid = (xmid+xupper)/2.0
         ENDIF
         xdel = ABS(xmid-xlower)
         icount = icount + 1
         IF ( xdel>=0.0000001 .AND. icount<=100 ) GOTO 400
         GOTO 500
      ENDIF
!
      END SUBROUTINE GAMPLT
!*==gamppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE GAMPPF(P,Gamma,Ppf)
      IMPLICIT NONE
!*--GAMPPF8588
!*** Start of declarations inserted by SPAG
      REAL Gamma , P , Ppf
      INTEGER icount , iloop , ipr , j , maxit
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT GAMPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE GAMMA DISTRIBUTION
!              WITH SINGLE PRECISION
!              TAIL LENGTH PARAMETER = GAMMA.
!              THE GAMMA DISTRIBUTION USED
!              HEREIN HAS MEAN = GAMMA
!              AND STANDARD DEVIATION = SQRT(GAMMA).
!              THIS DISTRIBUTION IS DEFINED FOR ALL POSITIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/CONSTANT) * (X**(GAMMA-1)) * EXP(-X)
!              WHERE THE CONSTANT = THE GAMMA FUNCTION EVALUATED
!              AT THE VALUE GAMMA.
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 (EXCLUSIVELY)
!                                AND 1.0 (EXCLUSIVELY))
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!                     --GAMMA  = THE SINGLE PRECISION VALUE OF THE
!                                TAIL LENGTH PARAMETER.
!                                GAMMA SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT FUNCTION .
!             VALUE PPF FOR THE GAMMA DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--GAMMA SHOULD BE POSITIVE.
!                 --P SHOULD BE BETWEEN 0.0 (EXCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--DEXP, DLOG.
!     MODE OF INTERNAL OPERATIONS--DOUBLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     ACCURACY--(ON THE UNIVAC 1108, EXEC 8 SYSTEM AT NBS)
!               COMPARED TO THE KNOWN GAMMA = 1 (EXPONENTIAL)
!               RESULTS, AGREEMENT WAS HAD OUT TO 6 SIGNIFICANT
!               DIGITS FOR ALL TESTED P IN THE RANGE P = .001 TO
!               P = .999.  FOR P = .95 AND SMALLER, THE AGREEMENT
!               WAS EVEN BETTER--7 SIGNIFICANT DIGITS.
!               (NOTE THAT THE TABULATED VALUES GIVEN IN THE WILK,
!               GNANADESIKAN, AND HUYETT REFERENCE BELOW, PAGE 20,
!               ARE IN ERROR FOR AT LEAST THE GAMMA = 1 CASE--
!               THE WORST DETECTED ERROR WAS AGREEMENT TO ONLY 3
!               SIGNIFICANT DIGITS (IN THEIR 8 SIGNIFICANT DIGIT TABLE)
!               FOR P = .999.)
!     REFERENCES--WILK, GNANADESIKAN, AND HUYETT, 'PROBABILITY
!                 PLOTS FOR THE GAMMA DISTRIBUTION',
!                 TECHNOMETRICS, 1962, PAGES 1-15,
!                 ESPECIALLY PAGES 3-5.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 257, FORMULA 6.1.41.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 166-206.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 68-73.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1974.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DOUBLE PRECISION dp , dgamma
      DOUBLE PRECISION z , z2 , z3 , z4 , z5 , den , a , b , c , d , g
      DOUBLE PRECISION xmin0 , xmin , ai , xmax , dx , pcalc , xmid
      DOUBLE PRECISION xlower , xupper , xdel
      DOUBLE PRECISION sum , term , cut1 , cut2 , aj , cutoff , t
      DOUBLE PRECISION DEXP , DLOG
      DIMENSION d(10)
      DATA c/.918938533204672741D0/
      DATA d(1) , d(2) , d(3) , d(4) , d(5)/ + .833333333333333333D-1 , &
     &     -.277777777777777778D-2 , +.793650793650793651D-3 ,          &
     &     -.595238095238095238D-3 , +.841750841750841751D-3/
      DATA d(6) , d(7) , d(8) , d(9) , d(10)/ - .191752691752691753D-2 ,&
     &     +.641025641025641025D-2 , -.295506535947712418D-1 ,          &
     &     +.179644372368830573D0 , -.139243221690590111D1/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE GAMPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99007) P
         Ppf = 0.0
         RETURN
      ELSEIF ( Gamma<=0.0 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE GAMPPF SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99007) Gamma
         Ppf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         dp = P
         dgamma = Gamma
         maxit = 10000
!
!     COMPUTE THE GAMMA FUNCTION USING THE ALGORITHM IN THE
!     NBS APPLIED MATHEMATICS SERIES REFERENCE.
!     THIS GAMMA FUNCTION NEED BE CALCULATED ONLY ONCE.
!     IT IS USED IN THE CALCULATION OF THE CDF BASED ON
!     THE TENTATIVE VALUE OF THE PPF IN THE ITERATION.
!
         z = dgamma
         den = 1.0D0
         DO WHILE ( z<10.0D0 )
            den = den*z
            z = z + 1.0D0
         ENDDO
         z2 = z*z
         z3 = z*z2
         z4 = z2*z2
         z5 = z2*z3
         a = (z-0.5D0)*DLOG(z) - z + c
         b = d(1)/z + d(2)/z3 + d(3)/z5 + d(4)/(z2*z5) + d(5)/(z4*z5)   &
     &       + d(6)/(z*z5*z5) + d(7)/(z3*z5*z5) + d(8)/(z5*z5*z5) + d(9)&
     &       /(z2*z5*z5*z5)
         g = DEXP(a+b)/den
!
!     DETERMINE LOWER AND UPPER LIMITS ON THE DESIRED 100P
!     PERCENT POINT.
!
         iloop = 1
         xmin0 = (dp*dgamma*g)**(1.0D0/dgamma)
         xmin = xmin0
         icount = 1
      ENDIF
 100  ai = icount
      xmax = ai*xmin0
      dx = xmax
      GOTO 500
 200  xmid = (xmin+xmax)/2.0D0
!
!     NOW ITERATE BY BISECTION UNTIL THE DESIRED ACCURACY IS ACHIEVED.
!
      iloop = 2
      xlower = xmin
      xupper = xmax
      icount = 0
 300  dx = xmid
      GOTO 500
 400  Ppf = xmid
      RETURN
!
!********************************************************************
!     THIS SECTION BELOW IS LOGICALLY SEPARATE FROM THE ABOVE.
!     THIS SECTION COMPUTES A CDF VALUE FOR ANY GIVEN TENTATIVE
!     PERCENT POINT X VALUE AS DEFINED IN EITHER OF THE 2
!     ITERATION LOOPS IN THE ABOVE CODE.
!
!     COMPUTE T-SUB-Q AS DEFINED ON PAGE 4 OF THE WILK, GNANADESIKAN,
!     AND HUYETT REFERENCE
!
 500  sum = 1.0D0/dgamma
      term = 1.0D0/dgamma
      cut1 = dx - dgamma
      cut2 = dx*10000000000.0D0
      DO j = 1 , maxit
         aj = j
         term = dx*term/(dgamma+aj)
         sum = sum + term
         cutoff = cut1 + (cut2*term/sum)
         IF ( aj>cutoff ) GOTO 600
      ENDDO
      WRITE (ipr,99003) maxit
!
99003 FORMAT (' ','*****ERROR IN INTERNAL OPERATIONS IN THE GAMPPF ',   &
     &        'SUBROUTINE--THE NUMBER OF ITERATIONS EXCEEDS ',I7)
      WRITE (ipr,99004) P
99004 FORMAT (' ','     THE INPUT VALUE OF P     IS ',E15.8)
      WRITE (ipr,99005) Gamma
99005 FORMAT (' ','     THE INPUT VALUE OF GAMMA IS ',E15.8)
      WRITE (ipr,99006)
99006 FORMAT (' ','     THE OUTPUT VALUE OF PPF HAS BEEN SET TO 0.0')
      Ppf = 0.0
      RETURN
!
 600  t = sum
      pcalc = (dx**dgamma)*(DEXP(-dx))*t/g
      IF ( iloop==1 ) THEN
         IF ( pcalc>=dp ) GOTO 200
         xmin = xmax
         icount = icount + 1
         IF ( icount>30000 ) GOTO 200
         GOTO 100
      ELSE
         IF ( pcalc==dp ) GOTO 400
         IF ( pcalc>dp ) THEN
            xupper = xmid
            xmid = (xmid+xlower)/2.0D0
         ELSE
            xlower = xmid
            xmid = (xmid+xupper)/2.0D0
         ENDIF
         xdel = xmid - xlower
         IF ( xdel<0.0D0 ) xdel = -xdel
         icount = icount + 1
         IF ( xdel>=0.0000000001D0 .AND. icount<=100 ) GOTO 300
         GOTO 400
      ENDIF
99007 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
      END SUBROUTINE GAMPPF
!*==gamran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE GAMRAN(N,Gamma,Iseed,X)
      IMPLICIT NONE
!*--GAMRAN8819
!*** Start of declarations inserted by SPAG
      REAL a1 , arg , athird , b1 , funct , Gamma , sqrt3 , term , u(1) ,  &
     &     X , xg , xg0 , xn(1) , xn0
      INTEGER i , ipr , Iseed , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT GAMRAN
!     ******STILL NEEDS ALGORITHM WORK ******
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE GAMMA DISTRIBUTION
!              WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!              THE PROTOTYPE GAMMA DISTRIBUTION USED
!              HEREIN HAS MEAN = GAMMA
!              AND STANDARD DEVIATION = SQRT(GAMMA).
!              THIS DISTRIBUTION IS DEFINED FOR ALL POSITIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/CONSTANT) * (X**(GAMMA-1)) * EXP(-X)
!              WHERE THE CONSTANT = THE GAMMA FUNCTION EVALUATED
!              AT THE VALUE GAMMA.
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!                     --GAMMA  = THE SINGLE PRECISION VALUE OF THE
!                                TAIL LENGTH PARAMETER.
!                                GAMMA SHOULD BE POSITIVE.
!                                GAMMA SHOULD BE LARGER
!                                THAN 1/3 (ALGORITHMIC RESTRICTION).
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE GAMMA DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!                 --GAMMA SHOULD BE POSITIVE.
!                 --GAMMA SHOULD BE LARGER
!                   THAN 1/3 (ALGORITHMIC RESTRICTION).
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN, NORRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     REFERENCES--GREENWOOD, 'A FAST GENERATOR FOR
!                 GAMMA-DISTRIBUTED RANDOM VARIABLES',
!                 COMPSTAT 1974, PROCEEDINGS IN
!                 COMPUTATIONAL STATISTICS, VIENNA,
!                 SEPTEMBER, 1974, PAGES 19-27.
!               --TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 24-27.
!               --HAMMERSLEY AND HANDSCOMB, MONTE CARLO METHODS,
!                 1964, PAGES 36-37.
!               --WILK, GNANADESIKAN, AND HUYETT, 'PROBABILITY
!                 PLOTS FOR THE GAMMA DISTRIBUTION',
!                 TECHNOMETRICS, 1962, PAGES 1-15.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 166-206.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 68-73.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 952.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82/7
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --JUNE      1978.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MARCH     1982.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
!-----DATA STATEMENTS-------------------------------------------------
!
      DATA athird/0.3333333/
      DATA sqrt3/1.73205081/
!
      ipr = 6
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE GAMRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( Gamma<=0.0 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE GAMRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99006) Gamma
         RETURN
      ELSEIF ( Gamma<=0.33333333 ) THEN
         WRITE (ipr,99004)
99004    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE GAMRAN SUBROU&
     &TINE IS SMALLER THAN OR EQUAL TO 0.33333333 *****')
         WRITE (ipr,99005)
99005    FORMAT (' ','                   (ALGORITHMIC RESTIRCTION)')
         WRITE (ipr,99006) Gamma
         RETURN
      ELSE
!
!     GENERATE N GAMMA DISTRIBUTION RANDOM NUMBERS
!     USING GREENWOOD'S REJECTION ALGORITHM--
!     1) GENERATE A NORMAL RANDOM NUMBER;
!     2) TRANSFORM THE NORMAL VARIATE TO AN APPROXIMATE
!        GAMMA VARIATE USING THE WILSON-HILFERTY
!        APPROXIMATION (SEE THE JOHNSON AND KOTZ
!        REFERENCE, PAGE 176);
!     3) FORM THE REJECTION FUNCTION VALUE, BASED
!        ON THE PROBABILITY DENSITY FUNCTION VALUE
!        OF THE ACTUAL DISTRIBUTION OF THE PSEUDO-GAMMA
!        VARIATE, AND THE PROBABILITY DENSITY FUNCTION VALUE
!        OF A TRUE GAMMA VARIATE.
!     4) GENERATE A UNIFORM RANDOM NUMBER;
!     5) IF THE UNIFORM RANDOM NUMBER IS LESS THAN
!        THE REJECTION FUNCTION VALUE, THEN ACCEPT
!        THE PSEUDO-RANDOM NUMBER AS A GAMMA VARIATE;
!        IF THE UNIFORM RANDOM NUMBER IS LARGER THAN
!        THE REJECTION FUNCTION VALUE, THEN REJECT
!        THE PSEUDO-RANDOM NUMBER AS A GAMMA VARIATE.
!
         a1 = 1.0/(9.0*Gamma)
         b1 = SQRT(a1)
         xn0 = -sqrt3 + b1
         xg0 = Gamma*(1.0-a1+b1*xn0)**3
         DO i = 1 , N
            DO
               CALL NORRAN(1,Iseed,xn)
               xg = Gamma*(1.0-a1+b1*xn(1))**3
               IF ( xg>=0.0 ) THEN
                  term = (xg/xg0)**(Gamma-athird)
                  arg = 0.5*xn(1)*xn(1) - xg - 0.5*xn0*xn0 + xg0
                  funct = term*EXP(arg)
                  CALL UNIRAN(1,Iseed,u(1))
                  IF ( u(1)<=funct ) THEN
                     X(i) = xg
                     EXIT
                  ENDIF
               ENDIF
            ENDDO
         ENDDO
      ENDIF
99006 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
      END SUBROUTINE GAMRAN
!*==geocdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE GEOCDF(X,P,Cdf)
      IMPLICIT NONE
!*--GEOCDF9005
!*** Start of declarations inserted by SPAG
      REAL Cdf , del , fintx , P , X
      INTEGER intx , ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT GEOCDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE AT THE SINGLE PRECISION VALUE X
!              FOR THE GEOMETRIC DISTRIBUTION
!              WITH SINGLE PRECISION
!              'BERNOULLI PROBABILITY' PARAMETER = P.
!              THE GEOMETRIC DISTRIBUTION USED HEREIN
!              HEREIN HAS MEAN = (1-P)/P
!              AND STANDARD DEVIATION = SQRT((1-P)/(P*P))).
!              THIS DISTRIBUTION IS DEFINED FOR
!              ALL NON-NEGATIVE INTEGER X--X = 0, 1, 2, ... .
!              THIS DISTRIBUTION HAS THE PROBABILITY FUNCTION
!              F(X) = P * (1-P)**X.
!              THE GEOMETRIC DISTRIBUTION IS THE
!              DISTRIBUTION OF THE NUMBER OF FAILURES
!              BEFORE OBTAINING 1 SUCCESS IN AN
!              INDEFINITE SEQUENCE OF BERNOULLI (0,1)
!              TRIALS WHERE THE PROBABILITY OF SUCCESS
!              IN A SINGLE TRIAL = P.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE
!                                AT WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!                                X SHOULD BE NON-NEGATIVE AND
!                                INTEGRAL-VALUED.
!                     --P      = THE SINGLE PRECISION VALUE
!                                OF THE 'BERNOULLI PROBABILITY'
!                                PARAMETER FOR THE GEOMETRIC
!                                DISTRIBUTION.
!                                P SHOULD BE BETWEEN
!                                0.0 (EXCLUSIVELY) AND
!                                1.0 (EXCLUSIVELY).
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF
!             FOR THE GEOMETRIC DISTRIBUTION
!             WITH 'BERNOULLI PROBABILITY' PARAMETER = P.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--X SHOULD BE NON-NEGATIVE AND INTEGRAL-VALUED.
!                 --P SHOULD BE BETWEEN 0.0 (EXCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--NOTE THAT EVEN THOUGH THE INPUT
!              TO THIS CUMULATIVE
!              DISTRIBUTION FUNCTION SUBROUTINE
!              FOR THIS DISCRETE DISTRIBUTION
!              SHOULD (UNDER NORMAL CIRCUMSTANCES) BE A
!              DISCRETE INTEGER VALUE,
!              THE INPUT VARIABLE X IS SINGLE
!              PRECISION IN MODE.
!              X HAS BEEN SPECIFIED AS SINGLE
!              PRECISION SO AS TO CONFORM WITH THE DATAPAC
!              CONVENTION THAT ALL INPUT ****DATA****
!              (AS OPPOSED TO SAMPLE SIZE, FOR EXAMPLE)
!              VARIABLES TO ALL
!              DATAPAC SUBROUTINES ARE SINGLE PRECISION.
!              THIS CONVENTION IS BASED ON THE BELIEF THAT
!              1) A MIXTURE OF MODES (FLOATING POINT
!              VERSUS INTEGER) IS INCONSISTENT AND
!              AN UNNECESSARY COMPLICATION
!              IN A DATA ANALYSIS; AND
!              2) FLOATING POINT MACHINE ARITHMETIC
!              (AS OPPOSED TO INTEGER ARITHMETIC)
!              IS THE MORE NATURAL MODE FOR DOING
!              DATA ANALYSIS.
!     REFERENCES--FELLER, AN INTRODUCTION TO PROBABILITY
!                 THEORY AND ITS APPLICATIONS, VOLUME 1,
!                 EDITION 2, 1957, PAGES 155-157, 210.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 929.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE GEOCDF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99004) P
         Cdf = 0.0
         RETURN
      ELSEIF ( X<0.0 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE GEOC&
     &DF SUBROUTINE IS NEGATIVE *****')
         WRITE (ipr,99004) X
         Cdf = 0.0
         RETURN
      ELSE
         intx = X + 0.0001
         fintx = intx
         del = X - fintx
         IF ( del<0.0 ) del = -del
         IF ( del>0.001 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE GEOC&
     &DF SUBROUTINE IS NON-INTEGRAL *****')
            WRITE (ipr,99004) X
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
         Cdf = 1.0 - (1.0-P)**(X+1.0)
      ENDIF
99004 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
      END SUBROUTINE GEOCDF
!*==geoplt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE GEOPLT(X,N,P)
      IMPLICIT NONE
!*--GEOPLT9137
!*** Start of declarations inserted by SPAG
      REAL an , cc , hold , P , pp0025 , pp025 , pp975 , pp9975 , q ,   &
     &     sum1 , sum2 , sum3 , tau , W , wbar , WS , X , Y , ybar ,    &
     &     yint
      REAL yslope
      INTEGER i , ipr , iupper , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT GEOPLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES A GEOMETRIC
!              PROBABILITY PLOT
!              (WITH 'BERNOULLI PROBABILITY' PARAMETER VALUE = P).
!              THE GEOMETRIC DISTRIBUTION USED
!              HEREIN HAS MEAN = (1-P)/P
!              AND STANDARD DEVIATION = SQRT((1-P)/(P*P))).
!              THIS DISTRIBUTION IS DEFINED FOR
!              ALL NON-NEGATIVE INTEGER X--X = 0, 1, 2, ... .
!              THIS DISTRIBUTION HAS THE PROBABILITY FUNCTION
!              F(X) = P * (1-P)**X.
!              THE GEOMETRIC DISTRIBUTION IS THE
!              DISTRIBUTION OF THE NUMBER OF FAILURES
!              BEFORE OBTAINING 1 SUCCESS IN AN
!              INDEFINITE SEQUENCE OF BERNOULLI (0,1)
!              TRIALS WHERE THE PROBABILITY OF SUCCESS
!              IN A SINGLE TRIAL = P.
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE GEOMETRIC PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE  GEOMETRIC DISTRIBUTION
!              WITH PROBABILITY PARAMETER VALUE = P.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --P      = THE SINGLE PRECISION VALUE
!                                OF THE 'BERNOULLI PROBABILITY'
!                                PARAMETER FOR THE GEOMETRIC
!                                DISTRIBUTION.
!                                P SHOULD BE BETWEEN
!                                0.0 (EXCLUSIVELY) AND
!                                1.0 (EXCLUSIVELY).
!     OUTPUT--A ONE-PAGE GEOMETRIC PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!                 --P SHOULD BE BETWEEN 0.0 (EXCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, PLOT, GEOPPF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --FELLER, AN INTRODUCTION TO PROBABILITY
!                 THEORY AND ITS APPLICATIONS, VOLUME 1,
!                 EDITION 2, 1957, PAGES 155-157, 210.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 929.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --MARCH     1987.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE GEOPLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE GEOP&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         IF ( P<=0.0 .OR. P>=1.0 ) THEN
            WRITE (ipr,99004)
99004       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE GEOPLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
            WRITE (ipr,99005) P
99005       FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,    &
     &              ' *****')
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99006) hold
99006       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE GEOPLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     COMPUTE GEOMETRIC DISTRIBUTION ORDER STATISTIC MEDIANS
!
         DO i = 1 , N
            CALL GEOPPF(W(i),P,W(i))
         ENDDO
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     COMPUTE THE TAIL LENGTH MEASURE OF THE DISTRIBUTION.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         q = .9975
         CALL GEOPPF(q,P,pp9975)
         q = .0025
         CALL GEOPPF(q,P,pp0025)
         q = .975
         CALL GEOPPF(q,P,pp975)
         q = .025
         CALL GEOPPF(q,P,pp025)
         tau = (pp9975-pp0025)/(pp975-pp025)
         WRITE (ipr,99007) P , tau , N
!
99007    FORMAT (' ','GEOMETRIC PROBABILITY PLOT WITH PROBABILITY ',    &
     &           'PARAMETER = ',E17.10,1X,'(TAU = ',E15.8,')',11X,      &
     &           'THE SAMPLE ','SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         sum2 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
            sum2 = sum2 + W(i)
         ENDDO
         ybar = sum1/an
         wbar = sum2/an
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + (Y(i)-ybar)*(W(i)-wbar)
            sum3 = sum3 + (W(i)-wbar)*(W(i)-wbar)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99008) cc , yint , yslope
99008    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
!
      END SUBROUTINE GEOPLT
!*==geoppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE GEOPPF(P,Ppar,Ppf)
      IMPLICIT NONE
!*--GEOPPF9341
!*** Start of declarations inserted by SPAG
      REAL aden , anum , aratio , arg1 , arg2 , P , Ppar , Ppf , ratio
      INTEGER ipr , iratio
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT GEOPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE GEOMETRIC
!              DISTRIBUTION WITH SINGLE PRECISION
!              'BERNOULLI PROBABILITY' PARAMETER = PPAR.
!              THE GEOMETRIC DISTRIBUTION USED
!              HEREIN HAS MEAN = (1-PPAR)/PPAR
!              AND STANDARD DEVIATION = SQRT((1-PPAR)/(PPAR*PPAR))).
!              THIS DISTRIBUTION IS DEFINED FOR
!              ALL NON-NEGATIVE INTEGER X--X = 0, 1, 2, ... .
!              THIS DISTRIBUTION HAS THE PROBABILITY FUNCTION
!              F(X) = PPAR * (1-PPAR)**X.
!              THE GEOMETRIC DISTRIBUTION IS THE
!              DISTRIBUTION OF THE NUMBER OF FAILURES
!              BEFORE OBTAINING 1 SUCCESS IN AN
!              INDEFINITE SEQUENCE OF BERNOULLI (0,1)
!              TRIALS WHERE THE PROBABILITY OF SUCCESS
!              IN A SINGLE TRIAL = PPAR.
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 (INCLUSIVELY)
!                                AND 1.0 (EXCLUSIVELY))
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!                     --PPAR   = THE SINGLE PRECISION VALUE
!                                OF THE 'BERNOULLI PROBABILITY'
!                                PARAMETER FOR THE GEOMETRIC
!                                DISTRIBUTION.
!                                PPAR SHOULD BE BETWEEN
!                                0.0 (EXCLUSIVELY) AND
!                                1.0 (EXCLUSIVELY).
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT FUNCTION .
!             VALUE PPF FOR THE GEOMETRIC DISTRIBUTION
!             WITH 'BERNOULLI PROBABILITY' PARAMETER VALUE = PPAR.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--PPAR SHOULD BE BETWEEN 0.0 (EXCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!                 --P SHOULD BE BETWEEN 0.0 (INCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--NOTE THAT EVEN THOUGH THE OUTPUT
!              FROM THIS DISCRETE DISTRIBUTION
!              PERCENT POINT FUNCTION
!              SUBROUTINE MUST NECESSARILY BE A
!              DISCRETE INTEGER VALUE,
!              THE OUTPUT VARIABLE PPF IS SINGLE
!              PRECISION IN MODE.
!              PPF HAS BEEN SPECIFIED AS SINGLE
!              PRECISION SO AS TO CONFORM WITH THE DATAPAC
!              CONVENTION THAT ALL OUTPUT VARIABLES FROM ALL
!              DATAPAC SUBROUTINES ARE SINGLE PRECISION.
!              THIS CONVENTION IS BASED ON THE BELIEF THAT
!              1) A MIXTURE OF MODES (FLOATING POINT
!              VERSUS INTEGER) IS INCONSISTENT AND
!              AN UNNECESSARY COMPLICATION
!              IN A DATA ANALYSIS; AND
!              2) FLOATING POINT MACHINE ARITHMETIC
!              (AS OPPOSED TO INTEGER ARITHMETIC)
!              IS THE MORE NATURAL MODE FOR DOING
!              DATA ANALYSIS.
!     REFERENCES--FELLER, AN INTRODUCTION TO PROBABILITY
!                 THEORY AND ITS APPLICATIONS, VOLUME 1,
!                 EDITION 2, 1957, PAGES 155-157, 210.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 929.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE GEOPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99003) P
         Ppf = 0.0
         RETURN
      ELSEIF ( Ppar<=0.0 .OR. Ppar>=1.0 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE GEOPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99003) Ppar
         Ppf = 0.0
         RETURN
!
!-----START POINT-----------------------------------------------------
!
      ELSEIF ( P/=0.0 ) THEN
!
         arg1 = 1.0 - P
         arg2 = 1.0 - Ppar
         anum = ALOG(arg1)
         aden = ALOG(arg2)
         ratio = anum/aden
         iratio = ratio
         Ppf = iratio
         aratio = iratio
         IF ( aratio==ratio ) Ppf = iratio - 1
         GOTO 99999
      ENDIF
      Ppf = 0.0
      RETURN
99003 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
99999 END SUBROUTINE GEOPPF
!*==georan.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE GEORAN(N,P,Iseed,X)
      IMPLICIT NONE
!*--GEORAN9473
!*** Start of declarations inserted by SPAG
      REAL aden , anum , aratio , arg1 , arg2 , P , ratio , X
      INTEGER i , ipr , iratio , Iseed , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT GEORAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE GEOMETRIC DISTRIBUTION
!              WITH SINGLE PRECISION 'BERNOULLI PROBABILITY'
!              PARAMETER = P.
!              THE GEOMETRIC DISTRIBUTION USED
!              HEREIN HAS MEAN = (1-P)/P
!              AND STANDARD DEVIATION = SQRT((1-P)/(P*P))).
!              THIS DISTRIBUTION IS DEFINED FOR
!              ALL NON-NEGATIVE INTEGER X--X = 0, 1, 2, ... .
!              THIS DISTRIBUTION HAS THE PROBABILITY FUNCTION
!              F(X) = P * (1-P)**X.
!              THE GEOMETRIC DISTRIBUTION IS THE
!              DISTRIBUTION OF THE NUMBER OF FAILURES
!              BEFORE OBTAINING 1 SUCCESS IN AN
!              INDEFINITE SEQUENCE OF BERNOULLI (0,1)
!              TRIALS WHERE THE PROBABILITY OF SUCCESS
!              IN A SINGLE TRIAL = P.
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!                     --P      = THE SINGLE PRECISION VALUE
!                                OF THE 'BERNOULLI PROBABILITY'
!                                PARAMETER FOR THE GEOMETRIC
!                                DISTRIBUTION.
!                                P SHOULD BE BETWEEN
!                                0.0 (EXCLUSIVELY) AND
!                                1.0 (EXCLUSIVELY).
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE GEOMETRIC DISTRIBUTION
!             WITH 'BERNOULLI PROBABILITY' PARAMETER = P.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!                 --P SHOULD BE BETWEEN 0.0 (EXCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     COMMENT--NOTE THAT EVEN THOUGH THE OUTPUT
!              FROM THIS DISCRETE RANDOM NUMBER
!              GENERATOR MUST NECESSARILY BE A
!              SEQUENCE OF ***INTEGER*** VALUES,
!              THE OUTPUT VECTOR X IS SINGLE
!              PRECISION IN MODE.
!              X HAS BEEN SPECIFIED AS SINGLE
!              PRECISION SO AS TO CONFORM WITH THE DATAPAC
!              CONVENTION THAT ALL OUTPUT VECTORS FROM ALL
!              DATAPAC SUBROUTINES ARE SINGLE PRECISION.
!              THIS CONVENTION IS BASED ON THE BELIEF THAT
!              1) A MIXTURE OF MODES (FLOATING POINT
!              VERSUS INTEGER) IS INCONSISTENT AND
!              AN UNNECESSARY COMPLICATION
!              IN A DATA ANALYSIS; AND
!              2) FLOATING POINT MACHINE ARITHMETIC
!              (AS OPPOSED TO INTEGER ARITHMETIC)
!              IS THE MORE NATURAL MODE FOR DOING
!              DATA ANALYSIS.
!     REFERENCES--TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 14-15.
!               --HAMMERSLEY AND HANDSCOMB, MONTE CARLO METHODS,
!                 1964, PAGE 36.
!               --FELLER, AN INTRODUCTION TO PROBABILITY
!                 THEORY AND ITS APPLICATIONS, VOLUME 1,
!                 EDITION 2, 1957, PAGES 155-157, 210.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 929.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82/7
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
      ipr = 6
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE GEORAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE GEORAN SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99004) P
99004    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!     GENERATE N UNIFORM (0,1) RANDOM NUMBERS;
!
         CALL UNIRAN(N,Iseed,X)
!
!     GENERATE N GEOMETRIC RANDOM NUMBERS
!     USING THE PERCENT POINT FUNCTION TRANSFORMATION METHOD.
!
         DO i = 1 , N
            IF ( X(i)/=0.0 ) THEN
               arg1 = 1.0 - X(i)
               arg2 = 1.0 - P
               anum = ALOG(arg1)
               aden = ALOG(arg2)
               ratio = anum/aden
               iratio = ratio
               X(i) = iratio
               aratio = iratio
               IF ( aratio==ratio ) X(i) = iratio - 1
            ENDIF
         ENDDO
      ENDIF
!
      END SUBROUTINE GEORAN
!*==hfncdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE HFNCDF(X,Cdf)
      IMPLICIT NONE
!*--HFNCDF9636
!*** Start of declarations inserted by SPAG
      REAL Cdf , X
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT HFNCDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR THE HALFNORMAL
!              DISTRIBUTION.
!              THE HALFNORMAL DISTRIBUTION USED
!              HEREIN HAS MEAN = SQRT(2/PI) = 0.79788456
!              AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL NON-NEGATIVE X
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (2/SQRT(2*PI)) * EXP(-X*X/2).
!              THE HALFNORMAL DISTRIBUTION USED HEREIN
!              IS THE DISTRIBUTION OF THE VARIATE X = ABS(Z) WHERE
!              THE VARIATE Z IS NORMALLY DISTRIBUTED
!              WITH MEAN = 0 AND STANDARD DEVIATION = 1.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE
!                                AT WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!                                X SHOULD BE NON-NEGATIVE.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF FOR THE HALFNORMAL
!             DISTRIBUTION WITH MEAN = SQRT(2/PI) = 0.79788456
!             AND STANDARD DEVIATION = 1.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--X SHOULD BE NON-NEGATIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NORCDF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 53, 59, 81, 83.
!               --DANIEL, 'USE OF HALF-NORMAL PLOTS IN
!                 INTERPRETING FACTORIAL TWO-LEVEL EXPERIMENTS',
!                 TECHNOMETRICS, 1959, PAGES 311-341.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --OCTOBER   1976.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( X<0.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE HFNC&
     &DF SUBROUTINE IS NEGATIVE *****')
         WRITE (ipr,99002) X
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         Cdf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         CALL NORCDF(X,Cdf)
         Cdf = 2.0*Cdf - 1.0
      ENDIF
!
      END SUBROUTINE HFNCDF
!*==hfnplt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE HFNPLT(X,N)
      IMPLICIT NONE
!*--HFNPLT9714
!*** Start of declarations inserted by SPAG
      REAL an , cc , hold , q , sum1 , sum2 , sum3 , tau , W , wbar ,   &
     &     WS , X , Y , ybar , yint , yslope
      INTEGER i , ipr , iupper , N
!*** End of declarations inserted by SPAG
!
!     PURPOSE--THIS SUBROUTINE GENERATES A HALFNORMAL
!              PROBABILITY PLOT.
!              THE PROTOTYPE HALFNORMAL DISTRIBUTION USED HEREIN
!              HAS MEAN = SQRT(2/PI) = 0.79788456
!              AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL NON-NEGATIVE X
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (2/SQRT(2*PI)) * EXP(-X*X/2).
!              THE PROTOTYPE HALFNORMAL DISTRIBUTION USED HEREIN
!              IS THE DISTRIBUTION OF THE VARIATE X = ABS(Z) WHERE
!              THE VARIATE Z IS NORMALLY DISTRIBUTED
!              WITH MEAN = 0 AND STANDARD DEVIATION = 1.
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE HALFNORMAL PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE HALFNORMAL DISTRIBUTION.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!     OUTPUT--A ONE-PAGE HALFNORMAL PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, NORPPF, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--DANIEL, 'USE OF HALF-NORMAL PLOTS IN
!                 INTERPRETING FACTORIAL TWO-LEVEL EXPERIMENTS',
!                 TECHNOMETRICS, 1959, PAGES 311-341.
!               --FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 53, 59, 81, 83.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
!
      DATA tau/1.41223913/
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE HFNPLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE HFNP&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE HFNPLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     COMPUTE HALFNORMAL ORDER STATISTIC MEDIANS
!
         DO i = 1 , N
            q = W(i)
            q = (q+1.0)/2.0
            CALL NORPPF(q,W(i))
         ENDDO
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         WRITE (ipr,99005) tau , N
!
99005    FORMAT (' ','HALFNORMAL PROBABILITY PLOT (TAU = ',E15.8,')',   &
     &           52X,'THE SAMPLE SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         sum2 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
            sum2 = sum2 + W(i)
         ENDDO
         ybar = sum1/an
         wbar = sum2/an
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + (Y(i)-ybar)*(W(i)-wbar)
            sum3 = sum3 + (W(i)-wbar)*(W(i)-wbar)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99006) cc , yint , yslope
99006    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
!
      END SUBROUTINE HFNPLT
!*==hfnppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE HFNPPF(P,Ppf)
      IMPLICIT NONE
!*--HFNPPF9883
!*** Start of declarations inserted by SPAG
      REAL arg , P , Ppf
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT HFNPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE HALFNORMAL
!              DISTRIBUTION.
!              THE HALFNORMAL DISTRIBUTION USED
!              HEREIN HAS MEAN = SQRT(2/PI) = 0.79788456
!              AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL NON-NEGATIVE X
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (2/SQRT(2*PI)) * EXP(-X*X/2).
!              THE HALFNORMAL DISTRIBUTION USED HEREIN
!              IS THE DISTRIBUTION OF THE VARIATE X = ABS(Z) WHERE
!              THE VARIATE Z IS NORMALLY DISTRIBUTED
!              WITH MEAN = 0 AND STANDARD DEVIATION = 1.
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 (INCLUSIVELY)
!                                AND 1.0 (EXCLUSIVELY))
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT FUNCTION .
!             VALUE PPF FOR THE HALFNORMAL DISTRIBUTION
!             WITH MEAN = SQRT(2/PI) = 0.79788456
!             AND STANDARD DEVIATION = 1.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0 (INCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NORPPF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 53, 59, 81, 83.
!               --DANIEL, 'USE OF HALF-NORMAL PLOTS IN
!                 INTERPRETING FACTORIAL TWO-LEVEL EXPERIMENTS',
!                 TECHNOMETRICS, 1959, PAGES 311-341.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --OCTOBER   1976.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE HFNPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         Ppf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         arg = (1.0+P)/2.0
         CALL NORPPF(arg,Ppf)
         IF ( Ppf<=0.0 ) Ppf = 0.0
      ENDIF
!
      END SUBROUTINE HFNPPF
!*==hfnran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE HFNRAN(N,Iseed,X)
      IMPLICIT NONE
!*--HFNRAN9967
!*** Start of declarations inserted by SPAG
      REAL arg1 , arg2 , pi , sqrt1 , u1 , u2 , X , y , z1 , z2
      INTEGER i , ip1 , ipr , Iseed , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT HFNRAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE HALFNORMAL DISTRIBUTION.
!              THE PROTOTYPE HALFNORMAL DISTRIBUTION USED
!              HEREIN HAS MEAN = SQRT(2/PI) = 0.79788456
!              AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL NON-NEGATIVE X
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (2/SQRT(2*PI)) * EXP(-X*X/2).
!              THE PROTOTYPE HALFNORMAL DISTRIBUTION USED HEREIN
!              IS THE DISTRIBUTION OF THE VARIATE X = ABS(Z) WHERE
!              THE VARIATE Z IS NORMALLY DISTRIBUTED
!              WITH MEAN = 0 AND STANDARD DEVIATION = 1.
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE HALFNORMAL DISTRIBUTION
!              WITH MEAN = SQRT(2/PI) = 0.79788456
!              AND STANDARD DEVIATION = 1.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG, SQRT, SIN, COS.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     REFERENCES--TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 14-15.
!               --HAMMERSLEY AND HANDSCOMB, MONTE CARLO METHODS,
!                 1964, PAGE 36.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 53, 59, 81, 83.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82/7
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --JULY      1976.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
      DIMENSION y(2)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
!-----DATA STATEMENTS-------------------------------------------------
!
      DATA pi/3.14159265359/
!
      ipr = 6
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE HFNRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
!
!     GENERATE N UNIFORM (0,1) RANDOM NUMBERS;
!     THEN GENERATE 2 ADDITIONAL UNIFORM (0,1) RANDOM NUMBERS
!     (TO BE USED BELOW IN FORMING THE N-TH NORMAL
!     RANDOM NUMBER WHEN THE DESIRED SAMPLE SIZE N
!     HAPPENS TO BE ODD).
!
         CALL UNIRAN(N,Iseed,X)
         CALL UNIRAN(2,Iseed,y)
!
!     GENERATE N NORMAL RANDOM NUMBERS
!     USING THE BOX-MULLER METHOD.
!
         DO i = 1 , N , 2
            ip1 = i + 1
            u1 = X(i)
            IF ( i==N ) THEN
               u2 = y(2)
            ELSE
               u2 = X(ip1)
            ENDIF
            arg1 = -2.0*ALOG(u1)
            arg2 = 2.0*pi*u2
            sqrt1 = SQRT(arg1)
            z1 = sqrt1*COS(arg2)
            z2 = sqrt1*SIN(arg2)
            X(i) = z1
            IF ( i/=N ) X(ip1) = z2
         ENDDO
!
!     GENERATE N HALFNORMAL RANDOM NUMBERS
!     USING THE DEFINITION THAT
!     A HALFNORMAL VARIATE
!     EQUALS THE ABSOLUTE VALUE OF A NORMAL VARIATE.
!
         DO i = 1 , N
            IF ( X(i)<0.0 ) X(i) = -X(i)
         ENDDO
      ENDIF
!
      END SUBROUTINE HFNRAN
!*==hist.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE HIST(X,N)
      IMPLICIT NONE
!*--HIST10109
!*** Start of declarations inserted by SPAG
      REAL acount , ai , amaxfr , an , cwidsd , cwidth , height , hold ,&
     &     prop , s , sum , tinc , tlable , X , xbar , xmax , xmin , z
      INTEGER i , icoun2 , icount , ievodd , ihist , inc , ipr , irev , &
     &        itlabl , ixlabl , j , jmax , jp1 , jsum , maxfre , mt ,   &
     &        mx , N , numcla , numhis
      INTEGER numout
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT HIST
!
!     PURPOSE--THIS SUBROUTINE PRODUCES 2 HISTOGRAMS
!              (WITH DIFFERING CLASS WIDTHS)
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE FIRST  HISTOGRAM HAS CLASS WIDTH = 0.1
!              SAMPLE STANDARD DEVIATIONS;
!              THE SECOND HISTOGRAM HAS CLASS WIDTH = 0.2
!              SAMPLE STANDARD DEVIATIONS.
!              TWO HISTOGRAMS OF THE SAME DATA SET
!              ARE PRINTED OUT SO AS TO GIVE THE DATA
!              ANALYST SOME FEEL FOR HOW DEPENDENT
!              THE HISTOGRAM SHAPE IS AS A FUNCTION
!              OF THE CLASS WIDTH AND NUMBER OF CLASSES.
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS.
!                      N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--1 PAGE OF AUTOMATIC PRINTOUT
!             CONSISTING OF 2 HALF-PAGE HISTOGRAMS
!             (WITH CLASS WIDTHS = 0.1 AND 0.2 SAMPLE
!             STANDARD DEVIATIONS, RESPECTIVELY)
!             OF THE DATA IN THE INPUT VECTOR X.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGE 4.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--DECEMBER  1972.
!     UPDATED         --JANUARY   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 blank , hyphen , alphai , alphax
      CHARACTER*4 IGRaph
!
      DIMENSION X(1)
      DIMENSION ixlabl(21)
      COMMON /BLOCK1/ IGRaph(55,130)
!CCCC COMMON IGRAPH(22,123)
      DIMENSION icount(121) , icoun2(121)
      DIMENSION tlable(13) , itlabl(13)
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE HIST   SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** FATAL ERROR--         THE SECOND INPUT ARGUMENT TO THE HIST&
     &   SUBROUTINE HAS THE VALUE 1 *****')
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) TO T&
     &HE HIST   SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      numhis = 2
         an = N
!
!     FIND THE MINIMUM AND THE MAXIMUM
         xmin = X(1)
         xmax = X(1)
         DO i = 1 , N
            IF ( X(i)<xmin ) xmin = X(i)
            IF ( X(i)>xmax ) xmax = X(i)
         ENDDO
!
!     COMPUTE THE SAMPLE MEAN AND SAMPLE STANDARD DEVIATION
!
         sum = 0.0
         DO i = 1 , N
            sum = sum + X(i)
         ENDDO
         xbar = sum/an
         sum = 0.0
         DO i = 1 , N
            sum = sum + (X(i)-xbar)**2
         ENDDO
         s = SQRT(sum/(an-1.0))
!
!     FORM THE BASIC FREQUENCY TABLE (ICOUNT) WHICH CORRESPONDS TO A HISTOGRAM
!     WITH 121 CLASSES AND A CLASS WIDTH OF ONE TENTH A SAMPLE STANDARD
!     DEVIATION.
!
         DO i = 1 , 121
            icount(i) = 0
         ENDDO
!
         numout = 0
         DO i = 1 , N
            z = (X(i)-xbar)/s
            mt = 10.0*(z+6.0) + 2.5
            IF ( mt<2 .OR. mt>122 ) numout = numout + 1
            IF ( mt>=2 .AND. mt<=122 ) icount(mt) = icount(mt) + 1
         ENDDO
!
!     LOOP THROUGH NUMHIS (= 2) HISTOGRAMS
!     NOTE THAT NUMHIS WAS PREVIOUSLY SET TO 6 (BEFORE JANUARY 1975)
!
         DO ihist = 1 , numhis
!
!     ZERO OUT THE MINI-GRAPH
!
            DO i = 1 , 22
               DO j = 1 , 123
                  IGRaph(i,j) = blank
               ENDDO
            ENDDO
!
!     PRODUCE THE HORIZONTAL AXES
!
            DO j = 2 , 122
               IGRaph(1,j) = hyphen
               IGRaph(22,j) = hyphen
            ENDDO
            DO j = 2 , 122 , 10
               IGRaph(1,j) = alphai
               IGRaph(22,j) = alphai
            ENDDO
!
!     PRODUCE THE VERTICAL AXES
!
            DO i = 2 , 21
               IGRaph(i,1) = alphai
               IGRaph(i,123) = alphai
            ENDDO
            DO i = 2 , 21 , 5
               IGRaph(i,1) = hyphen
               IGRaph(i,123) = hyphen
            ENDDO
            inc = ihist
            IF ( ihist==4 ) inc = 5
            IF ( ihist==5 ) inc = 10
            IF ( ihist==6 ) inc = 20
!
!     FORM THE FREQUENCY TABLE FOR THIS PARTICULAR HISTOGRAM
!
            icoun2(1) = icount(1)
            DO i = 2 , 121 , inc
               jmax = i + inc - 1
               jsum = 0
               DO j = i , jmax
                  jsum = jsum + icount(j)
               ENDDO
               DO j = i , jmax
                  icoun2(j) = jsum
               ENDDO
            ENDDO
!
!     DETERMINE THE MAXIMUM FREQUENCY
!
            maxfre = icoun2(1)
            DO i = 1 , 121
               IF ( icoun2(i)>maxfre ) maxfre = icoun2(i)
            ENDDO
!
!     DETERMINE THE PLOT POSITIONS
!
            amaxfr = maxfre
            height = 20.0
            DO j = 1 , 121
               jp1 = j + 1
               IF ( maxfre<=20 ) mx = icoun2(j)
               IF ( maxfre>20 ) THEN
                  acount = icoun2(j)
                  prop = acount/amaxfr
                  mx = prop*height + 0.999
               ENDIF
               IF ( mx/=0 ) THEN
                  DO i = 1 , mx
                     irev = 22 - i
                     IGRaph(irev,jp1) = alphax
                  ENDDO
               ENDIF
               IF ( icoun2(j)>=1 ) IGRaph(21,jp1) = alphax
            ENDDO
!
!     DETERMINE THE X VALUES TO BE LISTED ON THE LEFT LEFT VERTICAL AXIS
!
            IF ( maxfre>=21 ) THEN
               DO i = 1 , 20
                  irev = 22 - i
                  ai = i
                  prop = ai/20.0
                  ixlabl(irev) = prop*amaxfr + 0.5
               ENDDO
            ELSE
               DO i = 1 , 20
                  irev = 22 - i
                  ixlabl(irev) = i
               ENDDO
            ENDIF
!
!     WRITE EVERYTHING OUT
!
            ievodd = ihist - 2*(ihist/2)
            IF ( ievodd==0 ) THEN
               WRITE (ipr,99005)
99005          FORMAT (' ')
            ELSE
               WRITE (ipr,99006)
99006          FORMAT ('1')
            ENDIF
            WRITE (ipr,99013) (IGRaph(1,j),j=1,123)
            DO i = 2 , 21
               WRITE (ipr,99007) ixlabl(i) , (IGRaph(i,j),j=1,123)
99007          FORMAT (' ',I5,1X,123A1)
            ENDDO
            WRITE (ipr,99013) (IGRaph(22,j),j=1,123)
            numcla = (120/inc) + 1
            tinc = inc
            cwidsd = tinc*0.1
            cwidth = cwidsd*s
            tlable(7) = xbar
            itlabl(7) = 0
            DO i = 1 , 6
               irev = 13 - i + 1
               ai = i
               tlable(i) = xbar - (7.0-ai)*s
               tlable(irev) = xbar + (7.0-ai)*s
               itlabl(i) = i - 7
               itlabl(irev) = 7 - i
            ENDDO
            WRITE (ipr,99008) (tlable(i),i=1,13)
99008       FORMAT (' ',1X,12F10.4,F9.4)
            WRITE (ipr,99009) (itlabl(i),i=1,13)
99009       FORMAT (' ',13(1X,I7,2X))
            WRITE (ipr,99010) numout
99010       FORMAT (' ',I5,                                             &
     &' OBSERVATIONS WERE IN EXCESS OF 6 SAMPLE STANDARD DEVIATIONS ABOU&
     &T THE SAMPLE MEAN AND SO WERE NOT PLOTTED')
            WRITE (ipr,99011) numcla , cwidth , cwidsd
99011       FORMAT (' ','HISTOGRAM      THE NUMBER OF CLASSES IS ',I6,  &
     &              8X,'THE CLASS WIDTH IS ',E15.8,' = ',F7.1,          &
     &              ' STANDARD DEVIATIONS')
            WRITE (ipr,99012) N
99012       FORMAT (' ','THE SAMPLE SIZE N = ',I7)
         ENDDO
      ENDIF
99013 FORMAT (' ',6X,123A1)
      END SUBROUTINE HIST
!*==invxwx.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE INVXWX(N,K)
      IMPLICIT NONE
!*--INVXWX10396
!*** Start of declarations inserted by SPAG
      REAL anegri , D , dotpro , DUM1 , DUM2 , dum3 , Q , R , ri , WS
      INTEGER i , ii , im1 , ip1 , IPIvot , irarg , irarg1 , irarg2 ,   &
     &        irarg3 , j , jj , K , l , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT INVXWX
      EXTERNAL DOT
!     PURPOSE--THIS SUBROUTINE COMPUTES THE INVERSE OF X'WX
!     WHICH IS DONE BY COMPUTING THE INVERSE OF R'R (WHERE
!     R HAS JUST RECENTLY BEEN MODIFIED BEFORE CALLING THIS
!     SUBROUTINE.  THE INPUT R = THE SQUARE ROOT OF
!     THE DIAGONAL MATRIX D TIMES THE OLD MATRIX R.
!     THE INVERSE OF X'WX WILL BE IDENTICAL
!     (EXCEPT FOR THE ABSENCE OF S**2 = THE RESIDUAL
!     VARIANCE) TO THE COVARIANCE MATRIX OF THE COEFFICIENTS.
!     THE ONLY REASON THIS SUBROUTINE EXISTS IS FOR THE
!     CALCULATION OF SUCH COVARIANCES.
!     UNPIVOTING HAS ALSO BEEN DONE HEREIN SO AS TO UNDO
!     THE PIVOTING DONE IN THE DECOMPOSITION SUBROUTINE (DECOMP).
!     THE MATRIX C USED HEREIN IS AN INTERMEDIATE RESULT MATRIX.
!     X--NOT USED
!     Q--NOT USED
!     R--USED AND CHANGED
!     D--NOT USED
!     IPIVOT--USED
!     INVERSION ALGORITHM USED--CHOLESKI DECOMPOSITION
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION Q(10000) , R(2500) , D(50) , IPIvot(50)
      COMMON /BLOCK2/ WS(15000)
      COMMON /BLOCK3/ DUM1(3000) , DUM2(3000)
      EQUIVALENCE (Q(1),WS(1))
      EQUIVALENCE (R(1),WS(10001))
      EQUIVALENCE (D(1),WS(12501))
      EQUIVALENCE (IPIvot(1),WS(12551))
      DIMENSION dum3(200)
!
!-----START POINT-----------------------------------------------------
!
      DO i = 1 , K
         im1 = i - 1
         IF ( im1>=1 ) THEN
            DO j = 1 , im1
               irarg = (i-1)*K + j
               R(irarg) = 0.0
            ENDDO
         ENDIF
      ENDDO
      DO jj = 1 , K
         j = K + 1 - jj
         DO ii = 1 , j
            i = j + 1 - ii
            ip1 = i + 1
            IF ( ip1<=K ) THEN
               DO l = ip1 , K
                  irarg1 = (i-1)*K + l
                  irarg2 = (j-1)*K + l
                  irarg3 = (l-1)*K + j
                  DUM1(l) = R(irarg1)
                  IF ( l<j ) DUM2(l) = R(irarg2)
                  IF ( l==j ) DUM2(l) = dum3(l)
                  IF ( l>j ) DUM2(l) = R(irarg3)
               ENDDO
            ENDIF
            ri = 0.0
            irarg = (i-1)*K + i
            IF ( i==j ) ri = 1.0/R(irarg)
            anegri = -ri
!
            CALL DOT(DUM1,DUM2,ip1,K,anegri,dotpro)
!
            irarg = (i-1)*K + i
            dotpro = -dotpro/R(irarg)
            IF ( i==j ) dum3(i) = dotpro
            irarg = (j-1)*K + i
            IF ( i<j ) R(irarg) = dotpro
         ENDDO
      ENDDO
      DO i = 1 , K
         irarg = (i-1)*K + i
         R(irarg) = dum3(i)
      ENDDO
!
!     MATRIX C NOW EQUALS THE INVERSE OF R'R.
!     NOW 'UNPIVOT' ON C AND PUT THE RESULTS BACK INTO R.
!
      DO i = 1 , K
         ii = IPIvot(i)
         DO j = 1 , i
            jj = IPIvot(j)
            irarg1 = (ii-1)*K + jj
            irarg2 = (i-1)*K + j
            irarg3 = (jj-1)*K + ii
            IF ( ii<jj ) R(irarg1) = R(irarg2)
            IF ( ii==jj ) dum3(ii) = R(irarg2)
            IF ( ii>jj ) R(irarg3) = R(irarg2)
         ENDDO
      ENDDO
      DO i = 1 , K
         irarg = (i-1)*K + i
         R(irarg) = dum3(i)
      ENDDO
      END SUBROUTINE INVXWX
!*==lamcdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LAMCDF(X,Alamba,Cdf)
      IMPLICIT NONE
!*--LAMCDF10507
!*** Start of declarations inserted by SPAG
      REAL Alamba , Cdf , pdel , plower , pmax , pmid , pmin , pupper , &
     &     X , xcalc , xmax , xmin
      INTEGER icount , ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LAMCDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR THE (TUKEY) LAMBDA DISTRIBUTION
!              WITH TAIL LENGTH PARAMETER VALUE = ALAMBA.
!              IN GENERAL, THE PROBABILITY DENSITY FUNCTION
!              FOR THIS DISTRIBUTION IS NOT SIMPLE.
!              THE PERCENT POINT FUNCTION FOR THIS DISTRIBUTION IS
!              G(P) = ((P**ALAMBA)-((1-P)**ALAMBA))/ALAMBA
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!                     --ALAMBA = THE SINGLE PRECISION VALUE OF LAMBDA
!                                (THE TAIL LENGTH PARAMETER).
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF FOR THE TUKEY LAMBDA DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER = ALAMBA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--FOR ALAMBA NON-POSITIVE, NO RESTRICTIONS ON X.
!                 --FOR ALAMBA POSITIVE, X SHOULD BE BETWEEN (-1/ALAMBA)
!                   AND (+1/ALAMBA), INCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--HASTINGS, MOSTELLER, TUKEY, AND WINDSOR,
!                 'LOW MOMENTS FOR SMALL SAMPLES:  A COMPARATIVE
!                 STUDY OF ORDER STATISTICS', ANNALS OF
!                 MATHEMATICAL STATISTICS, 18, 1947,
!                 PAGES 413-426.
!               --FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 42-44, 53-58.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --MAY       1974.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( Alamba>0.0 ) THEN
         xmax = 1.0/Alamba
         xmin = -xmax
         IF ( X<xmin .OR. X>xmax ) THEN
            WRITE (ipr,99001)
99001       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST INPUT ARGUMENT TO THE LAMCD&
     &F SUBROUTINE IS OUTSIDE THE USUAL +-(1/ALAMBA) INTERVAL *****')
            WRITE (ipr,99002) X
99002       FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,    &
     &              ' *****')
            IF ( X<xmin ) Cdf = 0.0
            IF ( X>xmax ) Cdf = 1.0
            RETURN
         ENDIF
      ENDIF
!
!-----START POINT-----------------------------------------------------
!
      IF ( Alamba>0.0 ) THEN
!
         xmax = 1.0/Alamba
         xmin = -xmax
         IF ( X<=xmin ) Cdf = 0.0
         IF ( X>=xmax ) Cdf = 1.0
         IF ( X<=xmin .OR. X>=xmax ) RETURN
      ENDIF
!
      IF ( -0.001>=Alamba .OR. Alamba>=0.001 ) THEN
!
         IF ( -0.001>=Alamba .OR. Alamba>=0.001 ) THEN
            pmin = 0.0
            pmid = 0.5
            pmax = 1.0
            plower = pmin
            pupper = pmax
            icount = 0
            DO
               xcalc = (pmid**Alamba-(1.0-pmid)**Alamba)/Alamba
               IF ( xcalc==X ) THEN
                  Cdf = pmid
                  GOTO 99999
               ELSE
                  IF ( xcalc>X ) THEN
                     pupper = pmid
                     pmid = (pmid+plower)/2.0
                  ELSE
                     plower = pmid
                     pmid = (pmid+pupper)/2.0
                  ENDIF
                  pdel = ABS(pmid-plower)
                  icount = icount + 1
                  IF ( pdel<0.000001 .OR. icount>30 ) THEN
                     Cdf = pmid
                     GOTO 99999
                  ENDIF
               ENDIF
            ENDDO
         ENDIF
      ENDIF
      IF ( X>=0.0 ) THEN
         Cdf = 1.0/(1.0+EXP(-X))
         RETURN
      ELSE
         Cdf = EXP(X)/(1.0+EXP(X))
         RETURN
      ENDIF
!
99999 END SUBROUTINE LAMCDF
!*==lampdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LAMPDF(X,Alamba,Pdf)
      IMPLICIT NONE
!*--LAMPDF10638
!*** Start of declarations inserted by SPAG
      REAL Alamba , cdf , Pdf , sf , X , xmax , xmin
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LAMPDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PROBABILITY DENSITY
!              FUNCTION VALUE FOR THE (TUKEY) LAMBDA DISTRIBUTION
!              WITH TAIL LENGTH PARAMETER VALUE = ALAMBA.
!              IN GENERAL, THE PROBABILITY DENSITY FUNCTION
!              FOR THIS DISTRIBUTION IS NOT SIMPLE.
!              THE PERCENT POINT FUNCTION FOR THIS DISTRIBUTION IS
!              G(P) = ((P**ALAMBA)-((1-P)**ALAMBA))/ALAMBA
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE PROBABILITY DENSITY
!                                FUNCTION IS TO BE EVALUATED.
!                     --ALAMBA = THE SINGLE PRECISION VALUE OF LAMBDA
!                                (THE TAIL LENGTH PARAMETER).
!     OUTPUT ARGUMENTS--PDF    = THE SINGLE PRECISION PROBABILITY
!                                DENSITY FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PROBABILITY DENSITY
!             FUNCTION VALUE PDF FOR THE TUKEY LAMBDA DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER = ALAMBA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--FOR ALAMBA NON-POSITIVE, NO RESTRICTIONS ON X.
!                 --FOR ALAMBA POSITIVE, X SHOULD BE BETWEEN (-1/ALAMBA)
!                   AND (+1/ALAMBA), INCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--LAMCDF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--HASTINGS, MOSTELLER, TUKEY, AND WINDSOR,
!                 'LOW MOMENTS FOR SMALL SAMPLES:  A COMPARATIVE
!                 STUDY OF ORDER STATISTICS', ANNALS OF
!                 MATHEMATICAL STATISTICS, 18, 1947,
!                 PAGES 413-426.
!               --FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 42-44, 53-58.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --AUGUST    1974.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( Alamba>0.0 ) THEN
         xmax = 1.0/Alamba
         xmin = -xmax
         IF ( X<xmin .OR. X>xmax ) THEN
            WRITE (ipr,99001)
99001       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST INPUT ARGUMENT TO THE LAMPD&
     &F SUBROUTINE IS OUTSIDE THE USUAL +-(1/ALAMBA) INTERVAL *****')
            WRITE (ipr,99002) X
99002       FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,    &
     &              ' *****')
            IF ( X<xmin ) Pdf = 0.0
            IF ( X>xmax ) Pdf = 1.0
            RETURN
         ENDIF
      ENDIF
!
!-----START POINT-----------------------------------------------------
!
      IF ( Alamba>0.0 ) THEN
         xmax = 1.0/Alamba
         xmin = -xmax
         IF ( X<=xmin .OR. X>=xmax ) THEN
            IF ( X<xmin .OR. X>xmax ) Pdf = 0.0
            IF ( X==xmin .AND. Alamba<1.0 ) Pdf = 0.0
            IF ( X==xmax .AND. Alamba<1.0 ) Pdf = 0.0
            IF ( X==xmin .AND. Alamba==1.0 ) Pdf = 0.5
            IF ( X==xmax .AND. Alamba==1.0 ) Pdf = 0.5
            IF ( X==xmin .AND. Alamba>1.0 ) Pdf = 1.0
            IF ( X==xmax .AND. Alamba>1.0 ) Pdf = 1.0
            RETURN
         ENDIF
      ENDIF
!
      CALL LAMCDF(X,Alamba,cdf)
      sf = cdf**(Alamba-1.0) + (1.0-cdf)**(Alamba-1.0)
      Pdf = 1.0/sf
!
      END SUBROUTINE LAMPDF
!*==lamplt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LAMPLT(X,N,Alamba)
      IMPLICIT NONE
!*--LAMPLT10738
!*** Start of declarations inserted by SPAG
      REAL Alamba , an , cc , hold , pp0025 , pp025 , pp975 , pp9975 ,  &
     &     q , sum1 , sum2 , sum3 , tau , W , wbar , WS , X , Y , ybar ,&
     &     yint
      REAL yslope
      INTEGER i , ipr , iupper , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LAMPLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES A (TUKEY) LAMBDA DISTRIBUTION
!              PROBABILITY PLOT
!              (WITH TAIL LENGTH PARAMETER VALUE = ALAMBA).
!              IN GENERAL, THE PROBABILITY DENSITY FUNCTION
!              FOR THIS DISTRIBUTION IS NOT SIMPLE.
!              THE PERCENT POINT FUNCTION FOR THIS DISTRIBUTION IS
!              G(P) = ((P**ALAMBA)-((1-P)**ALAMBA)) / ALAMBA
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE LAMBDA PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE LAMBDA DISTRIBUTION
!              WITH TAIL LENGTH PARAMETER VALUE = ALAMBA.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --ALAMBA = THE SINGLE PRECISION VALUE OF LAMBDA
!                                (THE TAIL LENGTH PARAMETER).
!     OUTPUT--A ONE-PAGE LAMBDA PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY, 1969), PAGES 21-44, 229-231,
!                 PAGES 53-58.
!               --HASTINGS, MOSTELLER, TUKEY, AND WINDSOR,
!                 'LOW MOMENTS FOR SMALL SAMPLES:  A COMPARATIVE
!                 STUDY OF ORDER STATISTICS', ANNALS OF
!                 MATHEMATICAL STATISTICS, 18, 1947,
!                 PAGES 413-426.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE LAMPLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE LAMP&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE LAMPLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     COMPUTE LAMBDA DISTRIBUTION ORDER STATISTIC MEDIANS
!
         DO i = 1 , N
            q = W(i)
            IF ( -0.001<Alamba .AND. Alamba<0.001 ) W(i)                &
     &           = ALOG(q/(1.0-q))
            IF ( -0.001>=Alamba .OR. Alamba>=0.001 ) W(i)               &
     &           = (q**Alamba-(1.0-q)**Alamba)/Alamba
         ENDDO
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     COMPUTE THE TAIL LENGTH MEASURE OF THE DISTRIBUTION.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         IF ( -0.001<Alamba .AND. Alamba<0.001 ) tau = 1.63473745
         IF ( -0.001>=Alamba .OR. Alamba>=0.001 ) THEN
            q = .9975
            pp9975 = (q**Alamba-(1.0-q)**Alamba)/Alamba
            q = .0025
            pp0025 = (q**Alamba-(1.0-q)**Alamba)/Alamba
            q = .975
            pp975 = (q**Alamba-(1.0-q)**Alamba)/Alamba
            q = .025
            pp025 = (q**Alamba-(1.0-q)**Alamba)/Alamba
            tau = (pp9975-pp0025)/(pp975-pp025)
         ENDIF
         WRITE (ipr,99005) Alamba , tau , N
!
99005    FORMAT (' ','LAMBDA PROBABILITY PLOT WITH LAMBDA = ',E17.10,1X,&
     &           '(TAU = ',E15.8,')',24X,'THE SAMPLE SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
         ENDDO
         ybar = sum1/an
         wbar = 0.0
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + W(i)*Y(i)
            sum3 = sum3 + W(i)*W(i)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99006) cc , yint , yslope
99006    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
!
      END SUBROUTINE LAMPLT
!*==lamppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LAMPPF(P,Alamba,Ppf)
      IMPLICIT NONE
!*--LAMPPF10925
!*** Start of declarations inserted by SPAG
      REAL Alamba , P , Ppf
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LAMPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE (TUKEY) LAMBDA DISTRIBUTION
!              WITH TAIL LENGTH PARAMETER VALUE = ALAMBA.
!              IN GENERAL, THE PROBABILITY DENSITY FUNCTION
!              FOR THIS DISTRIBUTION IS NOT SIMPLE.
!              THE PERCENT POINT FUNCTION FOR THIS DISTRIBUTION IS
!              G(P) = ((P**ALAMBA)-((1-P)**ALAMBA))/ALAMBA
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!                     --ALAMBA = THE SINGLE PRECISION VALUE OF LAMBDA
!                                (THE TAIL LENGTH PARAMETER).
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT
!             FUNCTION VALUE PPF FOR THE TUKEY LAMBDA DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER = ALAMBA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--IF ALAMBA IS POSITIVE,
!                   THEN P SHOULD BE BETWEEN 0.0 AND 1.0, INCLUSIVELY.
!                   IF ALAMBA IS NON-POSITIVE,
!                   THEN P SHOULD BE BETWEEN 0.0 AND 1.0, EXCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231,
!                 PAGES 53-58.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --HASTINGS, MOSTELLER, TUKEY, AND WINDSOR,
!                 'LOW MOMENTS FOR SMALL SAMPLES:  A COMPARATIVE
!                 STUDY OF ORDER STATISTICS', ANNALS OF
!                 MATHEMATICAL STATISTICS, 18, 1947,
!                 PAGES 413-426.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( Alamba>0.0 .OR. P>0.0 ) THEN
         IF ( Alamba>0.0 .OR. P<1.0 ) THEN
            IF ( Alamba<=0.0 .OR. P>=0.0 ) THEN
               IF ( Alamba<=0.0 .OR. P<=1.0 ) THEN
!
!-----START POINT-----------------------------------------------------
!
                  IF ( -0.001<Alamba .AND. Alamba<0.001 ) THEN
                     Ppf = ALOG(P/(1.0-P))
                     RETURN
                  ELSE
!
                     Ppf = (P**Alamba-(1.0-P)**Alamba)/Alamba
                     GOTO 99999
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
      WRITE (ipr,99001)
99001 FORMAT (' ',                                                      &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE LAMPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
      WRITE (ipr,99002) P
99002 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
      RETURN
!
99999 END SUBROUTINE LAMPPF
!*==lamran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LAMRAN(N,Alamba,Iseed,X)
      IMPLICIT NONE
!*--LAMRAN11021
!*** Start of declarations inserted by SPAG
      REAL alamb2 , Alamba , q , X
      INTEGER i , ipr , Iseed , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LAMRAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE (TUKEY) LAMBDA DISTRIBUTION
!              WITH TAIL LENGTH PARAMETER VALUE = ALAMBA.
!              IN GENERAL, THE PROBABILITY DENSITY FUNCTION
!              FOR THIS DISTRIBUTION IS NOT SIMPLE.
!              THE PERCENT POINT FUNCTION FOR THIS DISTRIBUTION IS
!              G(P) = ((P**ALAMBA)-((1-P)**ALAMBA))/ALAMBA
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!                     --ALAMBA = THE SINGLE PRECISION VALUE OF LAMBDA
!                                (THE TAIL LENGTH PARAMETER).
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE (TUKEY) LAMBDA DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER VALUE = ALAMBA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     REFERENCES--TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 14-15.
!               --HAMMERSLEY AND HANDSCOMB, MONTE CARLO METHODS,
!                 1964, PAGE 36.
!               --FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 53-58.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82.6
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
      ipr = 6
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      alamb2 = Alamba
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE LAMRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
!
!     GENERATE N UNIFORM (0,1) RANDOM NUMBERS;
!
         CALL UNIRAN(N,Iseed,X)
!
!     GENERATE N LAMBDA DISTRIBUTION RANDOM NUMBERS
!     USING THE PERCENT POINT FUNCTION TRANSFORMATION METHOD.
!
         DO i = 1 , N
            q = X(i)
            IF ( -0.001<alamb2 .AND. alamb2<0.001 ) X(i)                &
     &           = ALOG(q/(1.0-q))
            IF ( -0.001>=alamb2 .OR. alamb2>=0.001 ) X(i)               &
     &           = (q**alamb2-(1.0-q)**alamb2)/alamb2
         ENDDO
      ENDIF
!
      END SUBROUTINE LAMRAN
!*==lamsf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LAMSF(P,Alamba,Sf)
      IMPLICIT NONE
!*--LAMSF11137
!*** Start of declarations inserted by SPAG
      REAL Alamba , P , Sf
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LAMSF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE SPARSITY
!              FUNCTION VALUE FOR THE (TUKEY) LAMBDA DISTRIBUTION
!              WITH TAIL LENGTH PARAMETER VALUE = ALAMBA.
!              IN GENERAL, THE PROBABILITY DENSITY FUNCTION
!              FOR THIS DISTRIBUTION IS NOT SIMPLE.
!              THE PERCENT POINT FUNCTION FOR THIS DISTRIBUTION IS
!              G(P) = ((P**ALAMBA)-((1-P)**ALAMBA))/ALAMBA
!              NOTE THAT THE SPARSITY FUNCTION OF A DISTRIBUTION
!              IS THE DERIVATIVE OF THE PERCENT POINT FUNCTION,
!              AND ALSO IS THE RECIPROCAL OF THE PROBABILITY
!              DENSITY FUNCTION (BUT IN UNITS OF P RATHER THAN X).
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                AT WHICH THE SPARSITY
!                                FUNCTION IS TO BE EVALUATED.
!                     --ALAMBA = THE SINGLE PRECISION VALUE OF LAMBDA
!                                (THE TAIL LENGTH PARAMETER).
!     OUTPUT ARGUMENTS--SF     = THE SINGLE PRECISION
!                                SPARSITY FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION SPARSITY
!             FUNCTION VALUE SF FOR THE TUKEY LAMBDA DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER = ALAMBA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--IF ALAMBA IS POSITIVE,
!                   THEN P SHOULD BE BETWEEN 0.0 AND 1.0, INCLUSIVELY.
!                   IF ALAMBA IS NON-POSITIVE,
!                   THEN P SHOULD BE BETWEEN 0.0 AND 1.0, EXCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231,
!                 PAGES 53-58.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --HASTINGS, MOSTELLER, TUKEY, AND WINDSOR,
!                 'LOW MOMENTS FOR SMALL SAMPLES:  A COMPARATIVE
!                 STUDY OF ORDER STATISTICS', ANNALS OF
!                 MATHEMATICAL STATISTICS, 18, 1947,
!                 PAGES 413-426.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( Alamba>0.0 .OR. P>0.0 ) THEN
         IF ( Alamba>0.0 .OR. P<1.0 ) THEN
            IF ( Alamba<=0.0 .OR. P>=0.0 ) THEN
               IF ( Alamba<=0.0 .OR. P<=1.0 ) THEN
!
!-----START POINT-----------------------------------------------------
!
                  Sf = P**(Alamba-1.0) + (1.0-P)**(Alamba-1.0)
                  GOTO 99999
               ENDIF
            ENDIF
         ENDIF
      ENDIF
      WRITE (ipr,99001)
99001 FORMAT (' ',                                                      &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE LAMSF  SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
      WRITE (ipr,99002) P
99002 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
      RETURN
!
99999 END SUBROUTINE LAMSF
!*==lgncdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LGNCDF(X,Cdf)
      IMPLICIT NONE
!*--LGNCDF11228
!*** Start of declarations inserted by SPAG
      REAL arg , Cdf , X
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LGNCDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR THE LOGNORMAL
!              DISTRIBUTION.
!              THE LOGNORMAL DISTRIBUTION USED
!              HEREIN HAS MEAN = SQRT(E) = 1.64872127
!              AND STANDARD DEVIATION = SQRT(E*(E-1)) = 2.16119742.
!              THIS DISTRIBUTION IS DEFINED FOR ALL POSITIVE X
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/(X*SQRT(2*PI))) * EXP(-ALOG(X)*ALOG(X)/2)
!              THE LOGNORMAL DISTRIBUTION USED HEREIN
!              IS THE DISTRIBUTION OF THE VARIATE X = EXP(Z) WHERE
!              THE VARIATE Z IS NORMALLY DISTRIBUTED
!              WITH MEAN = 0 AND STANDARD DEVIATION = 1.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE
!                                AT WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!                                X SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF FOR THE LOGNORMAL
!             DISTRIBUTION WITH MEAN = SQRT(E) = 1.64872127
!             AND STANDARD DEVIATION = SQRT(E*(E-1)) = 2.16119742.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--X SHOULD BE POSITIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NORCDF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 112-136.
!               --CRAMER, MATHEMATICAL METHODS OF STATISTICS,
!                 1946, PAGES 219-220.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( X<=0.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE LGNC&
     &DF SUBROUTINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) X
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         Cdf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         arg = ALOG(X)
         CALL NORCDF(arg,Cdf)
      ENDIF
!
      END SUBROUTINE LGNCDF
!*==lgnplt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LGNPLT(X,N)
      IMPLICIT NONE
!*--LGNPLT11304
!*** Start of declarations inserted by SPAG
      REAL an , cc , hold , q , sum1 , sum2 , sum3 , tau , W , wbar ,   &
     &     WS , X , Y , ybar , yint , yslope
      INTEGER i , ipr , iupper , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LGNPLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES A LOGNORMAL
!              PROBABILITY PLOT.
!              THE PROTOTYPE LOGNORMAL DISTRIBUTION USED HEREIN
!              HAS MEAN = SQRT(E) = 1.64872127
!              AND STANDARD DEVIATION = SQRT(E*(E-1)) = 2.16119742.
!              THIS DISTRIBUTION IS DEFINED FOR ALL POSITIVE X
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/(X*SQRT(2*PI))) * EXP(-ALOG(X)*ALOG(X)/2)
!              THE PROTOTYPE LOGNORMAL DISTRIBUTION USED HEREIN
!              IS THE DISTRIBUTION OF THE VARIATE X = EXP(Z) WHERE
!              THE VARIATE Z IS NORMALLY DISTRIBUTED
!              WITH MEAN = 0 AND STANDARD DEVIATION = 1.
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE LOGNORMAL PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE LOGNORMAL DISTRIBUTION.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!     OUTPUT--A ONE-PAGE LOGNORMAL PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, NORPPF, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 112-136.
!               --CRAMER, MATHEMATICAL METHODS OF STATISTICS,
!                 1946, PAGES 219-220.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
!
      DATA tau/2.37134890/
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE LGNPLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE LGNP&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE LGNPLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     COMPUTE LOGNORMAL ORDER STATISTIC MEDIANS
!
         DO i = 1 , N
            q = W(i)
            CALL NORPPF(q,q)
            W(i) = EXP(q)
         ENDDO
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         WRITE (ipr,99005) tau , N
!
99005    FORMAT (' ','LOGNORMAL PROBABILITY PLOT (TAU = ',E15.8,')',53X,&
     &           'THE SAMPLE SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         sum2 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
            sum2 = sum2 + W(i)
         ENDDO
         ybar = sum1/an
         wbar = sum2/an
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + (Y(i)-ybar)*(W(i)-wbar)
            sum3 = sum3 + (W(i)-wbar)*(W(i)-wbar)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99006) cc , yint , yslope
99006    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
!
      END SUBROUTINE LGNPLT
!*==lgnppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LGNPPF(P,Ppf)
      IMPLICIT NONE
!*--LGNPPF11474
!*** Start of declarations inserted by SPAG
      INTEGER ipr
      REAL P , Ppf
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LGNPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE LOGNORMAL
!              DISTRIBUTION.
!              THE LOGNORMAL DISTRIBUTION USED
!              HEREIN HAS MEAN = SQRT(E) = 1.64872127
!              AND STANDARD DEVIATION = SQRT(E*(E-1)) = 2.16119742.
!              THIS DISTRIBUTION IS DEFINED FOR ALL POSITIVE X
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/(X*SQRT(2*PI))) * EXP(-ALOG(X)*ALOG(X)/2)
!              THE LOGNORMAL DISTRIBUTION USED HEREIN
!              IS THE DISTRIBUTION OF THE VARIATE X = EXP(Z) WHERE
!              THE VARIATE Z IS NORMALLY DISTRIBUTED
!              WITH MEAN = 0 AND STANDARD DEVIATION = 1.
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 (EXCLUSIVELY)
!                                AND 1.0 (EXCLUSIVELY))
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT FUNCTION .
!             VALUE PPF FOR THE LOGNORMAL DISTRIBUTION
!             WITH MEAN = SQRT(E) = 1.64872127
!             AND STANDARD DEVIATION = SQRT(E*(E-1)) = 2.16119742.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0 (EXCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NORPPF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 112-136.
!               --CRAMER, MATHEMATICAL METHODS OF STATISTICS,
!                 1946, PAGES 219-220.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE LGNPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         Ppf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         CALL NORPPF(P,Ppf)
         Ppf = EXP(Ppf)
      ENDIF
!
      END SUBROUTINE LGNPPF
!*==lgnran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LGNRAN(N,Iseed,X)
      IMPLICIT NONE
!*--LGNRAN11555
!*** Start of declarations inserted by SPAG
      REAL arg1 , arg2 , pi , sqrt1 , u1 , u2 , X , y , z1 , z2
      INTEGER i , ip1 , ipr , Iseed , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LGNRAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE LOGNORMAL DISTRIBUTION.
!              THE PROTOTYPE LOGNORMAL DISTRIBUTION USED
!              HEREIN HAS MEAN = SQRT(E) = 1.64872127
!              AND STANDARD DEVIATION = SQRT(E*(E-1)) = 2.16119742.
!              THIS DISTRIBUTION IS DEFINED FOR ALL POSITIVE X
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/(X*SQRT(2*PI))) * EXP(-ALOG(X)*ALOG(X)/2)
!              THE PROTOTYPE LOGNORMAL DISTRIBUTION USED HEREIN
!              IS THE DISTRIBUTION OF THE VARIATE X = EXP(Z) WHERE
!              THE VARIATE Z IS NORMALLY DISTRIBUTED
!              WITH MEAN = 0 AND STANDARD DEVIATION = 1.
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE LOGNORMAL DISTRIBUTION
!             WITH MEAN = SQRT(E) = 1.64872127
!             AND STANDARD DEVIATION = SQRT(E*(E-1)) = 2.16119742.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG, SQRT, SIN, COS, EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     REFERENCES--TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 14-15.
!               --HAMMERSLEY AND HANDSCOMB, MONTE CARLO METHODS,
!                 1964, PAGE 36.
!               --CRAMER, MATHEMATICAL METHODS OF STATISTICS,
!                 1946, PAGES 219-220.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 112-136.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGE 88.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82.6
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --JULY      1976.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
      DIMENSION y(2)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
      ipr = 6
!
!-----DATA STATEMENTS-------------------------------------------------
!
      DATA pi/3.14159265359/
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE LGNRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
!
!     GENERATE N UNIFORM (0,1) RANDOM NUMBERS;
!     THEN GENERATE 2 ADDITIONAL UNIFORM (0,1) RANDOM NUMBERS
!     (TO BE USED BELOW IN FORMING THE N-TH NORMAL
!     RANDOM NUMBER WHEN THE DESIRED SAMPLE SIZE N
!     HAPPENS TO BE ODD).
!
         CALL UNIRAN(N,Iseed,X)
         CALL UNIRAN(2,Iseed,y)
!
!     GENERATE N NORMAL RANDOM NUMBERS
!     USING THE BOX-MULLER METHOD.
!
         DO i = 1 , N , 2
            ip1 = i + 1
            u1 = X(i)
            IF ( i==N ) THEN
               u2 = y(2)
            ELSE
               u2 = X(ip1)
            ENDIF
            arg1 = -2.0*ALOG(u1)
            arg2 = 2.0*pi*u2
            sqrt1 = SQRT(arg1)
            z1 = sqrt1*COS(arg2)
            z2 = sqrt1*SIN(arg2)
            X(i) = z1
            IF ( i/=N ) X(ip1) = z2
         ENDDO
!
!     GENERATE N LOGNORMAL RANDOM NUMBERS
!     USING THE DEFINITION THAT
!     A LOGNORMAL VARIATE
!     EQUALS AN EXPONETIATED NORMAL VARIATE.
!
         DO i = 1 , N
            X(i) = EXP(X(i))
         ENDDO
      ENDIF
!
      END SUBROUTINE LGNRAN
!*==loc.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LOC(X,N)
      IMPLICIT NONE
!*--LOC11703
!*** Start of declarations inserted by SPAG
      REAL aiflag , an , hold , sum , WS , X , xmean , xmed , xmid ,    &
     &     xmidm , Y
      INTEGER i , iflag , imax , imaxm1 , imin , iminp1 , ipr , iupper ,&
     &        N , nmid , nmidp1
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LOC
!
!     PURPOSE--THIS SUBROUTINE COMPUTES 4 ESTIMATES OF THE
!              LOCATION (TYPICAL VALUE, MEASURE OF CENTRAL
!              TENDANCY) OF THE DATA IN THE INPUT VECTOR X.
!              THE 4 ESTIMATORS EMPLOYED ARE--
!              1) THE SAMPLE MIDRANGE;
!              2) THE SAMPLE MEAN;
!              3) THE SAMPLE MIDMEAN; AND
!              4) THE SAMPLE MEDIAN.
!              THE ABOVE 4 ESTIMATORS ARE NEAR-OPTIMAL
!              ESTIMATORS OF LOCATION
!              FOR SHORTER-TAILED SYMMETRIC DISTRIBUTIONS,
!              MODERATE-TAILED DISTRIBUTIONS,
!              MODERATE-LONG-TAILED DISTRIBUTIONS,
!              AND LONG-TAILED DISTRIBUTIONS,
!              RESPECTIVELY.
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS.
!                      N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--1/4 PAGE OF AUTOMATIC OUTPUT
!             CONSISTING OF THE FOLLOWING 4
!             ESTIMATES OF LOCATION
!             FOR THE DATA IN THE INPUT VECTOR X--
!             1) THE SAMPLE MIDRANGE;
!             2) THE SAMPLE MEAN;
!             3) THE SAMPLE MIDMEAN; AND
!             4) THE SAMPLE MEDIAN.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--DIXON AND MASSEY, PAGES 14, 70, AND 71
!               --CROW, JOURNAL OF THE AMERICAN STATISTICAL ASSOCIATION,
!                 PAGES 357 AND 387
!               --KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGE 8.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(15000)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
!
      ipr = 6
      iupper = 15000
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      xmid = 0.0
      xmean = 0.0
      xmidm = 0.0
      xmed = 0.0
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE LOC    SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE LOC &
     &   SUBROUTINE HAS THE VALUE 1 *****')
            xmid = X(1)
            xmean = X(1)
            xmidm = X(1)
            xmed = X(1)
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 20
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE LOC    SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
 20         an = N
!
!     SORT THE DATA,
!     THEN COMPUTE THE SAMPLE MIDRANGE.
!
            CALL SORT(X,N,Y)
            xmid = (Y(1)+Y(N))/2.0
!
!     COMPUTE THE SAMPLE MEAN
!
            sum = 0.0
            DO i = 1 , N
               sum = sum + Y(i)
            ENDDO
            xmean = sum/an
!
!     COMPUTE THE SAMPLE MIDMEAN
!
            iflag = N - (N/4)*4
            aiflag = iflag
            imin = N/4 + 1
            imax = N - imin + 1
            sum = 0.0
            sum = sum + Y(imin)*(4.0-aiflag)/4.0
            sum = sum + Y(imax)*(4.0-aiflag)/4.0
            iminp1 = imin + 1
            imaxm1 = imax - 1
            IF ( iminp1<=imaxm1 ) THEN
               DO i = iminp1 , imaxm1
                  sum = sum + Y(i)
               ENDDO
            ENDIF
            xmidm = sum/(an/2.0)
!
!     COMPUTE THE SAMPLE MEDIAN
!
            iflag = N - (N/2)*2
            nmid = N/2
            nmidp1 = nmid + 1
            IF ( iflag==0 ) xmed = (Y(nmid)+Y(nmidp1))/2.0
            IF ( iflag==1 ) xmed = Y(nmidp1)
         ENDIF
!
!     WRITE EVERYTHING OUT
!
         DO i = 1 , 5
            WRITE (ipr,99011)
         ENDDO
         WRITE (ipr,99005)
!
99005    FORMAT (' ',30X,'ESTIMATES OF THE LOCATION PARAMETER')
         WRITE (ipr,99011)
         WRITE (ipr,99006) N
99006    FORMAT (' ',34X,'(THE SAMPLE SIZE N = ',I5,')')
         WRITE (ipr,99011)
         WRITE (ipr,99011)
         WRITE (ipr,99007) xmid
99007    FORMAT (' ','THE SAMPLE MIDRANGE IS                ',E15.8)
         WRITE (ipr,99008) xmean
99008    FORMAT (' ','THE SAMPLE MEAN IS                    ',E15.8)
         WRITE (ipr,99009) xmidm
99009    FORMAT (' ','THE SAMPLE 25 PERCENT TRIMMED MEAN IS ',E15.8)
         WRITE (ipr,99010) xmed
99010    FORMAT (' ','THE SAMPLE MEDIAN IS                  ',E15.8)
      ENDIF
99011 FORMAT (' ')
!
      END SUBROUTINE LOC
!*==logcdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LOGCDF(X,Cdf)
      IMPLICIT NONE
!*--LOGCDF11878
!*** Start of declarations inserted by SPAG
      REAL Cdf , X
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LOGCDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR THE LOGISTIC DISTRIBUTION
!              WITH MEAN = 0 AND STANDARD DEVIATION = PI/SQRT(3).
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = EXP(X)/(1+EXP(X)).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF.
!     PRINTING--NONE.
!     RESTRICTIONS--NONE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 1-21.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --MAY       1974.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS.
!     NO INPUT ARGUMENT ERRORS POSSIBLE
!     FOR THIS DISTRIBUTION.
!
!-----START POINT-----------------------------------------------------
!
      IF ( X>=0.0 ) THEN
         Cdf = 1.0/(1.0+EXP(-X))
         GOTO 99999
      ENDIF
      Cdf = EXP(X)/(1.0+EXP(X))
      RETURN
!
99999 END SUBROUTINE LOGCDF
!*==logpdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LOGPDF(X,Pdf)
      IMPLICIT NONE
!*--LOGPDF11938
!*** Start of declarations inserted by SPAG
      INTEGER ipr
      REAL Pdf , X
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LOGPDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PROBABILITY DENSITY
!              FUNCTION VALUE FOR THE LOGISTIC DISTRIBUTION
!              WITH MEAN = 0 AND STANDARD DEVIATION = PI/SQRT(3).
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = EXP(X)/(1+EXP(X)).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE PROBABILITY DENSITY
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--PDF    = THE SINGLE PRECISION PROBABILITY
!                                DENSITY FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PROBABILITY DENSITY
!             FUNCTION VALUE PDF.
!     PRINTING--NONE.
!     RESTRICTIONS--NONE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 1-21.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS.
!     NO INPUT ARGUMENT ERRORS POSSIBLE
!     FOR THIS DISTRIBUTION.
!
!-----START POINT-----------------------------------------------------
!
      Pdf = EXP(X)/((1.0+EXP(X))**2)
!
      END SUBROUTINE LOGPDF
!*==logplt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LOGPLT(X,N)
      IMPLICIT NONE
!*--LOGPLT11992
!*** Start of declarations inserted by SPAG
      REAL an , cc , hold , sum1 , sum2 , sum3 , tau , W , wbar , WS ,  &
     &     X , Y , ybar , yint , yslope
      INTEGER i , ipr , iupper , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LOGPLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES A LOGISTIC
!              PROBABILITY PLOT.
!              THE PROTOTYPE LOGISTIC DISTRIBUTION USED HEREIN
!              HAS MEAN = 0 AND STANDARD DEVIATION = PI/SQRT(3).
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = EXP(X) / (1+EXP(X)).
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE LOGISTIC PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE LOGISTIC DISTRIBUTION.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!     OUTPUT--A ONE-PAGE LOGISTIC PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 1-21.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
!
      DATA tau/1.63473745/
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE LOGPLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE LOGP&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE LOGPLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     COMPUTE LOGISTIC ORDER STATISTIC MEDIANS
!
         DO i = 1 , N
            W(i) = ALOG(W(i)/(1.0-W(i)))
         ENDDO
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         WRITE (ipr,99005) tau , N
!
99005    FORMAT (' ','LOGISTIC PROBABILITY PLOT (TAU = ',E15.8,')',54X, &
     &           'THE SAMPLE SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
         ENDDO
         ybar = sum1/an
         wbar = 0.0
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + W(i)*Y(i)
            sum3 = sum3 + W(i)*W(i)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99006) cc , yint , yslope
99006    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
!
      END SUBROUTINE LOGPLT
!*==logppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LOGPPF(P,Ppf)
      IMPLICIT NONE
!*--LOGPPF12151
!*** Start of declarations inserted by SPAG
      INTEGER ipr
      REAL P , Ppf
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LOGPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE LOGISTIC DISTRIBUTION
!              WITH MEAN = 0 AND STANDARD DEVIATION = PI/SQRT(3).
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = EXP(X)/(1+EXP(X)).
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT
!             FUNCTION VALUE PPF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0 AND 1.0, EXCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 1-21.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE LOGPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
!CCCC CALL QCORR(P,Q)
!CCCC PPF=ALOG(P/Q)
         Ppf = ALOG(P/(1.0-P))
      ENDIF
!
      END SUBROUTINE LOGPPF
!*==logran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LOGRAN(N,Iseed,X)
      IMPLICIT NONE
!*--LOGRAN12227
!*** Start of declarations inserted by SPAG
      INTEGER i , ipr , Iseed , N
      REAL X
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LOGRAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE LOGISTIC DISTRIBUTION
!              WITH MEAN = 0 AND STANDARD DEVIATION = PI/SQRT(3).
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = EXP(X)/(1+EXP(X)).
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE LOGISTIC DISTRIBUTION
!             WITH MEAN = 0 AND STANDARD DEVIATION = PI/SQRT(3).
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     REFERENCES--TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 14-15.
!               --HAMMERSLEY AND HANDSCOMB, MONTE CARLO METHODS,
!                 1964, PAGE 36.
!               --FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGE 230.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 1-21.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82.6
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
      ipr = 6
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE LOGRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
!
!     GENERATE N UNIFORM (0,1) RANDOM NUMBERS;
!
         CALL UNIRAN(N,Iseed,X)
!
!     GENERATE N LOGISTIC RANDOM NUMBERS
!     USING THE PERCENT POINT FUNCTION TRANSFORMATION METHOD.
!
         DO i = 1 , N
            X(i) = ALOG(X(i)/(1.0-X(i)))
         ENDDO
      ENDIF
!
      END SUBROUTINE LOGRAN
!*==logsf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE LOGSF(P,Sf)
      IMPLICIT NONE
!*--LOGSF12337
!*** Start of declarations inserted by SPAG
      INTEGER ipr
      REAL P , Sf
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT LOGSF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE SPARSITY
!              FUNCTION VALUE FOR THE LOGISTIC DISTRIBUTION
!              WITH MEAN = 0 AND STANDARD DEVIATION = PI/SQRT(3).
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = EXP(X)/(1+EXP(X)).
!              NOTE THAT THE SPARSITY FUNCTION OF A DISTRIBUTION
!              IS THE DERIVATIVE OF THE PERCENT POINT FUNCTION,
!              AND ALSO IS THE RECIPROCAL OF THE PROBABILITY
!              DENSITY FUNCTION (BUT IN UNITS OF P RATHER THAN X).
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                AT WHICH THE SPARSITY
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--SF     = THE SINGLE PRECISION
!                                SPARSITY FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION SPARSITY
!             FUNCTION VALUE SF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0 AND 1.0, EXCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 1-21.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE LOGSF  SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         Sf = 1.0/(P-P*P)
      ENDIF
!
      END SUBROUTINE LOGSF
!*==max.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE MAX(X,N,Iwrite,Xmax)
      IMPLICIT NONE
!*--MAX12412
!*** Start of declarations inserted by SPAG
      REAL hold , X , Xmax
      INTEGER i , ipr , Iwrite , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT MAX
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE MAXIMUM
!              OF THE DATA IN THE INPUT VECTOR X.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE MAXIMUM
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE MAXIMUM
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XMAX   = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE MAXIMUM.
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE MAXIMUM.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--DAVID, ORDER STATISTICS, 1970, PAGE 7.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE MAX    SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE MAX &
     &   SUBROUTINE HAS THE VALUE 1 *****')
            Xmax = X(1)
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE MAX    SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            Xmax = X(1)
         ENDIF
         GOTO 100
!
!-----START POINT-----------------------------------------------------
!
 50      Xmax = X(1)
         DO i = 2 , N
            IF ( X(i)>Xmax ) Xmax = X(i)
         ENDDO
      ENDIF
!
 100  IF ( Iwrite==0 ) RETURN
      WRITE (ipr,99005)
99005 FORMAT (' ')
      WRITE (ipr,99006) N , Xmax
99006 FORMAT (' ','THE MAXIMUM OF THE SET OF ',I6,' OBSERVATIONS IS ',  &
     &        E15.8)
      END SUBROUTINE MAX
!*==mean.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE MEAN(X,N,Iwrite,Xmean)
      IMPLICIT NONE
!*--MEAN12515
!*** Start of declarations inserted by SPAG
      REAL an , hold , sum , X , Xmean
      INTEGER i , ipr , Iwrite , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT MEAN
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE MEAN
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE SAMPLE MEAN = (SUM OF THE OBSERVATIONS)/N.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE MEAN
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE MEAN
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XMEAN  = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE MEAN.
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE MEAN.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 2, EDITION 1, 1961, PAGE 4.
!               --MOOD AND GRABLE, INTRODUCTION TO THE THEORY
!                 OF STATISTICS, EDITION 2, 1963, PAGE 146.
!               --DIXON AND MASSEY, INTRODUCTION TO STATISTICAL
!                 ANALYSIS, EDITION 2, 1957, PAGE 14.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      an = N
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE MEAN   SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE MEAN&
     &   SUBROUTINE HAS THE VALUE 1 *****')
            Xmean = X(1)
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE MEAN   SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            Xmean = X(1)
         ENDIF
         GOTO 100
!
!-----START POINT-----------------------------------------------------
!
 50      sum = 0.0
         DO i = 1 , N
            sum = sum + X(i)
         ENDDO
         Xmean = sum/an
      ENDIF
!
 100  IF ( Iwrite==0 ) RETURN
      WRITE (ipr,99005)
99005 FORMAT (' ')
      WRITE (ipr,99006) N , Xmean
99006 FORMAT (' ','THE SAMPLE MEAN OF THE ',I6,' OBSERVATIONS IS ',     &
     &        E15.8)
      END SUBROUTINE MEAN
!*==median.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE MEDIAN(X,N,Iwrite,Xmed)
      IMPLICIT NONE
!*--MEDIAN12627
!*** Start of declarations inserted by SPAG
      REAL hold , WS , X , Xmed , Y
      INTEGER i , iflag , ipr , iupper , Iwrite , N , nmid , nmidp1
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT MEDIAN
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE MEDIAN
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE SAMPLE MEDIAN = THAT VALUE SUCH THAT HALF THE
!              DATA SET IS BELOW IT AND HALF ABOVE IT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE MEDIAN
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE MEDIAN
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XMED   = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE MEDIAN.
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE MEDIAN.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 15000.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGE 326.
!               --KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 2, EDITION 1, 1961, PAGE 49.
!               --DAVID, ORDER STATISTICS, 1970, PAGE 139.
!               --SNEDECOR AND COCHRAN, STATISTICAL METHODS,
!                 EDITION 6, 1967, PAGE 123.
!               --DIXON AND MASSEY, INTRODUCTION TO STATISTICAL
!                 ANALYSIS, EDITION 2, 1957, PAGE 70.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(15000)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
!
      ipr = 6
      iupper = 15000
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE MEDIAN SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE MEDI&
     &AN SUBROUTINE HAS THE VALUE 1 *****')
            Xmed = X(1)
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE MEDIAN SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            Xmed = X(1)
         ENDIF
         GOTO 100
!
!-----START POINT-----------------------------------------------------
!
 50      CALL SORT(X,N,Y)
         iflag = N - (N/2)*2
         nmid = N/2
         nmidp1 = nmid + 1
         IF ( iflag==0 ) Xmed = (Y(nmid)+Y(nmidp1))/2.0
         IF ( iflag==1 ) Xmed = Y(nmidp1)
      ENDIF
!
 100  IF ( Iwrite==0 ) RETURN
      WRITE (ipr,99005)
99005 FORMAT (' ')
      WRITE (ipr,99006) N , Xmed
99006 FORMAT (' ','THE SAMPLE MEDIAN OF THE ',I6,' OBSERVATIONS IS ',   &
     &        E15.8)
      END SUBROUTINE MEDIAN
!*==midm.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE MIDM(X,N,Iwrite,Xmidm)
      IMPLICIT NONE
!*--MIDM12747
!*** Start of declarations inserted by SPAG
      REAL ak , an , hold , p1 , p2 , perp1 , perp2 , perp3 , sum , WS ,&
     &     X , Xmidm , Y
      INTEGER i , ipr , istart , istop , iupper , Iwrite , k , N , np1 ,&
     &        np2
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT MIDM
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE MIDMEAN = THE
!              SAMPLE 25% (ON EACH SIDE) TRIMMED MEAN
!              OF THE DATA IN THE INPUT VECTOR X.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE MIDMEAN
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE MIDMEAN
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XMIDM  = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE MIDMEAN.
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE MIDMEAN.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 15000.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--DAVID, ORDER STATISTICS, 1970, PAGES 129, 136.
!               --CROW AND SIDDIQUI, 'ROBUST ESTIMATION OF LOCATION',
!                 JOURNAL OF THE AMERICAN STATISTICAL ASSOCIATION,
!                 1967, PAGES 357, 387.
!               --FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY, 1969).
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(15000)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      DATA p1 , p2 , perp1 , perp2 , perp3/0.25 , 0.25 , 25.0 , 25.0 ,  &
     &     50.0/
!
      ipr = 6
      iupper = 15000
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      an = N
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE MIDM   SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE MIDM&
     &   SUBROUTINE HAS THE VALUE 1 *****')
            Xmidm = X(1)
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE MIDM   SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            Xmidm = X(1)
         ENDIF
         GOTO 100
!
!-----START POINT-----------------------------------------------------
!
 50      CALL SORT(X,N,Y)
!
         an = N
         np1 = p1*an + 0.0001
         istart = np1 + 1
         np2 = p2*an + 0.0001
         istop = N - np2
         sum = 0.0
         k = 0
         IF ( istart>istop ) THEN
            WRITE (ipr,99005)
99005       FORMAT (' ','INTERNAL ERROR IN MIDM   SUBROUTINE--',        &
     &              'THE START INDEX IS HIGHER THAN THE STOP INDEX')
            Xmidm = 0.0
            RETURN
         ELSE
            DO i = istart , istop
               k = k + 1
!CCCC SUM=SUM+X(I)
               sum = sum + Y(i)
            ENDDO
            ak = k
            Xmidm = sum/ak
         ENDIF
      ENDIF
!
 100  IF ( Iwrite==0 ) RETURN
      WRITE (ipr,99006)
99006 FORMAT (' ')
      WRITE (ipr,99007) N , Xmidm
99007 FORMAT (' ','THE SAMPLE MIDMEAN OF THE ',I6,' OBSERVATIONS',      &
     &        ' IS ',E15.8)
      WRITE (ipr,99008) perp1 , np1
99008 FORMAT (' ',8X,F10.4,' PERCENT (= ',I6,' OBSERVATIONS) ',         &
     &        'OF THE DATA WERE TRIMMED     FROM BELOW')
      WRITE (ipr,99009) perp2 , np2
99009 FORMAT (' ',8X,F10.4,' PERCENT (= ',I6,' OBSERVATIONS) ',         &
     &        'OF THE DATA WERE TRIMMED     FROM ABOVE')
      WRITE (ipr,99010) perp3 , k
99010 FORMAT (' ',8X,F10.4,' PERCENT (= ',I6,' OBSERVATIONS) ',         &
     &        ' OF THE DATA REMAIN IN THE MIDDLE AFTER THE TRIMMING')
!
      END SUBROUTINE MIDM
!*==midr.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE MIDR(X,N,Iwrite,Xmidr)
      IMPLICIT NONE
!*--MIDR12898
!*** Start of declarations inserted by SPAG
      REAL hold , X , xmax , Xmidr , xmin
      INTEGER i , ipr , Iwrite , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT MIDR
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE MIDRANGE
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE SAMPLE MIDRANGE = (SAMPLE MIN + SAMPLE MAX)/2.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE MIDRANGE
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE MIDRANGE
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XMIDR  = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE MIDRANGE.
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE MIDRANGE.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGE 338.
!               --KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 2, EDITION 1, 1961, PAGE 91.
!               --DAVID, ORDER STATISTICS, 1970, PAGE 97.
!               --DIXON AND MASSEY, INTRODUCTION TO STATISTICAL
!                 ANALYSIS, EDITION 2, 1957, PAGE 71.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE MIDR   SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE MIDR&
     &   SUBROUTINE HAS THE VALUE 1 *****')
            Xmidr = X(1)
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE MIDR   SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            Xmidr = X(1)
         ENDIF
         GOTO 100
!
!-----START POINT-----------------------------------------------------
!
 50      xmin = X(1)
         xmax = X(1)
         DO i = 1 , N
            IF ( X(i)<xmin ) xmin = X(i)
            IF ( X(i)>xmax ) xmax = X(i)
         ENDDO
         Xmidr = (xmin+xmax)/2.0
      ENDIF
!
 100  IF ( Iwrite==0 ) RETURN
      WRITE (ipr,99005)
99005 FORMAT (' ')
      WRITE (ipr,99006) N , Xmidr
99006 FORMAT (' ','THE SAMPLE MIDRANGE OF THE ',I6,' OBSERVATIONS IS ', &
     &        E22.15)
      END SUBROUTINE MIDR
!*==min.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE MIN(X,N,Iwrite,Xmin)
      IMPLICIT NONE
!*--MIN13011
!*** Start of declarations inserted by SPAG
      REAL hold , X , Xmin
      INTEGER i , ipr , Iwrite , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT MIN
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE MINIMUM
!              OF THE DATA IN THE INPUT VECTOR X.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE MINIMUM
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE MINIMUM
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XMIN   = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE MINIMUM.
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE MINIMUM.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--DAVID, ORDER STATISTICS, 1970, PAGE 7.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE MIN    SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE MIN &
     &   SUBROUTINE HAS THE VALUE 1 *****')
            Xmin = X(1)
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE MIN    SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            Xmin = X(1)
         ENDIF
         GOTO 100
!
!-----START POINT-----------------------------------------------------
!
 50      Xmin = X(1)
         DO i = 2 , N
            IF ( X(i)<Xmin ) Xmin = X(i)
         ENDDO
      ENDIF
!
 100  IF ( Iwrite==0 ) RETURN
      WRITE (ipr,99005)
99005 FORMAT (' ')
      WRITE (ipr,99006) N , Xmin
99006 FORMAT (' ','THE MINIMUM OF THE SET OF ',I6,' OBSERVATIONS IS ',  &
     &        E15.8)
      END SUBROUTINE MIN
!*==move.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE MOVE(X,M,Ix1,Iy1,Y)
      IMPLICIT NONE
!*--MOVE13114
!*** Start of declarations inserted by SPAG
      REAL hold , X , Y
      INTEGER i , iend , ipr , istart , Ix1 , Iy1 , j , k , M
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT MOVE
!
!     PURPOSE--THIS SUBROUTINE MOVES (COPIES) M ELEMENTS OF THE
!              SINGLE PRECISION VECTOR X
!              (STARTING WITH POSITION IX1)
!              INTO THE SINGLE PRECISION VECTOR Y
!              (STARTING WITH POSITION IY1).
!              THIS ALLOWS THE DATA ANALYST
!              TO TAKE ANY SUBVECTOR IN X AND PLACE IT
!              ANYWHERE IN THE VECTOR Y.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                OBSERVATIONS, PART (OR ALL)
!                                OF WHICH IS TO BE MOVED
!                                (COPIED) OVER INTO THE VECTOR Y.
!                     --M      = THE INTEGER NUMBER OF ELEMENTS
!                                IN THE VECTOR X TO BE MOVED.
!                     --IX1    = THE INTEGER VALUE WHICH DEFINES
!                                THE POSITION IN THE VECTOR X
!                                OF THE FIRST ELEMENT TO BE MOVED.
!                     --IY1    = THE INTEGER VALUE WHICH DEFINES
!                                THE POSITION IN THE VECTOR Y
!                                WHERE THE FIRST ELEMENT TO BE MOVED
!                                WILL BE PLACED.
!     OUTPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR
!                                INTO WHICH THE COPIED DATA VALUES
!                                FROM THE VECTOR X WILL BE SEQUENTIALLY
!                                PLACED, STARTING IN POSITION IY1 OF Y.
!     OUTPUT--THE SINGLE PRECISION VECTOR Y.
!             IN WHICH THE M ELEMENTS IN POSITIONS
!             IY1, IY1+1, ... , IY1+M-1
!             WILL BE IDENTICAL TO THE M ELEMENTS
!             IN THE X VECTOR IN POSITIONS
!             IX1, IX1+1, ... , IX1+M-1.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF M FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--THE ELEMENT IN POSITION IX1 OF THE VECTOR X
!            IS COPIED INTO POSITION IY1 OF THE VECTOR Y,
!            THE ELEMENT IN POSITION (IX1+1) OF THE VECTOR X
!            IS COPIED INTO POSITION (IY1+1) OF THE VECTOR Y,
!            ... ,
!            THE ELEMENT IN POSITION (IX1+M-1) OF THE VECTOR X
!            IS COPIED INTO POSITION (IY1+M-1) OF THE VECTOR Y.
!     COMMENT--THE INPUT VECTOR X REMAINS UNALTERED.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1972.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1) , Y(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( M<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE MOVE   SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99006) M
         RETURN
      ELSEIF ( Ix1<1 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE MOVE   SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99006) Ix1
         RETURN
      ELSEIF ( Iy1<1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FOURTH INPUT ARGUMENT TO THE MOVE   SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99006) Iy1
         RETURN
      ELSE
         IF ( M==1 ) THEN
            WRITE (ipr,99004)
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE MOVE&
     &   SUBROUTINE HAS THE VALUE 1 *****')
         ELSE
            hold = X(Ix1)
            istart = Ix1 + 1
            iend = Ix1 + M - 1
            DO i = istart , iend
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99005) hold
99005       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE MOVE   SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      DO i = 1 , M
            j = Ix1 - 1 + i
            k = Iy1 - 1 + i
            Y(k) = X(j)
         ENDDO
      ENDIF
99006 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
!
      END SUBROUTINE MOVE
!*==nbcdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE NBCDF(X,P,N,Cdf)
      IMPLICIT NONE
!*--NBCDF13239
!*** Start of declarations inserted by SPAG
      REAL ak , an , an2 , Cdf , del , fintx , P , X
      INTEGER i , ievodd , iflag1 , iflag2 , imax , imin , intx , ipr , &
     &        k , N , n2 , nu1 , nu2
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT NBCDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE AT THE SINGLE PRECISION VALUE X
!              FOR THE NEGATIVE BINOMIAL DISTRIBUTION
!              WITH SINGLE PRECISION 'BERNOULLI PROBABILITY'
!              PARAMETER = P,
!              AND INTEGER 'NUMBER OF SUCCESSES IN BERNOULLI TRIALS'
!              PARAMETER = N.
!              THE NEGATIVE BINOMIAL DISTRIBUTION USED
!              HEREIN HAS MEAN = N*(1-P)/P
!              AND STANDARD DEVIATION = SQRT(N*(1-P)/(P*P))).
!              THIS DISTRIBUTION IS DEFINED FOR
!              ALL NON-NEGATIVE INTEGER X--X = 0, 1, 2, ... .
!              THIS DISTRIBUTION HAS THE PROBABILITY FUNCTION
!              F(X) = C(N+X-1,N) * P**N * (1-P)**X.
!              WHERE C(N+X-1,N) IS THE COMBINATORIAL FUNCTION
!              EQUALING THE NUMBER OF COMBINATIONS OF N+X-1 ITEMS
!              TAKEN N AT A TIME.
!              THE NEGATIVE BINOMIAL DISTRIBUTION IS THE
!              DISTRIBUTION OF THE NUMBER OF FAILURES
!              BEFORE OBTAINING N SUCCESSES IN AN
!              INDEFINITE SEQUENCE OF BERNOULLI (0,1)
!              TRIALS WHERE THE PROBABILITY OF SUCCESS
!              IN A SINGLE TRIAL = P.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE
!                                AT WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!                                X SHOULD BE NON-NEGATIVE AND
!                                INTEGRAL-VALUED.
!                     --P      = THE SINGLE PRECISION VALUE
!                                OF THE 'BERNOULLI PROBABILITY'
!                                PARAMETER FOR THE NEGATIVE BINOMIAL
!                                DISTRIBUTION.
!                                P SHOULD BE BETWEEN
!                                0.0 (EXCLUSIVELY) AND
!                                1.0 (EXCLUSIVELY).
!                     --N      = THE INTEGER VALUE
!                                OF THE 'NUMBER OF SUCCESSES
!                                IN BERNOULLI TRIALS' PARAMETER.
!                                N SHOULD BE A POSITIVE INTEGER.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF
!             FOR THE NEGATIVE BINOMIAL DISTRIBUTION
!             WITH 'BERNOULLI PROBABILITY' PARAMETER = P
!             AND 'NUMBER OF SUCCESSES IN BERNOULLI TRIALS'
!             PARAMETER = N.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--X SHOULD BE NON-NEGATIVE AND INTEGRAL-VALUED.
!                 --P SHOULD BE BETWEEN 0.0 (EXCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!                 --N SHOULD BE A POSITIVE INTEGER.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--DSQRT, DATAN.
!     MODE OF INTERNAL OPERATIONS--DOUBLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--NOTE THAT EVEN THOUGH THE INPUT
!              TO THIS CUMULATIVE
!              DISTRIBUTION FUNCTION SUBROUTINE
!              FOR THIS DISCRETE DISTRIBUTION
!              SHOULD (UNDER NORMAL CIRCUMSTANCES) BE A
!              DISCRETE INTEGER VALUE,
!              THE INPUT VARIABLE X IS SINGLE
!              PRECISION IN MODE.
!              X HAS BEEN SPECIFIED AS SINGLE
!              PRECISION SO AS TO CONFORM WITH THE DATAPAC
!              CONVENTION THAT ALL INPUT ****DATA****
!              (AS OPPOSED TO SAMPLE SIZE, FOR EXAMPLE)
!              VARIABLES TO ALL
!              DATAPAC SUBROUTINES ARE SINGLE PRECISION.
!              THIS CONVENTION IS BASED ON THE BELIEF THAT
!              1) A MIXTURE OF MODES (FLOATING POINT
!              VERSUS INTEGER) IS INCONSISTENT AND
!              AN UNNECESSARY COMPLICATION
!              IN A DATA ANALYSIS; AND
!              2) FLOATING POINT MACHINE ARITHMETIC
!              (AS OPPOSED TO INTEGER ARITHMETIC)
!              IS THE MORE NATURAL MODE FOR DOING
!              DATA ANALYSIS.
!     REFERENCES--NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 945, FORMULAE 26.5.24 AND
!                 26.5.28, AND PAGE 929.
!               --JOHNSON AND KOTZ, DISCRETE
!                 DISTRIBUTIONS, 1969, PAGES 122-142,
!                 ESPECIALLY PAGE 127.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 92-95.
!               --FELLER, AN INTRODUCTION TO PROBABILITY
!                 THEORY AND ITS APPLICATIONS, VOLUME 1,
!                 EDITION 2, 1957, PAGES 155-157, 210.
!               --KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGES 130-131.
!               --WILLIAMSON AND BRETHERTON, TABLES OF
!                 THE NEGATIVE BINOMIAL PROBABILITY
!                 DISTRIBUTION, 1963.
!               --OWEN, HANDBOOK OF STATISTICAL
!                 TABLES, 1962, PAGE 304.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DOUBLE PRECISION dx2 , pi , anu1 , anu2 , z , sum , term , ai ,   &
     &                 coef1 , coef2 , arg
      DOUBLE PRECISION coef
      DOUBLE PRECISION theta , sinth , costh , a , b
      DOUBLE PRECISION DSQRT , DATAN
      DATA pi/3.14159265358979D0/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      an = N
      IF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE NBCDF  SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99006) P
         Cdf = 0.0
         RETURN
      ELSEIF ( N<1 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE NBCDF  SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99003) N
99003    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         Cdf = 0.0
         RETURN
      ELSEIF ( X<0.0 ) THEN
         WRITE (ipr,99004)
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE NBCD&
     &F  SUBROUTINE IS NEGATIVE *****')
         WRITE (ipr,99006) X
         IF ( X<0.0 ) Cdf = 0.0
         RETURN
      ELSE
         intx = X + 0.0001
         fintx = intx
         del = X - fintx
         IF ( del<0.0 ) del = -del
         IF ( del>0.001 ) THEN
            WRITE (ipr,99005)
99005       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE NBCD&
     &F  SUBROUTINE IS NON-INTEGRAL *****')
            WRITE (ipr,99006) X
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
!     EXPRESS THE NEGATIVE BINOMIAL CUMULATIVE DISTRIBUTION
!     FUNCTION IN TERMS OF THE EQUIVALENT BINOMIAL
!     CUMULATIVE DISTRIBUTION FUNCTION,
!     AND THEN OPERATE ON THE LATTER.
!
         intx = X + 0.0001
         k = N - 1
         n2 = N + intx
!
!     EXPRESS THE BINOMIAL CUMULATIVE DISTRIBUTION
!     FUNCTION IN TERMS OF THE EQUIVALENT F
!     CUMULATIVE DISTRIBUTION FUNCTION,
!     AND THEN EVALUATE THE LATTER.
!
         ak = k
         an2 = n2
         dx2 = (P/(1.0-P))*((an2-ak)/(ak+1.0))
         nu1 = 2*(k+1)
         nu2 = 2*(n2-k)
         anu1 = nu1
         anu2 = nu2
         z = anu2/(anu2+anu1*dx2)
!
!     DETERMINE IF NU1 AND NU2 ARE EVEN OR ODD
!
         iflag1 = nu1 - 2*(nu1/2)
         iflag2 = nu2 - 2*(nu2/2)
         IF ( iflag1==0 ) THEN
!
!     DO THE NU1 EVEN AND NU2 EVEN OR ODD CASE
!
            sum = 0.0D0
            term = 1.0D0
            imax = (nu1-2)/2
            IF ( imax>0 ) THEN
               DO i = 1 , imax
                  ai = i
                  coef1 = 2.0D0*(ai-1.0D0)
                  coef2 = 2.0D0*ai
                  term = term*((anu2+coef1)/coef2)*(1.0D0-z)
                  sum = sum + term
               ENDDO
            ENDIF
!
            sum = sum + 1.0D0
            sum = (z**(anu2/2.0D0))*sum
            Cdf = 1.0D0 - sum
            RETURN
         ELSEIF ( iflag2==0 ) THEN
!
!     DO THE NU1 ODD AND NU2 EVEN CASE
!
            sum = 0.0D0
            term = 1.0D0
            imax = (nu2-2)/2
            IF ( imax>0 ) THEN
               DO i = 1 , imax
                  ai = i
                  coef1 = 2.0D0*(ai-1.0D0)
                  coef2 = 2.0D0*ai
                  term = term*((anu1+coef1)/coef2)*z
                  sum = sum + term
               ENDDO
            ENDIF
!
            sum = sum + 1.0D0
            Cdf = ((1.0D0-z)**(anu1/2.0D0))*sum
            RETURN
         ELSE
!
!     DO THE NU1 ODD AND NU2 ODD CASE
!
            sum = 0.0D0
            term = 1.0D0
            arg = DSQRT((anu1/anu2)*dx2)
            theta = DATAN(arg)
            sinth = arg/DSQRT(1.0D0+arg*arg)
            costh = 1.0D0/DSQRT(1.0D0+arg*arg)
            IF ( nu2/=1 ) THEN
               IF ( nu2/=3 ) THEN
                  imax = nu2 - 2
                  DO i = 3 , imax , 2
                     ai = i
                     coef1 = ai - 1.0D0
                     coef2 = ai
                     term = term*(coef1/coef2)*(costh*costh)
                     sum = sum + term
                  ENDDO
               ENDIF
!
               sum = sum + 1.0D0
               sum = sum*sinth*costh
            ENDIF
!
            a = (2.0D0/pi)*(theta+sum)
            sum = 0.0D0
            term = 1.0D0
            IF ( nu1==1 ) b = 0.0D0
            IF ( nu1/=1 ) THEN
               IF ( nu1/=3 ) THEN
                  imax = nu1 - 3
                  DO i = 1 , imax , 2
                     ai = i
                     coef1 = ai
                     coef2 = ai + 2.0D0
                     term = term*((anu2+coef1)/coef2)*(sinth*sinth)
                     sum = sum + term
                  ENDDO
               ENDIF
!
               sum = sum + 1.0D0
               sum = sum*sinth*(costh**N)
               coef = 1.0D0
               ievodd = nu2 - 2*(nu2/2)
               imin = 3
               IF ( ievodd==0 ) imin = 2
               IF ( imin<=nu2 ) THEN
                  DO i = imin , nu2 , 2
                     ai = i
                     coef = ((ai-1.0D0)/ai)*coef
                  ENDDO
               ENDIF
!
               coef = coef*anu2
               IF ( ievodd/=0 ) coef = coef*(2.0D0/pi)
!
               b = coef*sum
            ENDIF
!
            Cdf = a - b
         ENDIF
      ENDIF
99006 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
      END SUBROUTINE NBCDF
!*==nbppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE NBPPF(P,Ppar,N,Ppf)
      IMPLICIT NONE
!*--NBPPF13546
!*** Start of declarations inserted by SPAG
      REAL amean , an , arcsh , arg , e , P , p0 , p1 , p2 , pf0 ,      &
     &     Ppar , Ppf , sd , sinh , x0 , x1 , x2 , ymean , yppf , ysd
      REAL zppf
      INTEGER i , ipr , isd , ix0 , ix0p1 , ix1 , ix2 , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT NBPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE AT THE SINGLE PRECISION VALUE P
!              FOR THE NEGATIVE BINOMIAL DISTRIBUTION
!              WITH SINGLE PRECISION 'BERNOULLI PROBABILITY'
!              PARAMETER = PPAR,
!              AND INTEGER 'NUMBER OF SUCCESSES IN BERNOULLI TRIALS'
!              PARAMETER = N.
!              THE NEGATIVE BINOMIAL DISTRIBUTION USED
!              HEREIN HAS MEAN = N*(1-PPAR)/PPAR
!              AND STANDARD DEVIATION = SQRT(N*(1-PPAR)/(PPAR*PPAR))).
!              THIS DISTRIBUTION IS DEFINED FOR
!              ALL NON-NEGATIVE INTEGER X--X = 0, 1, 2, ... .
!              THIS DISTRIBUTION HAS THE PROBABILITY FUNCTION
!              F(X) = C(N+X-1,N) * PPAR**N * (1-PPAR)**X.
!              WHERE C(N+X-1,N) IS THE COMBINATORIAL FUNCTION
!              EQUALING THE NUMBER OF COMBINATIONS OF N+X-1 ITEMS
!              TAKEN N AT A TIME.
!              THE NEGATIVE BINOMIAL DISTRIBUTION IS THE
!              DISTRIBUTION OF THE NUMBER OF FAILURES
!              BEFORE OBTAINING N SUCCESSES IN AN
!              INDEFINITE SEQUENCE OF BERNOULLI (0,1)
!              TRIALS WHERE THE PROBABILITY OF SUCCESS
!              IN A SINGLE TRIAL = PPAR.
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 (INCLUSIVELY)
!                                AND 1.0 (EXCLUSIVELY))
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!                     --PPAR   = THE SINGLE PRECISION VALUE
!                                OF THE 'BERNOULLI PROBABILITY'
!                                PARAMETER FOR THE NEGATIVE BINOMIAL
!                                DISTRIBUTION.
!                                PPAR SHOULD BE BETWEEN
!                                0.0 (EXCLUSIVELY) AND
!                                1.0 (EXCLUSIVELY).
!                     --N      = THE INTEGER VALUE
!                                OF THE 'NUMBER OF SUCCESSES
!                                IN BERNOULLI TRIALS' PARAMETER.
!                                N SHOULD BE A POSITIVE INTEGER.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT  .
!             FUNCTION VALUE PPF
!             FOR THE NEGATIVE BINOMIAL DISTRIBUTION
!             WITH 'BERNOULLI PROBABILITY' PARAMETER = PPAR
!             AND 'NUMBER OF SUCCESSES IN BERNOULLI TRIALS'
!             PARAMETER = N.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--PPAR SHOULD BE BETWEEN 0.0 (EXCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!                 --N SHOULD BE A POSITIVE INTEGER.
!                 --P SHOULD BE BETWEEN 0.0 (INCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NORPPF, NBCDF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, EXP, ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION AND DOUBLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--NOTE THAT EVEN THOUGH THE OUTPUT
!              FROM THIS DISCRETE DISTRIBUTION
!              PERCENT POINT FUNCTION
!              SUBROUTINE MUST NECESSARILY BE A
!              DISCRETE INTEGER VALUE,
!              THE OUTPUT VARIABLE PPF IS SINGLE
!              PRECISION IN MODE.
!              PPF HAS BEEN SPECIFIED AS SINGLE
!              PRECISION SO AS TO CONFORM WITH THE DATAPAC
!              CONVENTION THAT ALL OUTPUT VARIABLES FROM ALL
!              DATAPAC SUBROUTINES ARE SINGLE PRECISION.
!              THIS CONVENTION IS BASED ON THE BELIEF THAT
!              1) A MIXTURE OF MODES (FLOATING POINT
!              VERSUS INTEGER) IS INCONSISTENT AND
!              AN UNNECESSARY COMPLICATION
!              IN A DATA ANALYSIS; AND
!              2) FLOATING POINT MACHINE ARITHMETIC
!              (AS OPPOSED TO INTEGER ARITHMETIC)
!              IS THE MORE NATURAL MODE FOR DOING
!              DATA ANALYSIS.
!     REFERENCES--JOHNSON AND KOTZ, DISCRETE
!                 DISTRIBUTIONS, 1969, PAGES 122-142,
!                 ESPECIALLY PAGE 127, FORMULA 22.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 92-95.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 929.
!               --FELLER, AN INTRODUCTION TO PROBABILITY
!                 THEORY AND ITS APPLICATIONS, VOLUME 1,
!                 EDITION 2, 1957, PAGES 155-157, 210.
!               --KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGES 130-131.
!               --WILLIAMSON AND BRETHERTON, TABLES OF
!                 THE NEGATIVE BINOMIAL PROBABILITY
!                 DISTRIBUTION, 1963.
!               --OWEN, HANDBOOK OF STATISTICAL
!                 TABLES, 1962, PAGE 304.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DOUBLE PRECISION dppar
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE NBPPF  SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99019) P
         Ppf = 0.0
         RETURN
      ELSE
         IF ( Ppar<=0.0 .OR. Ppar>=1.0 ) THEN
            WRITE (ipr,99002)
99002       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE NBPPF  SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
            WRITE (ipr,99019) Ppar
            Ppf = 0.0
            RETURN
         ELSE
            IF ( N<1 ) THEN
               WRITE (ipr,99003)
99003          FORMAT (' ',                                             &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE NBPPF  SUBROU&
     &TINE IS NON-POSITIVE *****')
               WRITE (ipr,99004) N
99004          FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,    &
     &                 ' *****')
               Ppf = 0.0
               RETURN
            ELSE
!
!-----START POINT-----------------------------------------------------
!
               an = N
               dppar = Ppar
               Ppf = 0.0
               ix0 = 0
               ix1 = 0
               ix2 = 0
               p0 = 0.0
               p1 = 0.0
               p2 = 0.0
!
!     TREAT CERTAIN SPECIAL CASES IMMEDIATELY--
!     1) P = 0.0
!     2) P = 0.5 AND PPAR = 0.5
!     3) PPF = 0
!
               IF ( P/=0.0 ) THEN
                  IF ( P==0.5 .AND. Ppar==0.5 ) THEN
                     Ppf = N - 1
                     RETURN
                  ELSE
                     pf0 = dppar**N
                     IF ( P>pf0 ) THEN
!
!     DETERMINE AN INITIAL APPROXIMATION TO THE NEGATIVE BINOMIAL
!     PERCENT POINT BY USE OF THE HYPERBOLIC ARCSIN
!     TRANSFORMATION OF THE NEGATIVE BINOMIAL
!     TO APPROXIMATE NORMALITY.
!     (SEE JOHNSON AND KOTZ, DISCRETE DISTRIBUTIONS,
!     PAGE 127, FORMULA 22).
!
                        amean = an*(1.0-Ppar)/Ppar
                        sd = SQRT(an*(1.0-Ppar)/(Ppar*Ppar))
                        arg = SQRT((amean+0.375)/(an-0.75))
                        arcsh = ALOG(arg+SQRT(arg*arg+1.0))
                        ymean = (SQRT(an-0.5))*arcsh
                        ysd = 0.5
                        CALL NORPPF(P,zppf)
                        yppf = ymean + zppf*ysd
                        arg = yppf/SQRT(an-0.5)
                        e = EXP(arg)
                        sinh = (e-1.0/e)/2.0
                        x2 = -0.375 + (an-0.75)*sinh*sinh
                        x2 = x2 + 0.5
                        ix2 = x2
!
!     CHECK AND MODIFY (IF NECESSARY) THIS INITIAL
!     ESTIMATE OF THE PERCENT POINT
!     TO ASSURE THAT IT BE NON-NEGATIVE.
!
                        IF ( ix2<0 ) ix2 = 0
!
!     DETERMINE UPPER AND LOWER BOUNDS ON THE DESIRED
!     PERCENT POINT BY ITERATING OUT (BOTH BELOW AND ABOVE)
!     FROM THE ORIGINAL APPROXIMATION AT STEPS
!     OF 1 STANDARD DEVIATION.
!     THE RESULTING BOUNDS WILL BE AT MOST
!     1 STANDARD DEVIATION APART.
!
                        ix0 = 0
                        ix1 = huge(0) ! = 10**10
                        isd = sd + 1.0
                        x2 = ix2
                        CALL NBCDF(x2,Ppar,N,p2)
!
                        IF ( p2<P ) THEN
!
                           ix0 = ix2
                           DO i = 1 , 100000
                              ix2 = ix0 + isd
                              IF ( ix2>=ix1 ) GOTO 100
                              x2 = ix2
                              CALL NBCDF(x2,Ppar,N,p2)
                              IF ( p2>=P ) GOTO 20
                              ix0 = ix2
                           ENDDO
                           WRITE (ipr,99020)
                           WRITE (ipr,99005)
!
99005                      FORMAT (' ',                                 &
     &                     'NO UPPER BOUND FOUND AFTER 10**7 ITERATIONS'&
     &                     )
                        ELSE
!
                           ix1 = ix2
                           DO i = 1 , 100000
                              ix2 = ix1 - isd
                              IF ( ix2<=ix0 ) GOTO 100
                              x2 = ix2
                              CALL NBCDF(x2,Ppar,N,p2)
                              IF ( p2<P ) GOTO 50
                              ix1 = ix2
                           ENDDO
                           WRITE (ipr,99020)
                           WRITE (ipr,99006)
99006                      FORMAT (' ',                                 &
     &                     'NO LOWER BOUND FOUND AFTER 10**7 ITERATIONS'&
     &                     )
                        ENDIF
                        GOTO 200
                     ENDIF
                  ENDIF
               ENDIF
               Ppf = 0.0
               RETURN
            ENDIF
 20         ix1 = ix2
            GOTO 100
         ENDIF
 50      ix0 = ix2
      ENDIF
!
 100  IF ( ix0==ix1 ) THEN
         IF ( ix0==0 ) THEN
            ix1 = ix1 + 1
         ELSEIF ( ix0==N ) THEN
            ix0 = ix0 - 1
         ELSE
            WRITE (ipr,99020)
            WRITE (ipr,99007)
99007       FORMAT (' ','LOWER AND UPPER BOUND IDENTICAL')
            GOTO 200
         ENDIF
      ENDIF
!
!     COMPUTE NEGATIVE BINOMIAL PROBABILITIES FOR THE
!     DERIVED LOWER AND UPPER BOUNDS.
!
      x0 = ix0
      x1 = ix1
      CALL NBCDF(x0,Ppar,N,p0)
      CALL NBCDF(x1,Ppar,N,p1)
!
!     CHECK THE PROBABILITIES FOR PROPER ORDERING
!
      IF ( p0<P .AND. P<=p1 ) THEN
         DO
!
!     THE STOPPING CRITERION IS THAT THE LOWER BOUND
!     AND UPPER BOUND ARE EXACTLY 1 UNIT APART.
!     CHECK TO SEE IF IX1 = IX0 + 1;
!     IF SO, THE ITERATIONS ARE COMPLETE;
!     IF NOT, THEN BISECT, COMPUTE PROBABILIIES,
!     CHECK PROBABILITIES, AND CONTINUE ITERATING
!     UNTIL IX1 = IX0 + 1.
!
            ix0p1 = ix0 + 1
            IF ( ix1==ix0p1 ) THEN
               Ppf = ix1
               IF ( p0==P ) Ppf = ix0
               RETURN
            ELSE
               ix2 = (ix0+ix1)/2
               IF ( ix2/=ix0 ) THEN
                  IF ( ix2==ix1 ) THEN
                     WRITE (ipr,99020)
                     WRITE (ipr,99021)
                     EXIT
                  ELSE
                     x2 = ix2
                     CALL NBCDF(x2,Ppar,N,p2)
                     IF ( p0<p2 .AND. p2<p1 ) THEN
                        IF ( p2<=P ) THEN
                           ix0 = ix2
                           p0 = p2
                        ELSE
                           ix1 = ix2
                           p1 = p2
                        ENDIF
                        CYCLE
                     ELSEIF ( p2<=p0 ) THEN
                        WRITE (ipr,99020)
                        WRITE (ipr,99008)
99008                   FORMAT (' ','BISECTION VALUE PROBABILITY (P2) ',&
     &                          'LESS THAN LOWER BOUND PROBABILITY (P0)'&
     &                          )
                        EXIT
                     ELSEIF ( p2>=p1 ) THEN
                        WRITE (ipr,99020)
                        WRITE (ipr,99009)
99009                   FORMAT (' ','BISECTION VALUE PROBABILITY (P2) ',&
     &                       'GREATER THAN UPPER BOUND PROBABILITY (P1)'&
     &                       )
                        EXIT
                     ENDIF
                  ENDIF
               ENDIF
               WRITE (ipr,99020)
               WRITE (ipr,99021)
               EXIT
            ENDIF
         ENDDO
      ELSEIF ( p0==P ) THEN
         Ppf = ix0
         RETURN
      ELSEIF ( p1==P ) THEN
         Ppf = ix1
         RETURN
      ELSEIF ( p0>p1 ) THEN
         WRITE (ipr,99020)
         WRITE (ipr,99010)
99010    FORMAT (' ','LOWER BOUND PROBABILITY (P0) GREATER THAN ',      &
     &           'UPPER BOUND PROBABILITY (P1)')
      ELSEIF ( p0>P ) THEN
         WRITE (ipr,99020)
         WRITE (ipr,99011)
99011    FORMAT (' ','LOWER BOUND PROBABILITY (P0) GREATER THAN ',      &
     &           'INPUT PROBABILITY (P)')
      ELSEIF ( p1<P ) THEN
         WRITE (ipr,99020)
         WRITE (ipr,99012)
99012    FORMAT (' ','UPPER BOUND PROBABILITY (P1) LESS    THAN ',      &
     &           'INPUT PROBABILITY (P)')
      ELSE
         WRITE (ipr,99020)
         WRITE (ipr,99013)
99013    FORMAT (' ','IMPOSSIBLE BRANCH CONDITION ENCOUNTERED')
      ENDIF
!
 200  WRITE (ipr,99014) ix0 , p0
99014 FORMAT (' ','IX0  = ',I8,10X,'P0 = ',F14.7)
      WRITE (ipr,99015) ix1 , p1
99015 FORMAT (' ','IX1  = ',I8,10X,'P1 = ',F14.7)
      WRITE (ipr,99016) ix2 , p2
99016 FORMAT (' ','IX2  = ',I8,10X,'P2 = ',F14.7)
      WRITE (ipr,99017) P
99017 FORMAT (' ','P    = ',F14.7)
      WRITE (ipr,99018) Ppar , N
99018 FORMAT (' ','PPAR = ',F14.7,10X,'N  = ',I8)
      RETURN
99019 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
99020 FORMAT (' ','***** INTERNAL ERROR IN NBPPF  SUBROUTINE *****')
99021 FORMAT (' ','BISECTION VALUE (X2) = LOWER BOUND (X0)')
99022 FORMAT (' ','BISECTION VALUE (X2) = UPPER BOUND (X1)')
!
      END SUBROUTINE NBPPF
!*==nbran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE NBRAN(N,P,Npar,Istart,X)
      IMPLICIT NONE
!*--NBRAN13940
!*** Start of declarations inserted by SPAG
      REAL b(1) , g(1) , P , X
      INTEGER i , ib , ig , ipr , Istart , isum , j , N , Npar
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT NBRAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE NEGATIVE BINOMIAL DISTRIBUTION
!              WITH SINGLE PRECISION 'BERNOULLI PROBABILITY'
!              PARAMETER = P,
!              AND INTEGER 'NUMBER OF SUCCESSES IN BERNOULLI TRIALS'
!              PARAMETER = NPAR.
!              THE NEGATIVE BINOMIAL DISTRIBUTION USED
!              HEREIN HAS MEAN = NPAR*(1-P)/P
!              AND STANDARD DEVIATION = SQRT(NPAR*(1-P)/(P*P))).
!              THIS DISTRIBUTION IS DEFINED FOR
!              ALL NON-NEGATIVE INTEGER X--X = 0, 1, 2, ... .
!              THIS DISTRIBUTION HAS THE PROBABILITY FUNCTION
!              F(X) = C(NPAR+X-1,NPAR) * P**NPAR * (1-P)**X.
!              WHERE C(NPAR+X-1,NPAR) IS THE COMBINATORIAL FUNCTION
!              EQUALING THE NUMBER OF COMBINATIONS OF NPAR+X-1 ITEMS
!              TAKEN NPAR AT A TIME.
!              THE NEGATIVE BINOMIAL DISTRIBUTION IS THE
!              DISTRIBUTION OF THE NUMBER OF FAILURES
!              BEFORE OBTAINING NPAR SUCCESSES IN AN
!              INDEFINITE SEQUENCE OF BERNOULLI (0,1)
!              TRIALS WHERE THE PROBABILITY OF SUCCESS
!              IN A SINGLE TRIAL = P.
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!                     --P      = THE SINGLE PRECISION VALUE
!                                OF THE 'BERNOULLI PROBABILITY'
!                                PARAMETER FOR THE NEGATIVE BINOMIAL
!                                DISTRIBUTION.
!                                P SHOULD BE BETWEEN
!                                0.0 (EXCLUSIVELY) AND
!                                1.0 (EXCLUSIVELY).
!                     --NPAR   = THE INTEGER VALUE
!                                OF THE 'NUMBER OF SUCCESSES
!                                IN BERNOULLI TRIALS' PARAMETER.
!                                NPAR SHOULD BE A POSITIVE INTEGER.
!                     --ISTART = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL START THE
!                                GENERATOR OVER AND HENCE
!                                PRODUCE THE SAME RANDOM SAMPLE
!                                OVER AND OVER AGAIN
!                                UPON SUCCESSIVE CALLS TO
!                                THIS SUBROUTINE WITHIN A RUN; OR
!                                (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0,
!                                LIKE, SAY, 1) WILL ALLOW
!                                THE GENERATOR TO CONTINUE
!                                FROM WHERE IT STOPPED
!                                AND HENCE PRODUCE DIFFERENT
!                                RANDOM SAMPLES UPON
!                                SUCCESSIVE CALLS TO
!                                THIS SUBROUTINE WITHIN A RUN.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE NEGATIVE BINOMIAL DISTRIBUTION
!             WITH 'BERNOULLI PROBABILITY' PARAMETER = P
!             AND 'NUMBER OF SUCCESSES IN BERNOULLI TRIALS'
!             PARAMETER = NPAR.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!                 --P SHOULD BE BETWEEN 0.0 (EXCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!                 --NPAR SHOULD BE A POSITIVE INTEGER.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN, BINRAN, GEORAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--NOTE THAT EVEN THOUGH THE OUTPUT
!              FROM THIS DISCRETE RANDOM NUMBER
!              GENERATOR MUST NECESSARILY BE A
!              SEQUENCE OF ***INTEGER*** VALUES,
!              THE OUTPUT VECTOR X IS SINGLE
!              PRECISION IN MODE.
!              X HAS BEEN SPECIFIED AS SINGLE
!              PRECISION SO AS TO CONFORM WITH THE DATAPAC
!              CONVENTION THAT ALL OUTPUT VECTORS FROM ALL
!              DATAPAC SUBROUTINES ARE SINGLE PRECISION.
!              THIS CONVENTION IS BASED ON THE BELIEF THAT
!              1) A MIXTURE OF MODES (FLOATING POINT
!              VERSUS INTEGER) IS INCONSISTENT AND
!              AN UNNECESSARY COMPLICATION
!              IN A DATA ANALYSIS; AND
!              2) FLOATING POINT MACHINE ARITHMETIC
!              (AS OPPOSED TO INTEGER ARITHMETIC)
!              IS THE MORE NATURAL MODE FOR DOING
!              DATA ANALYSIS.
!     REFERENCES--HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGE 95.
!               --JOHNSON AND KOTZ, DISCRETE
!                 DISTRIBUTIONS, 1969, PAGES 122-142.
!               --FELLER, AN INTRODUCTION TO PROBABILITY
!                 THEORY AND ITS APPLICATIONS, VOLUME 1,
!                 EDITION 2, 1957, PAGES 155-157, 210.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 929.
!               --KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGES 130-131.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE BINRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99005) N
         RETURN
      ELSEIF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE BINRAN SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99003) P
99003    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSEIF ( Npar<1 ) THEN
         WRITE (ipr,99004)
99004    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE BINRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99005) Npar
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         CALL UNIRAN(1,Istart,g(1))
!
!     CHECK ON THE MAGNITUDE OF P,
!     AND BRANCH TO THE FASTER
!     GENERATION METHOD ACCORDINGLY.
!
         IF ( P<0.1 ) THEN
!
!     IF P IS SMALL,
!     GENERATE N NEGATIVE BINOMIAL NUMBERS
!     BY USING THE FACT THAT THE SUM
!     OF GEOMETRIC VARIATES IS A
!     NEGATIVE BINOMIAL VARIATE.
!
            DO i = 1 , N
               isum = 0
               DO j = 1 , Npar
                  CALL GEORAN(1,P,1,g)
                  ig = g(1) + 0.5
                  isum = isum + ig
               ENDDO
               X(i) = isum
            ENDDO
            GOTO 99999
         ENDIF
      ENDIF
!
!     IF P IS MODERATE OR LARGE,
!     GENERATE N NEGATIVE BINOMIAL NUMBERS
!     USING THE FACT THAT THE
!     WAITING TIME FOR NPAR SUCCESSES IN
!     BERNOULLI TRIALS HAS A
!     NEGATIVE BINOMIAL DISTRIBUTION.
!
      DO i = 1 , N
         isum = 0
         j = 1
         DO
            CALL BINRAN(1,P,1,1,b)
            ib = b(1) + 0.5
            isum = isum + ib
            IF ( isum==Npar ) THEN
               X(i) = j
               EXIT
            ELSE
               j = j + 1
            ENDIF
         ENDDO
      ENDDO
      RETURN
99005 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
!
99999 END SUBROUTINE NBRAN
!*==norcdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE NORCDF(X,Cdf)
      IMPLICIT NONE
!*--NORCDF14149
!*** Start of declarations inserted by SPAG
      REAL b1 , b2 , b3 , b4 , b5 , Cdf , p , t , X , z
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT NORCDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR THE NORMAL (GAUSSIAN)
!              DISTRIBUTION WITH MEAN = 0 AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/SQRT(2*PI))*EXP(-X*X/2).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF.
!     PRINTING--NONE.
!     RESTRICTIONS--NONE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 932, FORMULA 26.2.17.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 40-111.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DATA b1 , b2 , b3 , b4 , b5 , p/.319381530 , -0.356563782 ,       &
     &     1.781477937 , -1.821255978 , 1.330274429 , .2316419/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS.
!     NO INPUT ARGUMENT ERRORS POSSIBLE
!     FOR THIS DISTRIBUTION.
!
!-----START POINT-----------------------------------------------------
!
      z = X
      IF ( X<0.0 ) z = -z
      t = 1.0/(1.0+p*z)
      Cdf = 1.0 - ((0.39894228040143)*EXP(-0.5*z*z))                    &
     &      *(b1*t+b2*t**2+b3*t**3+b4*t**4+b5*t**5)
      IF ( X<0.0 ) Cdf = 1.0 - Cdf
!
      END SUBROUTINE NORCDF
!*==norout.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE NOROUT(X,N)
      IMPLICIT NONE
!*--NOROUT14213
!*** Start of declarations inserted by SPAG
      REAL ai , an , anm1 , anm2 , anm3 , anm4 , anm5 , cdf , hold ,    &
     &     res , s , s1 , s13 , s14 , s2 , s23 , s24 , s3 , s4 , ssq
      REAL ssq1 , ssq13 , ssq14 , ssq2 , ssq23 , ssq24 , ssq3 , ssq4 ,  &
     &     st1 , st2 , st3 , st4 , st5 , st6 , st7 , st8 , st9 , stres ,&
     &     sum , sum4
      REAL WS , X , xb , xb1 , xb13 , xb14 , xb2 , xb23 , xb24 , xb3 ,  &
     &     xb4 , xline , XPOs , Y
      INTEGER i , icount , iflag , ipr , irev , iupper , j , mx , N ,   &
     &        nm1 , nm2 , nm3 , nm4 , nm5
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT NOROUT
!
!     PURPOSE--THIS SUBROUTINE PERFORMS A NORMAL OUTLIER ANALYSIS
!              ON THE DATA IN THE INPUT VECTOR X.
!              THIS ANALYSIS CONSISTS OF--
!              1) VARIOUS NORMAL OUTLIER STATISTICS;
!              2) VARIOUS PARTIAL SAMPLE MEANS
!              3) VARIOUS PARTIAL SAMPLE STANDARD DEVIATIONS;
!              4) THE FIRST 40 AND LAST 40 ORDERED OBSERVATIONS;
!              5) A LINE PLOT; AND
!              6) A NORMAL PROBABILITY PLOT.
!              WHEN THE FIRST 40 AND LAST 40 ORDERED OBSERVATIONS
!              ARE PRINTED OUT, ALSO INCLUDED FOR EACH
!              OF THE 40+40 = 80 LISTED DATA VALUES
!              IS THE CORRESPONDING RESIDUAL ABOUT
!              THE (FULL) SAMPLE MEAN,
!              THE STANDARDIZED RESIDUAL,
!              THE NORMAL N(0,1) VALUE FOR THE STANDARDIZED
!              RESIDUAL,
!              AND THE POSITION NUMBER
!              IN THE ORIGINAL DATA VECTOR X.
!              THIS LAST PIECE OF INFORMATION ALLOWS
!              THE DATA ANALYST TO EASILY LOCATE
!              BACK IN THE ORIGINAL DATA VECTOR .
!              A SUSPECTED OUTLIER OR OTHERWISE
!              INTERESTING OBSERVATION.
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS.
!                      N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--4 PAGES OF AUTOMATIC PRINTOUT--
!             1) VARIOUS NORMAL OUTLIER STATISTICS;
!             2) VARIOUS PARTIAL SAMPLE MEANS
!             3) VARIOUS PARTIAL SAMPLE STANDARD DEVIATIONS;
!             4) THE FIRST 40 AND LAST 40 ORDERED OBSERVATIONS;
!             5) A LINE PLOT; AND
!             6) A NORMAL PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORTP, NORCDF, NORPLT,
!                                         SORT, UNIMED, NORPPF, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     WRITE OUT THE FIRST 40 AND LAST 40 ORDERED OBSERVATIONS,
!     INCLUDING THEIR RESIDUALS ABOUT THE (FULL) SAMPLE MEAN,
!     THE STANDARDIZED RESIDUALS,
!     THE NORMAL N(0,1) CUMULATIVE DISTRIBUTION FUNCTION VALUE
!     OF THE STANDARDIZED RESIDUAL, AND
!     THE POSITION NUMBER IN THE ORIGINAL DATA VECTOR X.
!     REFERENCES--GRUBBS, TECHNOMETRICS, 1969, PAGES 1-21
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 blank , hyphen , alphai , alphax
      CHARACTER*4 iline1
      CHARACTER*4 iline2
!
      DIMENSION X(1)
      DIMENSION Y(7500) , XPOs(7500)
      DIMENSION iline1(130) , iline2(130)
      DIMENSION xline(13)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (XPOs(1),WS(7501))
!
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE NOROUT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE NORO&
     &UT SUBROUTINE HAS THE VALUE 1 *****')
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE NOROUT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      nm1 = N - 1
         nm2 = N - 2
         nm3 = N - 3
         nm4 = N - 4
         nm5 = N - 5
         an = N
         anm1 = nm1
         anm2 = nm2
         anm3 = nm3
         anm4 = nm4
         anm5 = nm5
!
!     SORT THE DATA AND ALSO CARRY ALONG THE OBSERVATION NUMBER--THAT IS,
!     THE  POSITION IN THE ORIGINAL DATA SET OF THE I-TH ORDER STATISTIC
!
         CALL SORTP(X,N,Y,XPOs)
!
!     COMPUTE PARTIAL SAMPLE MEANS
!
         sum = 0.0
         DO i = 3 , nm2
            sum = sum + Y(i)
         ENDDO
         xb23 = sum/anm4
         xb13 = (sum+Y(2))/anm3
         xb24 = (sum+Y(nm1))/anm3
         xb3 = (sum+Y(1)+Y(2))/anm2
         xb2 = (sum+Y(nm1)+Y(N))/anm2
         xb14 = (sum+Y(2)+Y(nm1))/anm2
         xb4 = (sum+Y(1)+Y(2)+Y(nm1))/anm1
         xb1 = (sum+Y(2)+Y(nm1)+Y(N))/anm1
         xb = (sum+Y(1)+Y(2)+Y(nm1)+Y(N))/an
!
!     COMPUTE PARTIAL SUMS OF SQUARED DEVIATIONS
!     ABOUT THE PARTIAL SAMPLE MEANS
!
         ssq = 0.0
         ssq1 = 0.0
         ssq4 = 0.0
         ssq14 = 0.0
         ssq2 = 0.0
         ssq3 = 0.0
         ssq24 = 0.0
         ssq13 = 0.0
         ssq23 = 0.0
         DO i = 1 , N
            ssq = ssq + (Y(i)-xb)**2
         ENDDO
         DO i = 2 , N
            ssq1 = ssq1 + (Y(i)-xb1)**2
         ENDDO
         DO i = 1 , nm1
            ssq4 = ssq4 + (Y(i)-xb4)**2
         ENDDO
         DO i = 2 , nm1
            ssq14 = ssq14 + (Y(i)-xb14)**2
         ENDDO
         DO i = 3 , N
            ssq2 = ssq2 + (Y(i)-xb2)**2
         ENDDO
         DO i = 1 , nm2
            ssq3 = ssq3 + (Y(i)-xb3)**2
         ENDDO
         DO i = 3 , nm1
            ssq24 = ssq24 + (Y(i)-xb24)**2
         ENDDO
         DO i = 2 , nm2
            ssq13 = ssq13 + (Y(i)-xb13)**2
         ENDDO
         DO i = 3 , nm2
            ssq23 = ssq23 + (Y(i)-xb23)**2
         ENDDO
!
!     COMPUTE PARTIAL SAMPLE STANDARD DEVIATIONS
!
         s = SQRT(ssq/anm1)
         s1 = SQRT(ssq1/anm2)
         s4 = SQRT(ssq4/anm2)
         s14 = SQRT(ssq14/anm3)
         s2 = SQRT(ssq2/anm3)
         s3 = SQRT(ssq3/anm3)
         s24 = SQRT(ssq24/anm4)
         s13 = SQRT(ssq13/anm4)
         s23 = SQRT(ssq23/anm5)
!
!     COMPUTE OUTLIER STATISTICS
!     OMIT NO OBSERVATIONS, TEST FOR X(1)
         st1 = (xb-Y(1))/s
!     OMIT NO OBSERVATIONS, TEST FOR X(N)
         st2 = (Y(N)-xb)/s
!     OMIT NO OBSERVATIONS, TEST FOR X(1) AND X(N) SIMULTANEOUSLY
         st3 = (Y(N)-Y(1))/s
!     OMIT X(1), TEST FOR X(2)
         st4 = ssq2/ssq
!     OMIT X(N), TEST FOR X(N-1)
         st5 = ssq3/ssq
!     OMIT X(1) AND X(N), TEST FOR X(2)
         st6 = (xb14-Y(2))/s14
!     OMIT X(1) AND X(N), TEST FOR X(N-1)
         st7 = (Y(nm1)-xb14)/s14
!     OMIT X(1) AND X(N), TEST FOR X(2) AND X(N-1)
         st8 = (Y(nm1)-Y(2))/s14
         sum4 = 0.0
         DO i = 2 , nm2
            sum4 = sum4 + (Y(i)-xb14)**4
         ENDDO
         st9 = (an-2.0)*sum4/(ssq14**2)
         st9 = st9 + 3.0
!
!     COMPUTE THE LINE PLOT WHICH SHOWS THE DISTRIBUTION OF THE OBSERVED
!     VALUES IN TERMS OF MULTIPLES OF SAMPLE STANDARD DEVIATIONS AWAY FROM
!     THE SAMPLE MEAN
!
         DO i = 1 , 130
            iline1(i) = blank
            iline2(i) = blank
         ENDDO
         icount = 0
         DO i = 1 , N
            mx = 10.0*(((X(i)-xb)/s)+6.0) + 0.5
            mx = mx + 7
            IF ( mx<7 .OR. mx>127 ) icount = icount + 1
            IF ( mx>=7 .AND. mx<=127 ) iline1(mx) = alphax
         ENDDO
         DO i = 7 , 127
            iline2(i) = hyphen
         ENDDO
         DO i = 7 , 127 , 10
            iline2(i) = alphai
         ENDDO
         xline(7) = xb
         DO i = 1 , 6
            irev = 13 - i + 1
            ai = i
            xline(i) = xb - (7.0-ai)*s
            xline(irev) = xb + (7.0-ai)*s
         ENDDO
!
!     WRITE EVERYTHING OUT
!
!     WRITE OUT THE OUTLIER STATISTICS
!
         WRITE (ipr,99041)
         WRITE (ipr,99005)
99005    FORMAT (' ',48X,'NORMAL OUTLIER ANALYSIS')
         WRITE (ipr,99042)
         WRITE (ipr,99006) N
99006    FORMAT (' ',46X,'(THE SAMPLE SIZE N = ',I5,')')
         WRITE (ipr,99042)
         WRITE (ipr,99007)
99007    FORMAT (' ',39X,                                               &
     &           'REFERENCE--GRUBBS, TECHNOMETRICS, 1969, PAGES 1-21')
         DO i = 1 , 6
            WRITE (ipr,99042)
         ENDDO
         WRITE (ipr,99008)
99008    FORMAT (' ',49X,'OUTLIER STATISTICS')
         WRITE (ipr,99042)
         WRITE (ipr,99042)
         WRITE (ipr,99009)
99009    FORMAT (' ',                                                   &
     &'    OMIT             TEST                    FORM                &
     &  VALUE       PSEUDO-SAMPLE SIZE            TABLE')
         WRITE (ipr,99010)
99010    FORMAT (' ',                                                   &
     &'AS AN OUTLIER    AS AN OUTLIER           OF STATISTIC           O&
     &F STATISTIC   FOR TABLE LOOK-UP           REFERENCE')
         WRITE (ipr,99042)
         WRITE (ipr,99011) st1 , N
99011    FORMAT (' ',                                                   &
     &'    NONE             X(1)              (XBAR - X(1))/S           &
     &',F8.4,'           N = ',I5,'     GRUBBS, TECH., 1969, P.  4')
         WRITE (ipr,99012) st2 , N
99012    FORMAT (' ',                                                   &
     &'    NONE             X(N)              (X(N) - XBAR)/S           &
     &',F8.4,'           N = ',I5,'     GRUBBS, TECH., 1969, P.  4')
         WRITE (ipr,99013) st3 , N
99013    FORMAT (' ',                                                   &
     &'    NONE         X(1) AND X(N)             RANGE/S               &
     &',F8.4,'           N = ',I5,'     GRUBBS, TECH., 1969, P.  8')
         WRITE (ipr,99014) st4 , N
99014    FORMAT (' ',                                                   &
     &'    X(1)             X(2)               SSQD(1,2)/SSQD           &
     &',F8.4,'           N = ',I5,'     GRUBBS, TECH., 1969, P. 11')
         WRITE (ipr,99015) st5 , N
99015    FORMAT (' ',                                                   &
     &'    X(N)            X(N-1)             SSQD(N-1,N)/SSQD          &
     &',F8.4,'           N = ',I5,'     GRUBBS, TECH., 1969, P. 11')
         WRITE (ipr,99016) st6 , nm2
99016    FORMAT (' ',                                                   &
     &'X(1) AND X(N)        X(2)          (XBAR(1,N) - X(2))/S(1,N)     &
     &',F8.4,'         N-2 = ',I5,'     GRUBBS, TECH., 1969, P.  4')
         WRITE (ipr,99017) st7 , nm2
99017    FORMAT (' ',                                                   &
     &'X(1) AND X(N)       X(N-1)        (X(N-1) - XBAR(1,N))/S(1,N)    &
     &',F8.4,'         N-2 = ',I5,'     GRUBBS, TECH., 1969, P.  4')
         WRITE (ipr,99018) st8 , nm2
99018    FORMAT (' ',                                                   &
     &'X(1) AND X(N)   X(2) AND X(N-1)       RANGE(1,N)/S(1,N)          &
     &',F8.4,'         N-2 = ',I5,'     GRUBBS, TECH., 1969, P.  8')
         WRITE (ipr,99019) st9 , nm2
99019    FORMAT (' ',                                                   &
     &'X(1) AND X(N)   X(2) AND X(N-1)      SAMPLE KURTOSIS(1,N)        &
     &',F8.4,'         N-2 = ',I5,'     GRUBBS, TECH., 1969, P. 14')
         DO i = 1 , 10
            WRITE (ipr,99042)
         ENDDO
!
!     WRITE OUT THE PARTIAL SAMPLE MEANS
!     AND THE PARTIAL SAMPLE STANDARD DEVIATIONS.
!
         WRITE (ipr,99020)
99020    FORMAT (' ',30X,                                               &
     &     'PARTIAL SAMPLE MEANS AND PARTIAL SAMPLE STANDARD DEVIATIONS'&
     &     )
         WRITE (ipr,99042)
         WRITE (ipr,99042)
         WRITE (ipr,99021)
99021    FORMAT (' ',                                                   &
     &'            OMIT               PARTIAL SAMPLE      PARTIAL SAMPLE&
     &')
         WRITE (ipr,99022)
99022    FORMAT (' ',                                                   &
     &'        AS AN OUTLIER               MEAN         STANDARD DEVIATI&
     &ON')
         WRITE (ipr,99042)
         WRITE (ipr,99023) xb , s
99023    FORMAT (' ','            NONE             ',E15.8,5X,E15.8)
         WRITE (ipr,99024) xb1 , s1
99024    FORMAT (' ','            X(1)             ',E15.8,5X,E15.8)
         WRITE (ipr,99025) xb4 , s4
99025    FORMAT (' ','            X(N)             ',E15.8,5X,E15.8)
         WRITE (ipr,99026) xb14 , s14
99026    FORMAT (' ','       X(1) AND X(N)         ',E15.8,5X,E15.8)
         WRITE (ipr,99027) xb2 , s2
99027    FORMAT (' ','       X(1) AND X(2)         ',E15.8,5X,E15.8)
         WRITE (ipr,99028) xb3 , s3
99028    FORMAT (' ','      X(N-1) AND X(N)        ',E15.8,5X,E15.8)
         WRITE (ipr,99029) xb24 , s24
99029    FORMAT (' ','    X(1), X(2), AND X(N)     ',E15.8,5X,E15.8)
         WRITE (ipr,99030) xb13 , s13
99030    FORMAT (' ','   X(1), X(N-1), AND X(N)    ',E15.8,5X,E15.8)
         WRITE (ipr,99031) xb23 , s23
99031    FORMAT (' ','X(1), X(2), X(N-1), AND X(N) ',E15.8,5X,E15.8)
!
!     WRITE OUT THE FIRST 40 AND LAST 40 ORDERED OBSERVATIONS,
!     INCLUDING THEIR RESIDUALS ABOUT THE (FULL) SAMPLE MEAN,
!     THE STANDARDIZED RESIDUALS,
!     THE NORMAL N(0,1) CUMULATIVE DISTRIBUTION FUNCTION VALUE
!     OF THE STANDARDIZED RESIDUAL, AND
!     THE POSITION NUMBER IN THE ORIGINAL DATA VECTOR X.
!
         WRITE (ipr,99041)
         WRITE (ipr,99032)
99032    FORMAT (' ',                                                   &
     &'ORDER STATISTICS, RESIDUALS ABOUT THE SAMPLE MEAN, STANDARDIZED R&
     &ESIDUALS, AND NORMAL(0,1) CUMULATIVE DISTRIBUTION FUNCTION VALUES'&
     &)
         WRITE (ipr,99042)
         WRITE (ipr,99042)
         WRITE (ipr,99033)
99033    FORMAT (' ',                                                   &
     &'  INDEX       ORDERED        RESIDUALS        STANDARDIZED       &
     &NORMAL(0,1)        OBSERVATION')
         WRITE (ipr,99034)
99034    FORMAT (' ',                                                   &
     &'            OBSERVATIONS     ABOUT THE         RESIDUALS      CDF&
     & VALUES OF THE       NUMBER')
         WRITE (ipr,99035)
99035    FORMAT (' ',                                                   &
     &'                            SAMPLE MEAN                         S&
     &TANDARDIZED')
         WRITE (ipr,99036)
99036    FORMAT (' ',                                                   &
     &'                                                                 &
     &RESIDUALS')
         WRITE (ipr,99042)
         IF ( N<=80 ) THEN
            DO i = 1 , N
               res = Y(i) - xb
               stres = res/s
               CALL NORCDF(stres,cdf)
               WRITE (ipr,99043) i , Y(i) , res , stres , cdf , XPOs(i)
               iflag = i - (i/10)*10
               IF ( iflag==0 ) WRITE (ipr,99042)
            ENDDO
         ELSE
            DO i = 1 , 80
               IF ( i<=40 ) j = i
               IF ( i>=41 ) j = i + N - 80
               res = Y(j) - xb
               stres = res/s
               CALL NORCDF(stres,cdf)
               WRITE (ipr,99043) j , Y(j) , res , stres , cdf , XPOs(j)
               iflag = i - (i/10)*10
               IF ( iflag==0 ) WRITE (ipr,99042)
            ENDDO
         ENDIF
         DO i = 1 , 10
            WRITE (ipr,99042)
         ENDDO
!
!     WRITE OUT THE LINE PLOT SHOWING THE DEVIATIONS
!     OF THE OBSERVATIONS ABOUT THE (FULL) SAMPLE MEAN
!     IN TERMS OF MULTIPLES OF THE (FULL) SAMPLE STANDARD
!     DEVIATION.
!
         WRITE (ipr,99037)
99037    FORMAT (' ',                                                   &
     &'LINE PLOT SHOWING THE DISTRIBUTION OF THE OBSERVATIONS ABOUT THE &
     &SAMPLE MEAN IN TERMS OF MULTIPLES OF THE SAMPLE STANDARD DEVIATION&
     &')
         WRITE (ipr,99042)
         WRITE (ipr,99042)
         WRITE (ipr,99044) (iline1(i),i=1,130)
         WRITE (ipr,99044) (iline2(i),i=1,130)
         WRITE (ipr,99038)
99038    FORMAT (' ',                                                   &
     &'     -6        -5        -4        -3        -2        -1        &
     & 0         1         2         3         4         5         6')
         WRITE (ipr,99039) (xline(i),i=1,13)
99039    FORMAT (' ',13F10.4)
         WRITE (ipr,99042)
         WRITE (ipr,99040) icount
99040    FORMAT (' ',10X,I5,                                            &
     &' OBSERVATIONS WERE IN EXCESS OF 6 SAMPLE STANDARD DEVIATIONS FROM&
     & THE SAMPLE MEAN AND SO WERE NOT PLOTTED')
!
!     WRITE OUT A NORMAL PROBABILITY PLOT
!
         CALL NORPLT(Y,N)
      ENDIF
!
99041 FORMAT ('1')
99042 FORMAT (' ')
99043 FORMAT (' ',I5,4X,E15.8,1X,E15.8,7X,F7.2,11X,F8.5,11X,F7.0)
99044 FORMAT (' ',130A1)
!
      END SUBROUTINE NOROUT
!*==norpdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE NORPDF(X,Pdf)
      IMPLICIT NONE
!*--NORPDF14679
!*** Start of declarations inserted by SPAG
      REAL c , Pdf , X
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT NORPDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PROBABILITY DENSITY
!              FUNCTION VALUE FOR THE NORMAL (GAUSSIAN)
!              DISTRIBUTION WITH MEAN = 0 AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/SQRT(2*PI))*EXP(-X*X/2).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE PROBABILITY DENSITY
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--PDF    = THE SINGLE PRECISION PROBABILITY
!                                DENSITY FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PROBABILITY DENSITY
!             FUNCTION VALUE PDF.
!     PRINTING--NONE.
!     RESTRICTIONS--NONE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 40-111.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DATA c/.3989422804/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS.
!     NO INPUT ARGUMENT ERRORS POSSIBLE
!     FOR THIS DISTRIBUTION.
!
!-----START POINT-----------------------------------------------------
!
      Pdf = c*EXP(-(X*X)/2.0)
!
      END SUBROUTINE NORPDF
!*==norplt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE NORPLT(X,N)
      IMPLICIT NONE
!*--NORPLT14735
!*** Start of declarations inserted by SPAG
      REAL an , cc , hold , sum1 , sum2 , sum3 , tau , W , wbar , WS ,  &
     &     X , Y , ybar , yint , yslope
      INTEGER i , ipr , iupper , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT NORPLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES A NORMAL (GAUSSIAN)
!              PROBABILITY PLOT.
!              THE PROTOTYPE NORMAL DISTRIBUTION USED HEREIN
!              HAS MEAN = 0 AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/SQRT(2*PI)) * EXP(-X*X/2).
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE NORMAL PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE NORMAL DISTRIBUTION.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!     OUTPUT--A ONE-PAGE NORMAL PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, NORPPF, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --FILLIBEN, 'THE PROBABILITY PLOT CORRELATION COEFFICIENT
!                 TEST FOR NORMALITY', TECHNOMETRICS, 1975, PAGES 111-117.
!               --RYAN AND JOINER, 'NORMAL PROBABILITY PLOTS AND TESTS
!                 FOR NORMALITY'  PENNSYLVANIA
!                 STATE UNIVERSITY REPORT.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 40-111.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
!
      DATA tau/1.43218641/
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE NORPLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE NORP&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE NORPLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     COMPUTE NORMAL ORDER STATISTIC MEDIANS
!
         DO i = 1 , N
            CALL NORPPF(W(i),W(i))
         ENDDO
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         WRITE (ipr,99005) tau , N
!
99005    FORMAT (' ','NORMAL PROBABILITY PLOT (TAU = ',E15.8,')',56X,   &
     &           'THE SAMPLE SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
         ENDDO
         ybar = sum1/an
         wbar = 0.0
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + W(i)*Y(i)
            sum3 = sum3 + W(i)*W(i)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99006) cc , yint , yslope
99006    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
!
      END SUBROUTINE NORPLT
!*==norppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE NORPPF(P,Ppf)
      IMPLICIT NONE
!*--NORPPF14899
!*** Start of declarations inserted by SPAG
      REAL aden , anum , P , p0 , p1 , p2 , p3 , p4 , Ppf , q0 , q1 ,   &
     &     q2 , q3 , q4 , r , t
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT NORPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE NORMAL (GAUSSIAN)
!              DISTRIBUTION WITH MEAN = 0 AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/SQRT(2*PI))*EXP(-X*X/2).
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT
!             FUNCTION VALUE PPF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0 AND 1.0, EXCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--ODEH AND EVANS, THE PERCENTAGE POINTS
!                 OF THE NORMAL DISTRIBUTION, ALGORTIHM 70,
!                 APPLIED STATISTICS, 1974, PAGES 96-97.
!               --EVANS, ALGORITHMS FOR MINIMAL DEGREE
!                 POLYNOMIAL AND RATIONAL APPROXIMATION,
!                 M. SC. THESIS, 1972, UNIVERSITY
!                 OF VICTORIA, B. C., CANADA.
!               --HASTINGS, APPROXIMATIONS FOR DIGITAL
!                 COMPUTERS, 1955, PAGES 113, 191, 192.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 933, FORMULA 26.2.23.
!               --FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 40-111.
!               --THE KELLEY STATISTICAL TABLES, 1948.
!               --OWEN, HANDBOOK OF STATISTICAL TABLES,
!                 1962, PAGES 3-16.
!               --PEARSON AND HARTLEY, BIOMETRIKA TABLES
!                 FOR STATISTICIANS, VOLUME 1, 1954,
!                 PAGES 104-113.
!     COMMENTS--THE CODING AS PRESENTED BELOW
!               IS ESSENTIALLY IDENTICAL TO THAT
!               PRESENTED BY ODEH AND EVANS
!               AS ALGORTIHM 70 OF APPLIED STATISTICS.
!               THE PRESENT AUTHOR HAS MODIFIED THE
!               ORIGINAL ODEH AND EVANS CODE WITH ONLY
!               MINOR STYLISTIC CHANGES.
!             --AS POINTED OUT BY ODEH AND EVANS
!               IN APPLIED STATISTICS,
!               THEIR ALGORITHM REPRESENTES A
!               SUBSTANTIAL IMPROVEMENT OVER THE
!               PREVIOUSLY EMPLOYED
!               HASTINGS APPROXIMATION FOR THE
!               NORMAL PERCENT POINT FUNCTION--
!               THE ACCURACY OF APPROXIMATION
!               BEING IMPROVED FROM 4.5*(10**-4)
!               TO 1.5*(10**-8).
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --OCTOBER   1976.
!
!---------------------------------------------------------------------
!
      DATA p0 , p1 , p2 , p3 , p4/ - .322232431088 , -1.0 ,             &
     &     -.342242088547 , -.204231210245E-1 , -.453642210148E-4/
      DATA q0 , q1 , q2 , q3 , q4/.993484626060E-1 , .588581570495 ,    &
     &     .531103462366 , .103537752850 , .38560700634E-2/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE NORPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
!
!-----START POINT-----------------------------------------------------
!
      ELSEIF ( P/=0.5 ) THEN
!
         r = P
         IF ( P>0.5 ) r = 1.0 - r
         t = SQRT(-2.0*ALOG(r))
         anum = ((((t*p4+p3)*t+p2)*t+p1)*t+p0)
         aden = ((((t*q4+q3)*t+q2)*t+q1)*t+q0)
         Ppf = t + (anum/aden)
         IF ( P<0.5 ) Ppf = -Ppf
         GOTO 99999
      ENDIF
      Ppf = 0.0
      RETURN
!
99999 END SUBROUTINE NORPPF
!*==norran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE NORRAN(N,Iseed,X)
      IMPLICIT NONE
!*--NORRAN15024
!*** Start of declarations inserted by SPAG
      REAL arg1 , arg2 , pi , sqrt1 , u1 , u2 , X , y , z1 , z2
      INTEGER i , ip1 , ipr , Iseed , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT NORRAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE THE NORMAL (GAUSSIAN)
!              DISTRIBUTION WITH MEAN = 0 AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/SQRT(2*PI))*EXP(-X*X/2).
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE NORMAL DISTRIBUTION
!             WITH MEAN = 0 AND STANDARD DEVIATION = 1.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG, SQRT, SIN, COS.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     METHOD--BOX-MULLER ALGORITHM.
!     REFERENCES--BOX AND MULLER, 'A NOTE ON THE GENERATION
!                 OF RANDOM NORMAL DEVIATES', JOURNAL OF THE
!                 ASSOCIATION FOR COMPUTING MACHINERY, 1958,
!                 PAGES 610-611.
!               --TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 33-34.
!               --HAMMERSLEY AND HANDSCOMB, MONTE CARLO METHODS,
!                 1964, PAGE 39.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 40-111.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82.6
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --JULY      1976.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
      DIMENSION y(2)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
      ipr = 6
!
!-----DATA STATEMENTS-------------------------------------------------
!
      DATA pi/3.14159265359/
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE NORRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
!
!     GENERATE N UNIFORM (0,1) RANDOM NUMBERS;
!     THEN GENERATE 2 ADDITIONAL UNIFORM (0,1) RANDOM NUMBERS
!     (TO BE USED BELOW IN FORMING THE N-TH NORMAL
!     RANDOM NUMBER WHEN THE DESIRED SAMPLE SIZE N
!     HAPPENS TO BE ODD).
!
         CALL UNIRAN(N,Iseed,X)
         CALL UNIRAN(2,Iseed,y)
!
!     GENERATE N NORMAL RANDOM NUMBERS
!     USING THE BOX-MULLER METHOD.
!
         DO i = 1 , N , 2
            ip1 = i + 1
            u1 = X(i)
            IF ( i==N ) THEN
               u2 = y(2)
            ELSE
               u2 = X(ip1)
            ENDIF
            arg1 = -2.0*ALOG(u1)
            arg2 = 2.0*pi*u2
            sqrt1 = SQRT(arg1)
            z1 = sqrt1*COS(arg2)
            z2 = sqrt1*SIN(arg2)
            X(i) = z1
            IF ( i/=N ) X(ip1) = z2
         ENDDO
      ENDIF
!
      END SUBROUTINE NORRAN
!*==norsf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE NORSF(P,Sf)
      IMPLICIT NONE
!*--NORSF15157
!*** Start of declarations inserted by SPAG
      REAL c , P , pdf , ppf , Sf
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT NORSF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE SPARSITY
!              FUNCTION VALUE FOR THE NORMAL (GAUSSIAN)
!              DISTRIBUTION WITH MEAN = 0 AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/SQRT(2*PI))*EXP(-X*X/2).
!              NOTE THAT THE SPARSITY FUNCTION OF A DISTRIBUTION
!              IS THE DERIVATIVE OF THE PERCENT POINT FUNCTION,
!              AND ALSO IS THE RECIPROCAL OF THE PROBABILITY
!              DENSITY FUNCTION (BUT IN UNITS OF P RATHER THAN X).
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                AT WHICH THE SPARSITY
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--SF     = THE SINGLE PRECISION
!                                SPARSITY FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION SPARSITY
!             FUNCTION VALUE SF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0 AND 1.0, EXCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NORPPF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 40-111.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DATA c/.3989422804/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE NORSF  SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         CALL NORPPF(P,ppf)
         pdf = c*EXP(-(ppf*ppf)/2.0)
         Sf = 1.0/pdf
      ENDIF
!
      END SUBROUTINE NORSF
!*==parcdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PARCDF(X,Gamma,Cdf)
      IMPLICIT NONE
!*--PARCDF15236
!*** Start of declarations inserted by SPAG
      REAL Cdf , Gamma , X
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PARCDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR THE PARETO
!              DISTRIBUTION WITH SINGLE PRECISION
!              TAIL LENGTH PARAMETER = GAMMA.
!              THE PARETO DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL X GREATER THAN
!              OR EQUAL TO 1,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = GAMMA / (X**(GAMMA+1)).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE
!                                AT WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!                                X SHOULD BE GREATER THAN
!                                OR EQUAL TO 1.
!                     --GAMMA  = THE SINGLE PRECISION VALUE
!                                OF THE TAIL LENGTH PARAMETER.
!                                GAMMA SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF FOR THE PARETO
!             DISTRIBUTION WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--GAMMA SHOULD BE POSITIVE.
!                 --X SHOULD BE GREATER THAN
!                   OR EQUAL TO 1.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 233-249.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGE 102.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( X<1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE PARC&
     &DF SUBROUTINE IS LESS THAN 1.0 *****')
         WRITE (ipr,99003) X
         Cdf = 0.0
         RETURN
      ELSEIF ( Gamma<=0.0 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE PARCDF SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99003) Gamma
         Cdf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         Cdf = 1.0 - (X**(-Gamma))
      ENDIF
99003 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
      END SUBROUTINE PARCDF
!*==parplt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PARPLT(X,N,Gamma)
      IMPLICIT NONE
!*--PARPLT15321
!*** Start of declarations inserted by SPAG
      REAL an , cc , Gamma , hold , pp0025 , pp025 , pp975 , pp9975 ,   &
     &     q , sum1 , sum2 , sum3 , tau , W , wbar , WS , X , Y , ybar ,&
     &     yint
      REAL yslope
      INTEGER i , ipr , iupper , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PARPLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES A PARETO
!              PROBABILITY PLOT
!              (WITH TAIL LENGTH PARAMETER VALUE = GAMMA).
!              THE PROTOTYPE PARETO DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL X EQUAL TO
!              OR GREATER THAN 1,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = GAMMA / (X**(GAMMA+1)).
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE PARETO PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE  PARETO DISTRIBUTION
!              WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --GAMMA  = THE SINGLE PRECISION VALUE OF THE
!                                TAIL LENGTH PARAMETER.
!                                GAMMA SHOULD BE POSITIVE.
!     OUTPUT--A ONE-PAGE PARETO PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!                 --GAMMA SHOULD BE POSITIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 233-249.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE PARPLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE PARP&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         IF ( Gamma<=0.0 ) THEN
            WRITE (ipr,99004)
99004       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE PARPLT SUBROU&
     &TINE IS NON-POSITIVE *****')
            WRITE (ipr,99005) Gamma
99005       FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,    &
     &              ' *****')
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99006) hold
99006       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE PARPLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     COMPUTE PARETO DISTRIBUTION ORDER STATISTIC MEDIANS
!
         DO i = 1 , N
            W(i) = (1.0-W(i))**(-1.0/Gamma)
         ENDDO
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     COMPUTE THE TAIL LENGTH MEASURE OF THE DISTRIBUTION.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         q = .9975
         pp9975 = (1.0-q)**(-1.0/Gamma)
         q = .0025
         pp0025 = (1.0-q)**(-1.0/Gamma)
         q = .975
         pp975 = (1.0-q)**(-1.0/Gamma)
         q = .025
         pp025 = (1.0-q)**(-1.0/Gamma)
         tau = (pp9975-pp0025)/(pp975-pp025)
         WRITE (ipr,99007) Gamma , tau , N
!
99007    FORMAT (' ',                                                   &
     &           'PARETO PROBABILITY PLOT WITH EXPONENT PARAMETER = ',  &
     &           E17.10,1X,'(TAU = ',E15.8,')',11X,                     &
     &           'THE SAMPLE SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         sum2 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
            sum2 = sum2 + W(i)
         ENDDO
         ybar = sum1/an
         wbar = sum2/an
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + (Y(i)-ybar)*(W(i)-wbar)
            sum3 = sum3 + (W(i)-wbar)*(W(i)-wbar)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99008) cc , yint , yslope
99008    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
!
      END SUBROUTINE PARPLT
!*==parppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PARPPF(P,Gamma,Ppf)
      IMPLICIT NONE
!*--PARPPF15510
!*** Start of declarations inserted by SPAG
      REAL Gamma , P , Ppf
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PARPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE PARETO
!              DISTRIBUTION WITH SINGLE PRECISION
!              TAIL LENGTH PARAMETER = GAMMA.
!              THE PARETO DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL X GREATER THAN
!              OR EQUAL TO 1,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = GAMMA / (X**(GAMMA+1)).
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 (INCLUSIVELY)
!                                AND 1.0 (EXCLUSIVELY))
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!                     --GAMMA  = THE SINGLE PRECISION VALUE
!                                OF THE TAIL LENGTH PARAMETER.
!                                GAMMA SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT FUNCTION .
!             VALUE PPF FOR THE PARETO DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--GAMMA SHOULD BE POSITIVE.
!                 --P SHOULD BE BETWEEN 0.0 (INCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 233-249.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGE 102.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE PARPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99003) P
         Ppf = 0.0
         RETURN
      ELSEIF ( Gamma<=0.0 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE PARPPF SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99003) Gamma
         Ppf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         Ppf = (1.0-P)**(-1.0/Gamma)
      ENDIF
99003 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
      END SUBROUTINE PARPPF
!*==parran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PARRAN(N,Gamma,Iseed,X)
      IMPLICIT NONE
!*--PARRAN15598
!*** Start of declarations inserted by SPAG
      REAL Gamma , X
      INTEGER i , ipr , Iseed , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PARRAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE PARETO DISTRIBUTION
!              WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!              THE PROTOTYPE PARETO DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL X GREATER THAN
!              OR EQUAL TO 1,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = GAMMA / (X**(GAMMA+1)).
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!                     --GAMMA  = THE SINGLE PRECISION VALUE OF THE
!                                TAIL LENGTH PARAMETER.
!                                GAMMA SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE PARETO DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!                 --GAMMA SHOULD BE POSITIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     REFERENCES--TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 14-15.
!               --HAMMERSLEY AND HANDSCOMB, MONTE CARLO METHODS,
!                 1964, PAGE 36.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 233-249.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGE 104.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82.6
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
      ipr = 6
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE PARRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( Gamma<=0.0 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE PARRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99004) Gamma
99004    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!     GENERATE N UNIFORM (0,1) RANDOM NUMBERS;
!
         CALL UNIRAN(N,Iseed,X)
!
!     GENERATE N PARETO DISTRIBUTION RANDOM NUMBERS
!     USING THE PERCENT POINT FUNCTION TRANSFORMATION METHOD.
!
         DO i = 1 , N
            X(i) = (1.0-X(i))**(-1.0/Gamma)
         ENDDO
      ENDIF
!
      END SUBROUTINE PARRAN
!*==plot10.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
      SUBROUTINE PLOT10(Y,X,Char,N,Ymin,Ymax,Xmin,Xmax,D,Dmin,Dmax,     &
     &                  Yaxid,Xaxid,Plchid)
      IMPLICIT NONE
!*--PLOT1016034
!*** Start of declarations inserted by SPAG
      REAL aim1 , Char , cutoff , D , Dmax , Dmin , hold , Plchid ,     &
     &     ratiox , ratioy , X , x25 , x75 , Xaxid , Xmax , xmid ,      &
     &     Xmin , Y , Yaxid , ylable
      REAL Ymax , Ymin
      INTEGER i , iarg , iflag , ip2 , ipr , j , k , mx , my , N , n2
!*** End of declarations inserted by SPAG
!      DLL_EXPORT PLOT10
!
!     PURPOSE--THIS SUBROUTINE YIELDS A ONE-PAGE PRINTER PLOT
!              OF Y(I) VERSUS X(I):
!              1) WITH SPECIAL PLOT CHARACTERS;
!              2) WITH THE VERTICAL (Y) AXIS MIN AND MAX
!                 AND THE HORIZONTAL (X) AXIS MIN AND MAX
!                 VALUES SPECIFIED BY THE DATA ANALYST;
!              3) WITH ONLY THOSE POINTS (X(I),Y(I)) PLOTTED
!                 FOR WHICH THE CORRESPONDING VALUE OF D(I)
!                 IS BETWEEN THE SPECIFIED VALUES OF DMIN AND DMAX; AND
!              3) WITH HOLLARITH LABELS (AT MOST 6 CHARACTERS)
!                 FOR THE VERTICAL AXIS VARIABLE,
!                 THE HORIZONTAL AXIS VARIABLE, AND
!                 THE PLOTTING CHARACTER VARIABLE
!                 ALSO BEING PROVIDED BY THE DATA ANALYST.
!
!              THE 'SPECIAL PLOTTING CHARACTER' CAPABILITY
!              ALLOWS THE DATA ANALYST TO INCORPORATE INFORMATION
!              FROM A THIRD VARIABLE (ASIDE FROM Y AND X) INTO
!              THE PLOT.
!              THE PLOT CHARACTER USED AT THE I-TH PLOTTING
!              POSITION (THAT IS, AT THE COORDINATE (X(I),Y(I)))
!              WILL BE
!              1 IF CHAR(I) IS BETWEEN  0.5 AND  1.5
!              2 IF CHAR(I) IS BETWEEN  1.5 AND  2.5
!                .
!                .
!                .
!              9 IF CHAR(I) IS BETWEEN  8.5 AND  9.5
!              0 IF CHAR(I) IS BETWEEN  9.5 AND 10.5
!              A IF CHAR(I) IS BETWEEN 10.5 AND 11.5
!              B IF CHAR(I) IS BETWEEN 11.5 AND 12.5
!              C IF CHAR(I) IS BETWEEN 12.5 AND 13.5
!                .
!                .
!                .
!              W IF CHAR(I) IS BETWEEN 32.5 AND 33.5
!              X IF CHAR(I) IS BETWEEN 33.5 AND 34.5
!              Y IF CHAR(I) IS BETWEEN 34.5 AND 35.5
!              Z IF CHAR(I) IS BETWEEN 35.5 AND 36.5
!              X IF CHAR(I) IS ANY VALUE OUTSIDE THE RANGE
!                                       0.5 TO  36.5.
!
!              THE USE OF THE YMIN, YMAX, XMIN, AND XMAX
!              SPECIFICATIONS ALLOWS THE DATA ANALYST
!              TO CONTROL FULLY THE PLOT AXIS LIMITS,
!              SO AS, FOR EXAMPLE, TO ZERO-IN ON AN
!              INTERESTING SUB-REGION OF A PREVIOUS PLOT.
!
!              THE USE OF THE SUBSET DEFINTION VECTOR D
!              GIVES THE DATA ANALYST THE CAPABILITY OF
!              PLOTTING SUBSETS OF THE DATA,
!              WHERE THE SUBSET IS DEFINED
!              BY VALUES IN THE VECTOR D.
!
!              THE USE OF HOLLARITH IDENTIFYING LABELS
!              ALLOWS THE DATA ANALYST TO AUTOMATICALLY
!              HAVE THE PLOTS LABELED.  THIS IS PARTICULARLY
!              USEFUL IN A LARGE ANALYSIS WHEN MANY
!              PLOTS ARE BEING GENERATED.
!
!     INPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED VERTICALLY.
!                    --X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED HORIZONTALLY.
!                    --CHAR   = THE SINGLE PRECISION VECTOR OF
!                               OBSERVATIONS WHICH CONTROL THE
!                               VALUE OF EACH INDIVIDUAL PLOT
!                               CHARACTER.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR Y.
!                    --YMIN   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MINIMUM FOR THE VERTICAL AXIS.
!                    --YMAX   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MAXIMUM FOR THE VERTICAL AXIS.
!                    --XMIN   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MINIMUM FOR THE HORIZONTAL AXIS.
!                    --XMAX   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MAXIMUM FOR THE HORIZONTAL AXIS.
!                    --D      = THE SINGLE PRECISION VECTOR
!                               WHICH 'DEFINES' THE VARIOUS
!                               POSSIBLE SUBSETS.
!                    --DMIN   = THE SINGLE PRECISION VALUE
!                               WHICH DEFINES THE LOWER BOUND
!                               (INCLUSIVELY) OF THE PARTICULAR
!                               SUBSET OF INTEREST TO BE PLOTTED.
!                    --DMAX   = THE SINGLE PRECISION VALUE
!                               WHICH DEFINES THE UPPER BOUND
!                               (INCLUSIVELY) OF THE PARTICULAR
!                               SUBSET OF INTEREST TO BE PLOTTED.
!                    --YAXID  = THE HOLLARITH VALUE
!                               (AT MOST 6 CHARACTERS)
!                               OF THE DESIRED LABEL FOR THE
!                               VERTICAL AXIS VARIABLE.
!                    --XAXID  = THE HOLLARITH VALUE
!                               (AT MOST 6 CHARACTERS)
!                               OF THE DESIRED LABEL FOR THE
!                               HORIZONTAL AXIS VARIABLE.
!                    --PLCHID = THE HOLLARITH VALUE
!                               (AT MOST 6 CHARACTERS)
!                               OF THE DESIRED LABEL FOR THE
!                               PLOTTING CHARACTER VARIABLE.
!     OUTPUT--A ONE-PAGE PRINTER PLOT OF Y(I) VERSUS X(I),
!             WITH SPECIAL PLOT CHARACTERS,
!             WITH SPECIFIED AXIS LIMITS,
!             FOR ONLY OF A SPECIFIED SUBSET OF THE DATA, AND
!             WITH SPECIFIED LABELS.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--VALUES IN THE VERTICAL AXIS VECTOR (Y)
!              WHICH ARE SMALLER THAN YMIN OR LARGER THAN YMAX,
!              OR VALUES IN THE HORIZONTAL AXIS VECTOR (X)
!              WHICH ARE SMALLER THAN XMIN OR LARGER THAN XMAX
!              WILL NOT BE PLOTTED.
!            --FOR A GIVEN DUMMY INDEX I,
!              IF D(I) IS SMALLER THAN DMIN OR LARGER THAN DMAX,
!              THEN THE CORRESPONDING POINT (X(I),Y(I))
!              WILL NOT BE PLOTTED.
!            --VALUES IN THE VERTICAL AXIS VECTOR (Y),
!              THE HORIZONTAL AXIS VECTOR (X),
!              OR THE PLOT CHARACTER VECTOR (CHAR) WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR Y
!              (OR X, OR CHAR) ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR Y
!              (OR X, OR CHAR) FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN Y (OR X, OR CHAR) TO BE
!              PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN Y (OR X, OR CHAR) TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOTC
!              SUBROUTINE.
!     REFERENCES--FILLIBEN, 'STATISTICAL ANALYSIS OF INTERLAB
!                 FATIGUE TIME DATA', UNPUBLISHED MANUSCRIPT
!                 (AVAILABLE FROM AUTHOR)
!                 PRESENTED AT THE 'COMPUTER-ASSISTED DATA
!                 ANALYSIS' SESSION AT THE NATIONAL MEETING
!                 OF THE AMERICAN STATISTICAL ASSOCIATION,
!                 NEW YORK CITY, DECEMBER 27-30, 1973.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JANUARY   1974.
!     UPDATED         --OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --FEBRUARY  1977.
!     UPDATED         --JUNE      1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 IGRaph
      CHARACTER*4 iplotc
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22 , alph31 , alph32
      CHARACTER*4 alph41 , alph42 , alph91 , alph92
      CHARACTER*4 blank , hyphen , alphai , alphax
      CHARACTER*4 alpham , alphaa , alphad , alphan , equal
!
      DIMENSION Y(1)
      DIMENSION X(1)
      DIMENSION D(1)
      DIMENSION Char(1)
      DIMENSION ylable(11)
      DIMENSION iplotc(37)
      COMMON /BLOCK1/ IGRaph(55,130)
!
      DATA sbnam1 , sbnam2/'PLOT' , '10  '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA alph31 , alph32/'THIR' , 'D   '/
      DATA alph41 , alph42/'FOUR' , 'TH  '/
      DATA alph91 , alph92/'FIFT' , 'H   '/
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
      DATA alpham , alphaa , alphad , alphan , equal/'M' , 'A' , 'D' ,  &
     &     'N' , '='/
      DATA iplotc(1) , iplotc(2) , iplotc(3) , iplotc(4) , iplotc(5) ,  &
     &     iplotc(6) , iplotc(7) , iplotc(8) , iplotc(9) , iplotc(10) , &
     &     iplotc(11) , iplotc(12) , iplotc(13) , iplotc(14) ,          &
     &     iplotc(15) , iplotc(16) , iplotc(17) , iplotc(18) ,          &
     &     iplotc(19) , iplotc(20) , iplotc(21) , iplotc(22) ,          &
     &     iplotc(23) , iplotc(24) , iplotc(25) , iplotc(26) ,          &
     &     iplotc(27) , iplotc(28) , iplotc(29) , iplotc(30) ,          &
     &     iplotc(31) , iplotc(32) , iplotc(33) , iplotc(34) ,          &
     &     iplotc(35) , iplotc(36) , iplotc(37)/'1' , '2' , '3' , '4' , &
     &     '5' , '6' , '7' , '8' , '9' , '0' , 'A' , 'B' , 'C' , 'D' ,  &
     &     'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' ,  &
     &     'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' ,  &
     &     'Y' , 'Z' , 'X'/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      WRITE (ipr,99001)
99001 FORMAT ('1')
      IF ( N<1 ) THEN
         WRITE (ipr,99016)
         WRITE (ipr,99017)
         WRITE (ipr,99019) alph41 , alph42 , sbnam1 , sbnam2
         WRITE (ipr,99002) N
99002    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99016)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99016)
            WRITE (ipr,99017)
            WRITE (ipr,99019) alph41 , alph42 , sbnam1 , sbnam2
            WRITE (ipr,99003) N
99003       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99016)
            RETURN
         ELSE
!
            hold = Y(1)
            DO i = 2 , N
               IF ( Y(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99016)
            WRITE (ipr,99017)
            WRITE (ipr,99019) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99020) hold
            WRITE (ipr,99016)
            RETURN
         ENDIF
 50      hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99016)
         WRITE (ipr,99017)
         WRITE (ipr,99019) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99020) hold
         WRITE (ipr,99016)
         RETURN
      ENDIF
 100  hold = Char(1)
      DO i = 2 , N
         IF ( Char(i)/=hold ) GOTO 200
      ENDDO
      WRITE (ipr,99016)
      WRITE (ipr,99018)
      WRITE (ipr,99019) alph31 , alph32 , sbnam1 , sbnam2
      WRITE (ipr,99020) hold
      WRITE (ipr,99016)
 200  hold = D(1)
      DO i = 2 , N
         IF ( D(i)/=hold ) GOTO 300
      ENDDO
      WRITE (ipr,99016)
      WRITE (ipr,99018)
      WRITE (ipr,99019) alph91 , alph92 , sbnam1 , sbnam2
      WRITE (ipr,99020) hold
      WRITE (ipr,99016)
!
 300  DO i = 1 , N
         IF ( Y(i)<cutoff ) GOTO 400
      ENDDO
      WRITE (ipr,99016)
      WRITE (ipr,99017)
      WRITE (ipr,99019) alph11 , alph12 , sbnam1 , sbnam2
      WRITE (ipr,99021)
      WRITE (ipr,99022) cutoff
      WRITE (ipr,99016)
      RETURN
 400  DO i = 1 , N
         IF ( X(i)<cutoff ) GOTO 500
      ENDDO
      WRITE (ipr,99016)
      WRITE (ipr,99017)
      WRITE (ipr,99019) alph21 , alph22 , sbnam1 , sbnam2
      WRITE (ipr,99021)
      WRITE (ipr,99022) cutoff
      WRITE (ipr,99016)
      RETURN
 500  DO i = 1 , N
         IF ( Char(i)<cutoff ) GOTO 600
      ENDDO
      WRITE (ipr,99016)
      WRITE (ipr,99017)
      WRITE (ipr,99019) alph31 , alph32 , sbnam1 , sbnam2
      WRITE (ipr,99021)
      WRITE (ipr,99022) cutoff
      WRITE (ipr,99016)
      RETURN
 600  DO i = 1 , N
         IF ( D(i)<cutoff ) GOTO 700
      ENDDO
      WRITE (ipr,99016)
      WRITE (ipr,99017)
      WRITE (ipr,99019) alph91 , alph92 , sbnam1 , sbnam2
      WRITE (ipr,99021)
      WRITE (ipr,99022) cutoff
      WRITE (ipr,99016)
      RETURN
!
 700  DO i = 1 , N
         IF ( Dmin<D(i) .AND. D(i)<Dmax ) GOTO 800
      ENDDO
      WRITE (ipr,99016)
      WRITE (ipr,99017)
      WRITE (ipr,99019) alph91 , alph92 , sbnam1 , sbnam2
      WRITE (ipr,99004)
99004 FORMAT (' ','HAS ALL ELEMENTS OUTSIDE THE INTERVAL')
      WRITE (ipr,99005) Dmin , Dmax
99005 FORMAT (' ','(',E15.8,',',E15.8,')',' AS DEFINED BY')
      WRITE (ipr,99006)
99006 FORMAT (' ','THE TENTH  AND ELEVENTH INPUT ARGUMENTS.')
      WRITE (ipr,99016)
      RETURN
!
 800  n2 = 0
      DO i = 1 , N
         IF ( Y(i)<cutoff .AND. X(i)<cutoff .AND. Char(i)<cutoff .AND.  &
     &        D(i)<cutoff ) THEN
            IF ( Dmin<D(i) .AND. D(i)<Dmax ) n2 = n2 + 1
            IF ( n2>=2 ) GOTO 900
         ENDIF
      ENDDO
      WRITE (ipr,99016)
      WRITE (ipr,99017)
      WRITE (ipr,99007) alph11 , alph12 , alph21 , alph22 , alph31 ,    &
     &                  alph32 , alph91 , alph92
99007 FORMAT (' ','THE ',A4,A4,', ',A4,A4,', ',A4,A4,', AND ',A4,A4)
      WRITE (ipr,99008) sbnam1 , sbnam2
99008 FORMAT (' ','INPUT ARGUMENTS TO THE ',A4,A4,' SUBROUTINE')
      WRITE (ipr,99009)
99009 FORMAT (' ','ARE SUCH THAT TOO MANY POINTS HAVE BEEN',            &
     &        ' EXCLUDED FROM THE PLOT.')
      WRITE (ipr,99010) n2
99010 FORMAT (' ','ONLY ',I3,' POINTS ARE LEFT TO BE PLOTTED.')
      WRITE (ipr,99016)
      RETURN
!
!-----START POINT-----------------------------------------------------
!
!     DETERMINE THE VALUES TO BE LISTED ON THE LEFT VERTICAL AXIS
!
 900  DO i = 1 , 9
         aim1 = i - 1
         ylable(i) = Ymax - (aim1/8.0)*(Ymax-Ymin)
      ENDDO
!
!     DETERMINE THE VALUES TO BE LISTED ON THE BOTTOM HORIZONTAL AXIS
!     DETERMINE XMID, X25 (=THE 25% POINT), AND
!     X75 (=THE 75% POINT)
!
      xmid = (Xmin+Xmax)/2.0
      x25 = 0.75*Xmin + 0.25*Xmax
      x75 = 0.25*Xmin + 0.75*Xmax
!
!     BLANK OUT THE GRAPH
!
      DO i = 1 , 45
         DO j = 1 , 109
            IGRaph(i,j) = blank
         ENDDO
      ENDDO
!
!     PRODUCE THE VERTICAL AXES
!
      DO i = 3 , 43
         IGRaph(i,5) = alphai
         IGRaph(i,109) = alphai
      ENDDO
      DO i = 3 , 43 , 5
         IGRaph(i,5) = hyphen
         IGRaph(i,109) = hyphen
      ENDDO
      IGRaph(3,1) = equal
      IGRaph(3,2) = alpham
      IGRaph(3,3) = alphaa
      IGRaph(3,4) = alphax
      IGRaph(23,1) = equal
      IGRaph(23,2) = alpham
      IGRaph(23,3) = alphai
      IGRaph(23,4) = alphad
      IGRaph(43,1) = equal
      IGRaph(43,2) = alpham
      IGRaph(43,3) = alphai
      IGRaph(43,4) = alphan
!
!     PRODUCE THE HORIZONTAL AXES
!
      DO j = 7 , 107
         IGRaph(1,j) = hyphen
         IGRaph(45,j) = hyphen
      ENDDO
      DO j = 7 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
      DO j = 20 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
!
!     DETERMINE THE (X,Y) PLOT POSITIONS
!
      ratioy = 40.0/(Ymax-Ymin)
      ratiox = 100.0/(Xmax-Xmin)
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  IF ( Y(i)>=Ymin .AND. Y(i)<=Ymax ) THEN
                     IF ( X(i)>=Xmin .AND. X(i)<=Xmax ) THEN
                        IF ( D(i)>=Dmin ) THEN
                           IF ( D(i)<=Dmax ) THEN
                              mx = ratiox*(X(i)-Xmin) + 0.5
                              mx = mx + 7
                              my = ratioy*(Y(i)-Ymin) + 0.5
                              my = 43 - my
                              iarg = 37
                              IF ( 0.5<Char(i) .AND. Char(i)<36.5 )     &
     &                             iarg = Char(i) + 0.5
                              IGRaph(my,mx) = iplotc(iarg)
                           ENDIF
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
!
!     WRITE OUT THE GRAPH
!
      DO i = 1 , 45
         ip2 = i + 2
         iflag = ip2 - (ip2/5)*5
         k = ip2/5
         IF ( iflag/=0 ) WRITE (ipr,99011) (IGRaph(i,j),j=1,109)
!
99011    FORMAT (' ',20X,109A1)
         IF ( iflag==0 ) WRITE (ipr,99012) ylable(k) ,                  &
     &                          (IGRaph(i,j),j=1,109)
99012    FORMAT (' ',F20.7,109A1)
      ENDDO
      WRITE (ipr,99013) Xmin , x25 , xmid , x75 , Xmax
99013 FORMAT (' ',14X,F20.7,5X,F20.7,5X,F20.7,5X,F20.7,1X,F20.7)
      WRITE (ipr,99014) Yaxid , Xaxid , Plchid
99014 FORMAT (' ',9X,A4,A4,' (VERTICAL AXIS) VERSUS ',A4,A4,            &
     &        ' (HORIZONTAL AXIS) ',20X,'THE PLOTTING CHARACTER IS ',A4,&
     &        A4)
      WRITE (ipr,99015) N
99015 FORMAT (' ',83X,'THE NUMBER OF OBSERVATIONS PLOTTED IS ',I8)
!
99016 FORMAT (' ','**************************************************', &
     &        '********************')
99017 FORMAT (' ','                   FATAL ERROR                    ')
99018 FORMAT (' ','               NON-FATAL DIAGNOSTIC               ')
99019 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
99020 FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
99021 FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
99022 FORMAT (' ','VALUE OF ',E15.8)
!
      END SUBROUTINE PLOT10
!*==plot6.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOT6(Y,X,N,Ymin,Ymax,Xmin,Xmax)
      IMPLICIT NONE
!*--PLOT616520
!*** Start of declarations inserted by SPAG
      REAL aim1 , cutoff , hold , ratiox , ratioy , X , x25 , x75 ,     &
     &     Xmax , xmid , Xmin , Y , ylable , Ymax , Ymin
      INTEGER i , iflag , ip2 , ipr , j , k , mx , my , N , n2
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOT6
!
!     PURPOSE--THIS SUBROUTINE YIELDS A ONE-PAGE PRINTER PLOT
!              OF Y(I) VERSUS X(I):
!              1) WITH THE VERTICAL (Y) AXIS MIN AND MAX
!                 AND THE HORIZONTAL (X) AXIS MIN AND MAX
!                 VALUES SPECIFIED BY THE DATA ANALYST.
!
!              THE USE OF THE YMIN, YMAX, XMIN, AND XMAX
!              SPECIFICATIONS ALLOWS THE DATA ANALYST
!              TO CONTROL FULLY THE PLOT AXIS LIMITS,
!              SO AS, FOR EXAMPLE, TO ZERO-IN ON AN
!              INTERESTING SUB-REGION OF A PREVIOUS PLOT.
!
!     INPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED VERTICALLY.
!                    --X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED HORIZONTALLY.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR Y.
!                    --YMIN   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MINIMUM FOR THE VERTICAL AXIS.
!                    --YMAX   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MAXIMUM FOR THE VERTICAL AXIS.
!                    --XMIN   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MINIMUM FOR THE HORIZONTAL AXIS.
!                    --XMAX   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MAXIMUM FOR THE HORIZONTAL AXIS.
!     OUTPUT--A ONE-PAGE PRINTER PLOT OF Y(I) VERSUS X(I),
!             WITH SPECIFIED AXIS LIMITS.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--VALUES IN THE VERTICAL AXIS VECTOR (Y)
!              WHICH ARE SMALLER THAN YMIN OR LARGER THAN YMAX,
!              OR VALUES IN THE HORIZONTAL AXIS VECTOR (X)
!              WHICH ARE SMALLER THAN XMIN OR LARGER THAN XMAX
!              WILL NOT BE PLOTTED.
!            --VALUES IN THE VERTICAL AXIS VECTOR (Y)
!              OR THE HORIZONTAL AXIS VECTOR (X) WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR Y
!              (OR X) ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR Y
!              (OR X) FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN Y (OR X) TO BE PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN Y (OR X) TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOT
!              SUBROUTINE.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --FEBRUARY  1977.
!     UPDATED         --JUNE      1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 IGRaph
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22 , alph31 , alph32
      CHARACTER*4 blank , hyphen , alphai , alphax
      CHARACTER*4 alpham , alphaa , alphad , alphan , equal
!
      DIMENSION Y(1)
      DIMENSION X(1)
      DIMENSION ylable(11)
      COMMON /BLOCK1/ IGRaph(55,130)
!
      DATA sbnam1 , sbnam2/'PLOT' , '6   '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA alph31 , alph32/'THIR' , 'D   '/
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
      DATA alpham , alphaa , alphad , alphan , equal/'M' , 'A' , 'D' ,  &
     &     'N' , '='/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      WRITE (ipr,99001)
99001 FORMAT ('1')
      IF ( N<1 ) THEN
         WRITE (ipr,99011)
         WRITE (ipr,99012)
         WRITE (ipr,99013) alph31 , alph32 , sbnam1 , sbnam2
         WRITE (ipr,99002) N
99002    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99011)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99011)
            WRITE (ipr,99012)
            WRITE (ipr,99013) alph31 , alph32 , sbnam1 , sbnam2
            WRITE (ipr,99003) N
99003       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99011)
            RETURN
         ELSE
!
            hold = Y(1)
            DO i = 2 , N
               IF ( Y(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99011)
            WRITE (ipr,99012)
            WRITE (ipr,99013) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99014) hold
            WRITE (ipr,99011)
            RETURN
         ENDIF
 50      hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99011)
         WRITE (ipr,99012)
         WRITE (ipr,99013) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99014) hold
         WRITE (ipr,99011)
         RETURN
      ENDIF
!
 100  DO i = 1 , N
         IF ( Y(i)<cutoff ) GOTO 200
      ENDDO
      WRITE (ipr,99011)
      WRITE (ipr,99012)
      WRITE (ipr,99013) alph11 , alph12 , sbnam1 , sbnam2
      WRITE (ipr,99015)
      WRITE (ipr,99016) cutoff
      WRITE (ipr,99011)
      RETURN
 200  DO i = 1 , N
         IF ( X(i)<cutoff ) GOTO 300
      ENDDO
      WRITE (ipr,99011)
      WRITE (ipr,99012)
      WRITE (ipr,99013) alph21 , alph22 , sbnam1 , sbnam2
      WRITE (ipr,99015)
      WRITE (ipr,99016) cutoff
      WRITE (ipr,99011)
      RETURN
!
 300  n2 = 0
      DO i = 1 , N
         IF ( Y(i)<cutoff .AND. X(i)<cutoff ) THEN
            n2 = n2 + 1
            IF ( n2>=2 ) GOTO 400
         ENDIF
      ENDDO
      WRITE (ipr,99011)
      WRITE (ipr,99012)
      WRITE (ipr,99004) alph11 , alph12 , alph21 , alph22
99004 FORMAT (' ','THE ',A4,A4,', AND ',A4,A4)
      WRITE (ipr,99005) sbnam1 , sbnam2
99005 FORMAT (' ','INPUT ARGUMENTS TO THE ',A4,A4,' SUBROUTINE')
      WRITE (ipr,99006)
99006 FORMAT (' ','ARE SUCH THAT TOO MANY POINTS HAVE BEEN',            &
     &        ' EXCLUDED FROM THE PLOT.')
      WRITE (ipr,99007) n2
99007 FORMAT (' ','ONLY ',I3,' POINTS ARE LEFT TO BE PLOTTED.')
      WRITE (ipr,99011)
      RETURN
!
!-----START POINT-----------------------------------------------------
!
!     DETERMINE THE VALUES TO BE LISTED ON THE LEFT VERTICAL AXIS
!
 400  DO i = 1 , 9
         aim1 = i - 1
         ylable(i) = Ymax - (aim1/8.0)*(Ymax-Ymin)
      ENDDO
!
!     DETERMINE THE VALUES TO BE LISTED ON THE BOTTOM HORIZONTAL AXIS
!     DETERMINE XMID, X25 (=THE 25% POINT), AND
!     X75 (=THE 75% POINT)
!
      xmid = (Xmin+Xmax)/2.0
      x25 = 0.75*Xmin + 0.25*Xmax
      x75 = 0.25*Xmin + 0.75*Xmax
!
!     BLANK OUT THE GRAPH
!
      DO i = 1 , 45
         DO j = 1 , 109
            IGRaph(i,j) = blank
         ENDDO
      ENDDO
!
!     PRODUCE THE VERTICAL AXES
!
      DO i = 3 , 43
         IGRaph(i,5) = alphai
         IGRaph(i,109) = alphai
      ENDDO
      DO i = 3 , 43 , 5
         IGRaph(i,5) = hyphen
         IGRaph(i,109) = hyphen
      ENDDO
      IGRaph(3,1) = equal
      IGRaph(3,2) = alpham
      IGRaph(3,3) = alphaa
      IGRaph(3,4) = alphax
      IGRaph(23,1) = equal
      IGRaph(23,2) = alpham
      IGRaph(23,3) = alphai
      IGRaph(23,4) = alphad
      IGRaph(43,1) = equal
      IGRaph(43,2) = alpham
      IGRaph(43,3) = alphai
      IGRaph(43,4) = alphan
!
!     PRODUCE THE HORIZONTAL AXES
!
      DO j = 7 , 107
         IGRaph(1,j) = hyphen
         IGRaph(45,j) = hyphen
      ENDDO
      DO j = 7 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
      DO j = 20 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
!
!     DETERMINE THE (X,Y) PLOT POSITIONS
!
      ratioy = 40.0/(Ymax-Ymin)
      ratiox = 100.0/(Xmax-Xmin)
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Y(i)>=Ymin .AND. Y(i)<=Ymax ) THEN
                  IF ( X(i)>=Xmin .AND. X(i)<=Xmax ) THEN
                     mx = ratiox*(X(i)-Xmin) + 0.5
                     mx = mx + 7
                     my = ratioy*(Y(i)-Ymin) + 0.5
                     my = 43 - my
                     IGRaph(my,mx) = alphax
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
!
!     WRITE OUT THE GRAPH
!
      DO i = 1 , 45
         ip2 = i + 2
         iflag = ip2 - (ip2/5)*5
         k = ip2/5
         IF ( iflag/=0 ) WRITE (ipr,99008) (IGRaph(i,j),j=1,109)
!
99008    FORMAT (' ',20X,109A1)
         IF ( iflag==0 ) WRITE (ipr,99009) ylable(k) ,                  &
     &                          (IGRaph(i,j),j=1,109)
99009    FORMAT (' ',F20.7,109A1)
      ENDDO
      WRITE (ipr,99010) Xmin , x25 , xmid , x75 , Xmax
99010 FORMAT (' ',14X,F20.7,5X,F20.7,5X,F20.7,5X,F20.7,1X,F20.7)
!
99011 FORMAT (' ','**************************************************', &
     &        '********************')
99012 FORMAT (' ','                   FATAL ERROR                    ')
99013 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
99014 FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
99015 FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
99016 FORMAT (' ','VALUE OF ',E15.8)
!
      END SUBROUTINE PLOT6
!*==plot7.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOT7(Y,X,Char,N,Ymin,Ymax,Xmin,Xmax)
      IMPLICIT NONE
!*--PLOT716824
!*** Start of declarations inserted by SPAG
      REAL aim1 , Char , cutoff , hold , ratiox , ratioy , X , x25 ,    &
     &     x75 , Xmax , xmid , Xmin , Y , ylable , Ymax , Ymin
      INTEGER i , iarg , iflag , ip2 , ipr , j , k , mx , my , N , n2
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOT7
!
!     PURPOSE--THIS SUBROUTINE YIELDS A ONE-PAGE PRINTER PLOT
!              OF Y(I) VERSUS X(I):
!              1) WITH SPECIAL PLOT CHARACTERS; AND
!              2) WITH THE VERTICAL (Y) AXIS MIN AND MAX
!                 AND THE HORIZONTAL (X) AXIS MIN AND MAX
!                 VALUES SPECIFIED BY THE DATA ANALYST.
!
!              THE 'SPECIAL PLOTTING CHARACTER' CAPABILITY
!              ALLOWS THE DATA ANALYST TO INCORPORATE INFORMATION
!              FROM A THIRD VARIABLE (ASIDE FROM Y AND X) INTO
!              THE PLOT.
!              THE PLOT CHARACTER USED AT THE I-TH PLOTTING
!              POSITION (THAT IS, AT THE COORDINATE (X(I),Y(I)))
!              WILL BE
!              1 IF CHAR(I) IS BETWEEN  0.5 AND  1.5
!              2 IF CHAR(I) IS BETWEEN  1.5 AND  2.5
!                .
!                .
!                .
!              9 IF CHAR(I) IS BETWEEN  8.5 AND  9.5
!              0 IF CHAR(I) IS BETWEEN  9.5 AND 10.5
!              A IF CHAR(I) IS BETWEEN 10.5 AND 11.5
!              B IF CHAR(I) IS BETWEEN 11.5 AND 12.5
!              C IF CHAR(I) IS BETWEEN 12.5 AND 13.5
!                .
!                .
!                .
!              W IF CHAR(I) IS BETWEEN 32.5 AND 33.5
!              X IF CHAR(I) IS BETWEEN 33.5 AND 34.5
!              Y IF CHAR(I) IS BETWEEN 34.5 AND 35.5
!              Z IF CHAR(I) IS BETWEEN 35.5 AND 36.5
!              X IF CHAR(I) IS ANY VALUE OUTSIDE THE RANGE
!                                       0.5 TO  36.5.
!
!              THE USE OF THE YMIN, YMAX, XMIN, AND XMAX
!              SPECIFICATIONS ALLOWS THE DATA ANALYST
!              TO CONTROL FULLY THE PLOT AXIS LIMITS,
!              SO AS, FOR EXAMPLE, TO ZERO-IN ON AN
!              INTERESTING SUB-REGION OF A PREVIOUS PLOT.
!
!     INPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED VERTICALLY.
!                    --X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED HORIZONTALLY.
!                    --CHAR   = THE SINGLE PRECISION VECTOR OF
!                               OBSERVATIONS WHICH CONTROL THE
!                               VALUE OF EACH INDIVIDUAL PLOT
!                               CHARACTER.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR Y.
!                    --YMIN   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MINIMUM FOR THE VERTICAL AXIS.
!                    --YMAX   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MAXIMUM FOR THE VERTICAL AXIS.
!                    --XMIN   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MINIMUM FOR THE HORIZONTAL AXIS.
!                    --XMAX   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MAXIMUM FOR THE HORIZONTAL AXIS.
!     OUTPUT--A ONE-PAGE PRINTER PLOT OF Y(I) VERSUS X(I),
!             WITH SPECIAL PLOT CHARACTERS,
!             AND WITH SPECIFIED AXIS LIMITS.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--VALUES IN THE VERTICAL AXIS VECTOR (Y)
!              WHICH ARE SMALLER THAN YMIN OR LARGER THAN YMAX,
!              OR VALUES IN THE HORIZONTAL AXIS VECTOR (X)
!              WHICH ARE SMALLER THAN XMIN OR LARGER THAN XMAX
!              WILL NOT BE PLOTTED.
!            --VALUES IN THE VERTICAL AXIS VECTOR (Y),
!              THE HORIZONTAL AXIS VECTOR (X),
!              OR THE PLOT CHARACTER VECTOR (CHAR) WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR Y
!              (OR X, OR CHAR) ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR Y
!              (OR X, OR CHAR) FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN Y (OR X, OR CHAR) TO BE
!              PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN Y (OR X, OR CHAR) TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOTC
!              SUBROUTINE.
!     REFERENCES--FILLIBEN, 'STATISTICAL ANALYSIS OF INTERLAB
!                 FATIGUE TIME DATA', UNPUBLISHED MANUSCRIPT
!                 (AVAILABLE FROM AUTHOR)
!                 PRESENTED AT THE 'COMPUTER-ASSISTED DATA
!                 ANALYSIS' SESSION AT THE NATIONAL MEETING
!                 OF THE AMERICAN STATISTICAL ASSOCIATION,
!                 NEW YORK CITY, DECEMBER 27-30, 1973.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --JUNE      1974.
!     UPDATED         --OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --FEBRUARY  1977.
!     UPDATED         --JUNE      1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 IGRaph
      CHARACTER*4 iplotc
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22 , alph31 , alph32
      CHARACTER*4 alph41 , alph42
      CHARACTER*4 blank , hyphen , alphai , alphax
      CHARACTER*4 alpham , alphaa , alphad , alphan , equal
!
      DIMENSION Y(1)
      DIMENSION X(1)
      DIMENSION Char(1)
      DIMENSION ylable(11)
      DIMENSION iplotc(37)
      COMMON /BLOCK1/ IGRaph(55,130)
!
      DATA sbnam1 , sbnam2/'PLOT' , '7   '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA alph31 , alph32/'THIR' , 'D   '/
      DATA alph41 , alph42/'FOUR' , 'TH  '/
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
      DATA alpham , alphaa , alphad , alphan , equal/'M' , 'A' , 'D' ,  &
     &     'N' , '='/
      DATA iplotc(1) , iplotc(2) , iplotc(3) , iplotc(4) , iplotc(5) ,  &
     &     iplotc(6) , iplotc(7) , iplotc(8) , iplotc(9) , iplotc(10) , &
     &     iplotc(11) , iplotc(12) , iplotc(13) , iplotc(14) ,          &
     &     iplotc(15) , iplotc(16) , iplotc(17) , iplotc(18) ,          &
     &     iplotc(19) , iplotc(20) , iplotc(21) , iplotc(22) ,          &
     &     iplotc(23) , iplotc(24) , iplotc(25) , iplotc(26) ,          &
     &     iplotc(27) , iplotc(28) , iplotc(29) , iplotc(30) ,          &
     &     iplotc(31) , iplotc(32) , iplotc(33) , iplotc(34) ,          &
     &     iplotc(35) , iplotc(36) , iplotc(37)/'1' , '2' , '3' , '4' , &
     &     '5' , '6' , '7' , '8' , '9' , '0' , 'A' , 'B' , 'C' , 'D' ,  &
     &     'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' ,  &
     &     'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' ,  &
     &     'Y' , 'Z' , 'X'/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      WRITE (ipr,99001)
99001 FORMAT ('1')
      IF ( N<1 ) THEN
         WRITE (ipr,99012)
         WRITE (ipr,99013)
         WRITE (ipr,99014) alph41 , alph42 , sbnam1 , sbnam2
         WRITE (ipr,99002) N
99002    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99012)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99012)
            WRITE (ipr,99013)
            WRITE (ipr,99014) alph41 , alph42 , sbnam1 , sbnam2
            WRITE (ipr,99003) N
99003       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99012)
            RETURN
         ELSE
!
            hold = Y(1)
            DO i = 2 , N
               IF ( Y(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99012)
            WRITE (ipr,99013)
            WRITE (ipr,99014) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99015) hold
            WRITE (ipr,99012)
            RETURN
         ENDIF
 50      hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99012)
         WRITE (ipr,99013)
         WRITE (ipr,99014) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99015) hold
         WRITE (ipr,99012)
         RETURN
      ENDIF
 100  hold = Char(1)
      DO i = 2 , N
         IF ( Char(i)/=hold ) GOTO 200
      ENDDO
      WRITE (ipr,99012)
      WRITE (ipr,99004)
99004 FORMAT (' ','               NON-FATAL DIAGNOSTIC               ')
      WRITE (ipr,99014) alph31 , alph32 , sbnam1 , sbnam2
      WRITE (ipr,99015) hold
      WRITE (ipr,99012)
!
 200  DO i = 1 , N
         IF ( Y(i)<cutoff ) GOTO 300
      ENDDO
      WRITE (ipr,99012)
      WRITE (ipr,99013)
      WRITE (ipr,99014) alph11 , alph12 , sbnam1 , sbnam2
      WRITE (ipr,99016)
      WRITE (ipr,99017) cutoff
      WRITE (ipr,99012)
      RETURN
 300  DO i = 1 , N
         IF ( X(i)<cutoff ) GOTO 400
      ENDDO
      WRITE (ipr,99012)
      WRITE (ipr,99013)
      WRITE (ipr,99014) alph21 , alph22 , sbnam1 , sbnam2
      WRITE (ipr,99016)
      WRITE (ipr,99017) cutoff
      WRITE (ipr,99012)
      RETURN
 400  DO i = 1 , N
         IF ( Char(i)<cutoff ) GOTO 500
      ENDDO
      WRITE (ipr,99012)
      WRITE (ipr,99013)
      WRITE (ipr,99014) alph31 , alph32 , sbnam1 , sbnam2
      WRITE (ipr,99016)
      WRITE (ipr,99017) cutoff
      WRITE (ipr,99012)
      RETURN
!
 500  n2 = 0
      DO i = 1 , N
         IF ( Y(i)<cutoff .AND. X(i)<cutoff .AND. Char(i)<cutoff ) THEN
            n2 = n2 + 1
            IF ( n2>=2 ) GOTO 600
         ENDIF
      ENDDO
      WRITE (ipr,99012)
      WRITE (ipr,99013)
      WRITE (ipr,99005) alph11 , alph12 , alph21 , alph22 , alph31 ,    &
     &                  alph32
99005 FORMAT (' ','THE ',A4,A4,', ',A4,A4,', AND ',A4,A4)
      WRITE (ipr,99006) sbnam1 , sbnam2
99006 FORMAT (' ','INPUT ARGUMENTS TO THE ',A4,A4,' SUBROUTINE')
      WRITE (ipr,99007)
99007 FORMAT (' ','ARE SUCH THAT TOO MANY POINTS HAVE BEEN',            &
     &        ' EXCLUDED FROM THE PLOT.')
      WRITE (ipr,99008) n2
99008 FORMAT (' ','ONLY ',I3,' POINTS ARE LEFT TO BE PLOTTED.')
      WRITE (ipr,99012)
      RETURN
!
!-----START POINT-----------------------------------------------------
!
!     DETERMINE THE VALUES TO BE LISTED ON THE LEFT VERTICAL AXIS
!
 600  DO i = 1 , 9
         aim1 = i - 1
         ylable(i) = Ymax - (aim1/8.0)*(Ymax-Ymin)
      ENDDO
!
!     DETERMINE THE VALUES TO BE LISTED ON THE BOTTOM HORIZONTAL AXIS
!     DETERMINE XMID, X25 (=THE 25% POINT), AND
!     X75 (=THE 75% POINT)
!
      xmid = (Xmin+Xmax)/2.0
      x25 = 0.75*Xmin + 0.25*Xmax
      x75 = 0.25*Xmin + 0.75*Xmax
!
!     BLANK OUT THE GRAPH
!
      DO i = 1 , 45
         DO j = 1 , 109
            IGRaph(i,j) = blank
         ENDDO
      ENDDO
!
!     PRODUCE THE VERTICAL AXES
!
      DO i = 3 , 43
         IGRaph(i,5) = alphai
         IGRaph(i,109) = alphai
      ENDDO
      DO i = 3 , 43 , 5
         IGRaph(i,5) = hyphen
         IGRaph(i,109) = hyphen
      ENDDO
      IGRaph(3,1) = equal
      IGRaph(3,2) = alpham
      IGRaph(3,3) = alphaa
      IGRaph(3,4) = alphax
      IGRaph(23,1) = equal
      IGRaph(23,2) = alpham
      IGRaph(23,3) = alphai
      IGRaph(23,4) = alphad
      IGRaph(43,1) = equal
      IGRaph(43,2) = alpham
      IGRaph(43,3) = alphai
      IGRaph(43,4) = alphan
!
!     PRODUCE THE HORIZONTAL AXES
!
      DO j = 7 , 107
         IGRaph(1,j) = hyphen
         IGRaph(45,j) = hyphen
      ENDDO
      DO j = 7 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
      DO j = 20 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
!
!     DETERMINE THE (X,Y) PLOT POSITIONS
!
      ratioy = 40.0/(Ymax-Ymin)
      ratiox = 100.0/(Xmax-Xmin)
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  IF ( Y(i)>=Ymin .AND. Y(i)<=Ymax ) THEN
                     IF ( X(i)>=Xmin .AND. X(i)<=Xmax ) THEN
                        mx = ratiox*(X(i)-Xmin) + 0.5
                        mx = mx + 7
                        my = ratioy*(Y(i)-Ymin) + 0.5
                        my = 43 - my
                        iarg = 37
                        IF ( 0.5<Char(i) .AND. Char(i)<36.5 )           &
     &                       iarg = Char(i) + 0.5
                        IGRaph(my,mx) = iplotc(iarg)
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
!
!     WRITE OUT THE GRAPH
!
      DO i = 1 , 45
         ip2 = i + 2
         iflag = ip2 - (ip2/5)*5
         k = ip2/5
         IF ( iflag/=0 ) WRITE (ipr,99009) (IGRaph(i,j),j=1,109)
!
99009    FORMAT (' ',20X,109A1)
         IF ( iflag==0 ) WRITE (ipr,99010) ylable(k) ,                  &
     &                          (IGRaph(i,j),j=1,109)
99010    FORMAT (' ',F20.7,109A1)
      ENDDO
      WRITE (ipr,99011) Xmin , x25 , xmid , x75 , Xmax
99011 FORMAT (' ',14X,F20.7,5X,F20.7,5X,F20.7,5X,F20.7,1X,F20.7)
!
99012 FORMAT (' ','**************************************************', &
     &        '********************')
99013 FORMAT (' ','                   FATAL ERROR                    ')
99014 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
99015 FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
99016 FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
99017 FORMAT (' ','VALUE OF ',E15.8)
!
      END SUBROUTINE PLOT7
!*==plot8.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOT8(Y,X,Char,N,Ymin,Ymax,Xmin,Xmax,D,Dmin,Dmax)
      IMPLICIT NONE
!*--PLOT817214
!*** Start of declarations inserted by SPAG
      REAL aim1 , Char , cutoff , D , Dmax , Dmin , hold , ratiox ,     &
     &     ratioy , X , x25 , x75 , Xmax , xmid , Xmin , Y , ylable ,   &
     &     Ymax , Ymin
      INTEGER i , iarg , iflag , ip2 , ipr , j , k , mx , my , N , n2
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOT8
!
!     PURPOSE--THIS SUBROUTINE YIELDS A ONE-PAGE PRINTER PLOT
!              OF Y(I) VERSUS X(I):
!              1) WITH SPECIAL PLOT CHARACTERS;
!              2) WITH THE VERTICAL (Y) AXIS MIN AND MAX
!                 AND THE HORIZONTAL (X) AXIS MIN AND MAX
!                 VALUES SPECIFIED BY THE DATA ANALYST; AND
!              3) WITH ONLY THOSE POINTS (X(I),Y(I)) PLOTTED
!                 FOR WHICH THE CORRESPONDING VALUE OF D(I)
!                 IS BETWEEN THE SPECIFIED VALUES OF DMIN AND DMAX.
!
!              THE 'SPECIAL PLOTTING CHARACTER' CAPABILITY
!              ALLOWS THE DATA ANALYST TO INCORPORATE INFORMATION
!              FROM A THIRD VARIABLE (ASIDE FROM Y AND X) INTO
!              THE PLOT.
!              THE PLOT CHARACTER USED AT THE I-TH PLOTTING
!              POSITION (THAT IS, AT THE COORDINATE (X(I),Y(I)))
!              WILL BE
!              1 IF CHAR(I) IS BETWEEN  0.5 AND  1.5
!              2 IF CHAR(I) IS BETWEEN  1.5 AND  2.5
!                .
!                .
!                .
!              9 IF CHAR(I) IS BETWEEN  8.5 AND  9.5
!              0 IF CHAR(I) IS BETWEEN  9.5 AND 10.5
!              A IF CHAR(I) IS BETWEEN 10.5 AND 11.5
!              B IF CHAR(I) IS BETWEEN 11.5 AND 12.5
!              C IF CHAR(I) IS BETWEEN 12.5 AND 13.5
!                .
!                .
!                .
!              W IF CHAR(I) IS BETWEEN 32.5 AND 33.5
!              X IF CHAR(I) IS BETWEEN 33.5 AND 34.5
!              Y IF CHAR(I) IS BETWEEN 34.5 AND 35.5
!              Z IF CHAR(I) IS BETWEEN 35.5 AND 36.5
!              X IF CHAR(I) IS ANY VALUE OUTSIDE THE RANGE
!                                       0.5 TO  36.5.
!
!              THE USE OF THE YMIN, YMAX, XMIN, AND XMAX
!              SPECIFICATIONS ALLOWS THE DATA ANALYST
!              TO CONTROL FULLY THE PLOT AXIS LIMITS,
!              SO AS, FOR EXAMPLE, TO ZERO-IN ON AN
!              INTERESTING SUB-REGION OF A PREVIOUS PLOT.
!
!              THE USE OF THE SUBSET DEFINTION VECTOR D
!              GIVES THE DATA ANALYST THE CAPABILITY OF
!              PLOTTING SUBSETS OF THE DATA,
!              WHERE THE SUBSET IS DEFINED
!              BY VALUES IN THE VECTOR D.
!
!     INPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED VERTICALLY.
!                    --X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED HORIZONTALLY.
!                    --CHAR   = THE SINGLE PRECISION VECTOR OF
!                               OBSERVATIONS WHICH CONTROL THE
!                               VALUE OF EACH INDIVIDUAL PLOT
!                               CHARACTER.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR Y.
!                    --YMIN   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MINIMUM FOR THE VERTICAL AXIS.
!                    --YMAX   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MAXIMUM FOR THE VERTICAL AXIS.
!                    --XMIN   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MINIMUM FOR THE HORIZONTAL AXIS.
!                    --XMAX   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MAXIMUM FOR THE HORIZONTAL AXIS.
!                    --D      = THE SINGLE PRECISION VECTOR
!                               WHICH 'DEFINES' THE VARIOUS
!                               POSSIBLE SUBSETS.
!                    --DMIN   = THE SINGLE PRECISION VALUE
!                               WHICH DEFINES THE LOWER BOUND
!                               (INCLUSIVELY) OF THE PARTICULAR
!                               SUBSET OF INTEREST TO BE PLOTTED.
!                    --DMAX   = THE SINGLE PRECISION VALUE
!                               WHICH DEFINES THE UPPER BOUND
!                               (INCLUSIVELY) OF THE PARTICULAR
!                               SUBSET OF INTEREST TO BE PLOTTED.
!     OUTPUT--A ONE-PAGE PRINTER PLOT OF Y(I) VERSUS X(I),
!             WITH SPECIAL PLOT CHARACTERS,
!             WITH SPECIFIED AXIS LIMITS,
!             AND ONLY FOR A SPECIFIED SUBSET OF THE DATA.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--VALUES IN THE VERTICAL AXIS VECTOR (Y)
!              WHICH ARE SMALLER THAN YMIN OR LARGER THAN YMAX,
!              OR VALUES IN THE HORIZONTAL AXIS VECTOR (X)
!              WHICH ARE SMALLER THAN XMIN OR LARGER THAN XMAX
!              WILL NOT BE PLOTTED.
!            --FOR A GIVEN DUMMY INDEX I,
!              IF D(I) IS SMALLER THAN DMIN OR LARGER THAN DMAX,
!              THEN THE CORRESPONDING POINT (X(I),Y(I))
!              WILL NOT BE PLOTTED.
!            --VALUES IN THE VERTICAL AXIS VECTOR (Y),
!              THE HORIZONTAL AXIS VECTOR (X),
!              OR THE PLOT CHARACTER VECTOR (CHAR) WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR Y
!              (OR X, OR CHAR) ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR Y
!              (OR X, OR CHAR) FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN Y (OR X, OR CHAR) TO BE
!              PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN Y (OR X, OR CHAR) TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOTC
!              SUBROUTINE.
!     REFERENCES--FILLIBEN, 'STATISTICAL ANALYSIS OF INTERLAB
!                 FATIGUE TIME DATA', UNPUBLISHED MANUSCRIPT
!                 (AVAILABLE FROM AUTHOR)
!                 PRESENTED AT THE 'COMPUTER-ASSISTED DATA
!                 ANALYSIS' SESSION AT THE NATIONAL MEETING
!                 OF THE AMERICAN STATISTICAL ASSOCIATION,
!                 NEW YORK CITY, DECEMBER 27-30, 1973.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JANUARY   1974.
!     UPDATED         --OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --FEBRUARY  1977.
!     UPDATED         --JUNE      1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 IGRaph
      CHARACTER*4 iplotc
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22 , alph31 , alph32
      CHARACTER*4 alph41 , alph42 , alph91 , alph92
      CHARACTER*4 blank , hyphen , alphai , alphax
      CHARACTER*4 alpham , alphaa , alphad , alphan , equal
!
      DIMENSION Y(1)
      DIMENSION X(1)
      DIMENSION D(1)
      DIMENSION Char(1)
      DIMENSION ylable(11)
      DIMENSION iplotc(37)
      COMMON /BLOCK1/ IGRaph(55,130)
!
      DATA sbnam1 , sbnam2/'PLOT' , '8   '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA alph31 , alph32/'THIR' , 'D   '/
      DATA alph41 , alph42/'FOUR' , 'TH  '/
      DATA alph91 , alph92/'NINT' , 'H   '/
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
      DATA alpham , alphaa , alphad , alphan , equal/'M' , 'A' , 'D' ,  &
     &     'N' , '='/
      DATA iplotc(1) , iplotc(2) , iplotc(3) , iplotc(4) , iplotc(5) ,  &
     &     iplotc(6) , iplotc(7) , iplotc(8) , iplotc(9) , iplotc(10) , &
     &     iplotc(11) , iplotc(12) , iplotc(13) , iplotc(14) ,          &
     &     iplotc(15) , iplotc(16) , iplotc(17) , iplotc(18) ,          &
     &     iplotc(19) , iplotc(20) , iplotc(21) , iplotc(22) ,          &
     &     iplotc(23) , iplotc(24) , iplotc(25) , iplotc(26) ,          &
     &     iplotc(27) , iplotc(28) , iplotc(29) , iplotc(30) ,          &
     &     iplotc(31) , iplotc(32) , iplotc(33) , iplotc(34) ,          &
     &     iplotc(35) , iplotc(36) , iplotc(37)/'1' , '2' , '3' , '4' , &
     &     '5' , '6' , '7' , '8' , '9' , '0' , 'A' , 'B' , 'C' , 'D' ,  &
     &     'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' ,  &
     &     'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' ,  &
     &     'Y' , 'Z' , 'X'/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      WRITE (ipr,99001)
99001 FORMAT ('1')
      IF ( N<1 ) THEN
         WRITE (ipr,99014)
         WRITE (ipr,99015)
         WRITE (ipr,99017) alph41 , alph42 , sbnam1 , sbnam2
         WRITE (ipr,99002) N
99002    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99014)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99014)
            WRITE (ipr,99015)
            WRITE (ipr,99017) alph41 , alph42 , sbnam1 , sbnam2
            WRITE (ipr,99003) N
99003       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99014)
            RETURN
         ELSE
!
            hold = Y(1)
            DO i = 2 , N
               IF ( Y(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99014)
            WRITE (ipr,99015)
            WRITE (ipr,99017) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99018) hold
            WRITE (ipr,99014)
            RETURN
         ENDIF
 50      hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99014)
         WRITE (ipr,99015)
         WRITE (ipr,99017) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99018) hold
         WRITE (ipr,99014)
         RETURN
      ENDIF
 100  hold = Char(1)
      DO i = 2 , N
         IF ( Char(i)/=hold ) GOTO 200
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99016)
      WRITE (ipr,99017) alph31 , alph32 , sbnam1 , sbnam2
      WRITE (ipr,99018) hold
      WRITE (ipr,99014)
 200  hold = D(1)
      DO i = 2 , N
         IF ( D(i)/=hold ) GOTO 300
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99016)
      WRITE (ipr,99017) alph91 , alph92 , sbnam1 , sbnam2
      WRITE (ipr,99018) hold
      WRITE (ipr,99014)
!
 300  DO i = 1 , N
         IF ( Y(i)<cutoff ) GOTO 400
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99017) alph11 , alph12 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99014)
      RETURN
 400  DO i = 1 , N
         IF ( X(i)<cutoff ) GOTO 500
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99017) alph21 , alph22 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99014)
      RETURN
 500  DO i = 1 , N
         IF ( Char(i)<cutoff ) GOTO 600
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99017) alph31 , alph32 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99014)
      RETURN
 600  DO i = 1 , N
         IF ( D(i)<cutoff ) GOTO 700
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99017) alph91 , alph92 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99014)
      RETURN
!
 700  DO i = 1 , N
         IF ( Dmin<D(i) .AND. D(i)<Dmax ) GOTO 800
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99017) alph91 , alph92 , sbnam1 , sbnam2
      WRITE (ipr,99004)
99004 FORMAT (' ','HAS ALL ELEMENTS OUTSIDE THE INTERVAL')
      WRITE (ipr,99005) Dmin , Dmax
99005 FORMAT (' ','(',E15.8,',',E15.8,')',' AS DEFINED BY')
      WRITE (ipr,99006)
99006 FORMAT (' ','THE FIFTH  AND SIXTH  INPUT ARGUMENTS.')
      WRITE (ipr,99014)
      RETURN
!
 800  n2 = 0
      DO i = 1 , N
         IF ( Y(i)<cutoff .AND. X(i)<cutoff .AND. Char(i)<cutoff .AND.  &
     &        D(i)<cutoff ) THEN
            IF ( Dmin<D(i) .AND. D(i)<Dmax ) n2 = n2 + 1
            IF ( n2>=2 ) GOTO 900
         ENDIF
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99007) alph11 , alph12 , alph21 , alph22 , alph31 ,    &
     &                  alph32 , alph91 , alph92
99007 FORMAT (' ','THE ',A4,A4,', ',A4,A4,', ',A4,A4,', AND ',A4,A4)
      WRITE (ipr,99008) sbnam1 , sbnam2
99008 FORMAT (' ','INPUT ARGUMENTS TO THE ',A4,A4,' SUBROUTINE')
      WRITE (ipr,99009)
99009 FORMAT (' ','ARE SUCH THAT TOO MANY POINTS HAVE BEEN',            &
     &        ' EXCLUDED FROM THE PLOT.')
      WRITE (ipr,99010) n2
99010 FORMAT (' ','ONLY ',I3,' POINTS ARE LEFT TO BE PLOTTED.')
      WRITE (ipr,99014)
      RETURN
!
!-----START POINT-----------------------------------------------------
!
!     DETERMINE THE VALUES TO BE LISTED ON THE LEFT VERTICAL AXIS
!
 900  DO i = 1 , 9
         aim1 = i - 1
         ylable(i) = Ymax - (aim1/8.0)*(Ymax-Ymin)
      ENDDO
!
!     DETERMINE THE VALUES TO BE LISTED ON THE BOTTOM HORIZONTAL AXIS
!     DETERMINE XMID, X25 (=THE 25% POINT), AND
!     X75 (=THE 75% POINT)
!
      xmid = (Xmin+Xmax)/2.0
      x25 = 0.75*Xmin + 0.25*Xmax
      x75 = 0.25*Xmin + 0.75*Xmax
!
!     BLANK OUT THE GRAPH
!
      DO i = 1 , 45
         DO j = 1 , 109
            IGRaph(i,j) = blank
         ENDDO
      ENDDO
!
!     PRODUCE THE VERTICAL AXES
!
      DO i = 3 , 43
         IGRaph(i,5) = alphai
         IGRaph(i,109) = alphai
      ENDDO
      DO i = 3 , 43 , 5
         IGRaph(i,5) = hyphen
         IGRaph(i,109) = hyphen
      ENDDO
      IGRaph(3,1) = equal
      IGRaph(3,2) = alpham
      IGRaph(3,3) = alphaa
      IGRaph(3,4) = alphax
      IGRaph(23,1) = equal
      IGRaph(23,2) = alpham
      IGRaph(23,3) = alphai
      IGRaph(23,4) = alphad
      IGRaph(43,1) = equal
      IGRaph(43,2) = alpham
      IGRaph(43,3) = alphai
      IGRaph(43,4) = alphan
!
!     PRODUCE THE HORIZONTAL AXES
!
      DO j = 7 , 107
         IGRaph(1,j) = hyphen
         IGRaph(45,j) = hyphen
      ENDDO
      DO j = 7 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
      DO j = 20 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
!
!     DETERMINE THE (X,Y) PLOT POSITIONS
!
      ratioy = 40.0/(Ymax-Ymin)
      ratiox = 100.0/(Xmax-Xmin)
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  IF ( Y(i)>=Ymin .AND. Y(i)<=Ymax ) THEN
                     IF ( X(i)>=Xmin .AND. X(i)<=Xmax ) THEN
                        IF ( D(i)>=Dmin ) THEN
                           IF ( D(i)<=Dmax ) THEN
                              mx = ratiox*(X(i)-Xmin) + 0.5
                              mx = mx + 7
                              my = ratioy*(Y(i)-Ymin) + 0.5
                              my = 43 - my
                              iarg = 37
                              IF ( 0.5<Char(i) .AND. Char(i)<36.5 )     &
     &                             iarg = Char(i) + 0.5
                              IGRaph(my,mx) = iplotc(iarg)
                           ENDIF
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
!
!     WRITE OUT THE GRAPH
!
      DO i = 1 , 45
         ip2 = i + 2
         iflag = ip2 - (ip2/5)*5
         k = ip2/5
         IF ( iflag/=0 ) WRITE (ipr,99011) (IGRaph(i,j),j=1,109)
!
99011    FORMAT (' ',20X,109A1)
         IF ( iflag==0 ) WRITE (ipr,99012) ylable(k) ,                  &
     &                          (IGRaph(i,j),j=1,109)
99012    FORMAT (' ',F20.7,109A1)
      ENDDO
      WRITE (ipr,99013) Xmin , x25 , xmid , x75 , Xmax
99013 FORMAT (' ',14X,F20.7,5X,F20.7,5X,F20.7,5X,F20.7,1X,F20.7)
!
99014 FORMAT (' ','**************************************************', &
     &        '********************')
99015 FORMAT (' ','                   FATAL ERROR                    ')
99016 FORMAT (' ','               NON-FATAL DIAGNOSTIC               ')
99017 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
99018 FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
99019 FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
99020 FORMAT (' ','VALUE OF ',E15.8)
!
      END SUBROUTINE PLOT8
!*==plot9.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOT9(Y,X,Char,N,Ymin,Ymax,Xmin,Xmax,Yaxid,Xaxid,      &
     &                 Plchid)
      IMPLICIT NONE
!*--PLOT917671
!*** Start of declarations inserted by SPAG
      REAL aim1 , Char , cutoff , hold , Plchid , ratiox , ratioy , X , &
     &     x25 , x75 , Xaxid , Xmax , xmid , Xmin , Y , Yaxid , ylable ,&
     &     Ymax , Ymin
      INTEGER i , iarg , iflag , ip2 , ipr , j , k , mx , my , N , n2
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOT9
!
!     PURPOSE--THIS SUBROUTINE YIELDS A ONE-PAGE PRINTER PLOT
!              OF Y(I) VERSUS X(I):
!              1) WITH SPECIAL PLOT CHARACTERS;
!              2) WITH THE VERTICAL (Y) AXIS MIN AND MAX
!                 AND THE HORIZONTAL (X) AXIS MIN AND MAX
!                 VALUES SPECIFIED BY THE DATA ANALYST; AND
!              3) WITH HOLLARITH LABELS (AT MOST 6 CHARACTERS)
!                 FOR THE VERTICAL AXIS VARIABLE,
!                 THE HORIZONTAL AXIS VARIABLE, AND
!                 THE PLOTTING CHARACTER VARIABLE
!                 ALSO BEING PROVIDED BY THE DATA ANALYST.
!
!              THE 'SPECIAL PLOTTING CHARACTER' CAPABILITY
!              ALLOWS THE DATA ANALYST TO INCORPORATE INFORMATION
!              FROM A THIRD VARIABLE (ASIDE FROM Y AND X) INTO
!              THE PLOT.
!              THE PLOT CHARACTER USED AT THE I-TH PLOTTING
!              POSITION (THAT IS, AT THE COORDINATE (X(I),Y(I)))
!              WILL BE
!              1 IF CHAR(I) IS BETWEEN  0.5 AND  1.5
!              2 IF CHAR(I) IS BETWEEN  1.5 AND  2.5
!                .
!                .
!                .
!              9 IF CHAR(I) IS BETWEEN  8.5 AND  9.5
!              0 IF CHAR(I) IS BETWEEN  9.5 AND 10.5
!              A IF CHAR(I) IS BETWEEN 10.5 AND 11.5
!              B IF CHAR(I) IS BETWEEN 11.5 AND 12.5
!              C IF CHAR(I) IS BETWEEN 12.5 AND 13.5
!                .
!                .
!                .
!              W IF CHAR(I) IS BETWEEN 32.5 AND 33.5
!              X IF CHAR(I) IS BETWEEN 33.5 AND 34.5
!              Y IF CHAR(I) IS BETWEEN 34.5 AND 35.5
!              Z IF CHAR(I) IS BETWEEN 35.5 AND 36.5
!              X IF CHAR(I) IS ANY VALUE OUTSIDE THE RANGE
!                                       0.5 TO  36.5.
!
!              THE USE OF THE YMIN, YMAX, XMIN, AND XMAX
!              SPECIFICATIONS ALLOWS THE DATA ANALYST
!              TO CONTROL FULLY THE PLOT AXIS LIMITS,
!              SO AS, FOR EXAMPLE, TO ZERO-IN ON AN
!              INTERESTING SUB-REGION OF A PREVIOUS PLOT.
!
!              THE USE OF HOLLARITH IDENTIFYING LABELS
!              ALLOWS THE DATA ANALYST TO AUTOMATICALLY
!              HAVE THE PLOTS LABELED.  THIS IS PARTICULARLY
!              USEFUL IN A LARGE ANALYSIS WHEN MANY
!              PLOTS ARE BEING GENERATED.
!
!     INPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED VERTICALLY.
!                    --X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED HORIZONTALLY.
!                    --CHAR   = THE SINGLE PRECISION VECTOR OF
!                               OBSERVATIONS WHICH CONTROL THE
!                               VALUE OF EACH INDIVIDUAL PLOT
!                               CHARACTER.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR Y.
!                    --YMIN   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MINIMUM FOR THE VERTICAL AXIS.
!                    --YMAX   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MAXIMUM FOR THE VERTICAL AXIS.
!                    --XMIN   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MINIMUM FOR THE HORIZONTAL AXIS.
!                    --XMAX   = THE SINGLE PRECISION VALUE OF
!                               DESIRED MAXIMUM FOR THE HORIZONTAL AXIS.
!                    --YAXID  = THE HOLLARITH VALUE
!                               (AT MOST 6 CHARACTERS)
!                               OF THE DESIRED LABEL FOR THE
!                               VERTICAL AXIS VARIABLE.
!                    --XAXID  = THE HOLLARITH VALUE
!                               (AT MOST 6 CHARACTERS)
!                               OF THE DESIRED LABEL FOR THE
!                               HORIZONTAL AXIS VARIABLE.
!                    --PLCHID = THE HOLLARITH VALUE
!                               (AT MOST 6 CHARACTERS)
!                               OF THE DESIRED LABEL FOR THE
!                               PLOTTING CHARACTER VARIABLE.
!     OUTPUT--A ONE-PAGE PRINTER PLOT OF Y(I) VERSUS X(I),
!             WITH SPECIAL PLOT CHARACTERS,
!             WITH SPECIFIED AXIS LIMITS,
!             AND WITH SPECIFIED LABELS.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--VALUES IN THE VERTICAL AXIS VECTOR (Y)
!              WHICH ARE SMALLER THAN YMIN OR LARGER THAN YMAX,
!              OR VALUES IN THE HORIZONTAL AXIS VECTOR (X)
!              WHICH ARE SMALLER THAN XMIN OR LARGER THAN XMAX
!              WILL NOT BE PLOTTED.
!            --VALUES IN THE VERTICAL AXIS VECTOR (Y),
!              THE HORIZONTAL AXIS VECTOR (X),
!              OR THE PLOT CHARACTER VECTOR (CHAR) WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR Y
!              (OR X, OR CHAR) ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR Y
!              (OR X, OR CHAR) FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN Y (OR X, OR CHAR) TO BE
!              PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN Y (OR X, OR CHAR) TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOTC
!              SUBROUTINE.
!     REFERENCES--FILLIBEN, 'STATISTICAL ANALYSIS OF INTERLAB
!                 FATIGUE TIME DATA', UNPUBLISHED MANUSCRIPT
!                 (AVAILABLE FROM AUTHOR)
!                 PRESENTED AT THE 'COMPUTER-ASSISTED DATA
!                 ANALYSIS' SESSION AT THE NATIONAL MEETING
!                 OF THE AMERICAN STATISTICAL ASSOCIATION,
!                 NEW YORK CITY, DECEMBER 27-30, 1973.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --JUNE      1974.
!     UPDATED         --OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --FEBRUARY  1977.
!     UPDATED         --JUNE      1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 IGRaph
      CHARACTER*4 iplotc
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22 , alph31 , alph32
      CHARACTER*4 alph41 , alph42
      CHARACTER*4 blank , hyphen , alphai , alphax
      CHARACTER*4 alpham , alphaa , alphad , alphan , equal
!
      DIMENSION Y(1)
      DIMENSION X(1)
      DIMENSION Char(1)
      DIMENSION ylable(11)
      DIMENSION iplotc(37)
      COMMON /BLOCK1/ IGRaph(55,130)
!
      DATA sbnam1 , sbnam2/'PLOT' , '9   '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA alph31 , alph32/'THIR' , 'D   '/
      DATA alph41 , alph42/'FOUR' , 'TH  '/
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
      DATA alpham , alphaa , alphad , alphan , equal/'M' , 'A' , 'D' ,  &
     &     'N' , '='/
      DATA iplotc(1) , iplotc(2) , iplotc(3) , iplotc(4) , iplotc(5) ,  &
     &     iplotc(6) , iplotc(7) , iplotc(8) , iplotc(9) , iplotc(10) , &
     &     iplotc(11) , iplotc(12) , iplotc(13) , iplotc(14) ,          &
     &     iplotc(15) , iplotc(16) , iplotc(17) , iplotc(18) ,          &
     &     iplotc(19) , iplotc(20) , iplotc(21) , iplotc(22) ,          &
     &     iplotc(23) , iplotc(24) , iplotc(25) , iplotc(26) ,          &
     &     iplotc(27) , iplotc(28) , iplotc(29) , iplotc(30) ,          &
     &     iplotc(31) , iplotc(32) , iplotc(33) , iplotc(34) ,          &
     &     iplotc(35) , iplotc(36) , iplotc(37)/'1' , '2' , '3' , '4' , &
     &     '5' , '6' , '7' , '8' , '9' , '0' , 'A' , 'B' , 'C' , 'D' ,  &
     &     'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' ,  &
     &     'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' ,  &
     &     'Y' , 'Z' , 'X'/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      WRITE (ipr,99001)
99001 FORMAT ('1')
      IF ( N<1 ) THEN
         WRITE (ipr,99014)
         WRITE (ipr,99015)
         WRITE (ipr,99016) alph41 , alph42 , sbnam1 , sbnam2
         WRITE (ipr,99002) N
99002    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99014)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99014)
            WRITE (ipr,99015)
            WRITE (ipr,99016) alph41 , alph42 , sbnam1 , sbnam2
            WRITE (ipr,99003) N
99003       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99014)
            RETURN
         ELSE
!
            hold = Y(1)
            DO i = 2 , N
               IF ( Y(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99014)
            WRITE (ipr,99015)
            WRITE (ipr,99016) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99017) hold
            WRITE (ipr,99014)
            RETURN
         ENDIF
 50      hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99014)
         WRITE (ipr,99015)
         WRITE (ipr,99016) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99017) hold
         WRITE (ipr,99014)
         RETURN
      ENDIF
 100  hold = Char(1)
      DO i = 2 , N
         IF ( Char(i)/=hold ) GOTO 200
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99004)
99004 FORMAT (' ','               NON-FATAL DIAGNOSTIC               ')
      WRITE (ipr,99016) alph31 , alph32 , sbnam1 , sbnam2
      WRITE (ipr,99017) hold
      WRITE (ipr,99014)
!
 200  DO i = 1 , N
         IF ( Y(i)<cutoff ) GOTO 300
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99016) alph11 , alph12 , sbnam1 , sbnam2
      WRITE (ipr,99018)
      WRITE (ipr,99019) cutoff
      WRITE (ipr,99014)
      RETURN
 300  DO i = 1 , N
         IF ( X(i)<cutoff ) GOTO 400
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99016) alph21 , alph22 , sbnam1 , sbnam2
      WRITE (ipr,99018)
      WRITE (ipr,99019) cutoff
      WRITE (ipr,99014)
      RETURN
 400  DO i = 1 , N
         IF ( Char(i)<cutoff ) GOTO 500
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99016) alph31 , alph32 , sbnam1 , sbnam2
      WRITE (ipr,99018)
      WRITE (ipr,99019) cutoff
      WRITE (ipr,99014)
      RETURN
!
 500  n2 = 0
      DO i = 1 , N
         IF ( Y(i)<cutoff .AND. X(i)<cutoff .AND. Char(i)<cutoff ) THEN
            n2 = n2 + 1
            IF ( n2>=2 ) GOTO 600
         ENDIF
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99005) alph11 , alph12 , alph21 , alph22 , alph31 ,    &
     &                  alph32
99005 FORMAT (' ','THE ',A4,A4,', ',A4,A4,', AND ',A4,A4)
      WRITE (ipr,99006) sbnam1 , sbnam2
99006 FORMAT (' ','INPUT ARGUMENTS TO THE ',A4,A4,' SUBROUTINE')
      WRITE (ipr,99007)
99007 FORMAT (' ','ARE SUCH THAT TOO MANY POINTS HAVE BEEN',            &
     &        ' EXCLUDED FROM THE PLOT.')
      WRITE (ipr,99008) n2
99008 FORMAT (' ','ONLY ',I3,' POINTS ARE LEFT TO BE PLOTTED.')
      WRITE (ipr,99014)
      RETURN
!
!-----START POINT-----------------------------------------------------
!
!     DETERMINE THE VALUES TO BE LISTED ON THE LEFT VERTICAL AXIS
!
 600  DO i = 1 , 9
         aim1 = i - 1
         ylable(i) = Ymax - (aim1/8.0)*(Ymax-Ymin)
      ENDDO
!
!     DETERMINE THE VALUES TO BE LISTED ON THE BOTTOM HORIZONTAL AXIS
!     DETERMINE XMID, X25 (=THE 25% POINT), AND
!     X75 (=THE 75% POINT)
!
      xmid = (Xmin+Xmax)/2.0
      x25 = 0.75*Xmin + 0.25*Xmax
      x75 = 0.25*Xmin + 0.75*Xmax
!
!     BLANK OUT THE GRAPH
!
      DO i = 1 , 45
         DO j = 1 , 109
            IGRaph(i,j) = blank
         ENDDO
      ENDDO
!
!     PRODUCE THE VERTICAL AXES
!
      DO i = 3 , 43
         IGRaph(i,5) = alphai
         IGRaph(i,109) = alphai
      ENDDO
      DO i = 3 , 43 , 5
         IGRaph(i,5) = hyphen
         IGRaph(i,109) = hyphen
      ENDDO
      IGRaph(3,1) = equal
      IGRaph(3,2) = alpham
      IGRaph(3,3) = alphaa
      IGRaph(3,4) = alphax
      IGRaph(23,1) = equal
      IGRaph(23,2) = alpham
      IGRaph(23,3) = alphai
      IGRaph(23,4) = alphad
      IGRaph(43,1) = equal
      IGRaph(43,2) = alpham
      IGRaph(43,3) = alphai
      IGRaph(43,4) = alphan
!
!     PRODUCE THE HORIZONTAL AXES
!
      DO j = 7 , 107
         IGRaph(1,j) = hyphen
         IGRaph(45,j) = hyphen
      ENDDO
      DO j = 7 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
      DO j = 20 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
!
!     DETERMINE THE (X,Y) PLOT POSITIONS
!
      ratioy = 40.0/(Ymax-Ymin)
      ratiox = 100.0/(Xmax-Xmin)
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  IF ( Y(i)>=Ymin .AND. Y(i)<=Ymax ) THEN
                     IF ( X(i)>=Xmin .AND. X(i)<=Xmax ) THEN
                        mx = ratiox*(X(i)-Xmin) + 0.5
                        mx = mx + 7
                        my = ratioy*(Y(i)-Ymin) + 0.5
                        my = 43 - my
                        iarg = 37
                        IF ( 0.5<Char(i) .AND. Char(i)<36.5 )           &
     &                       iarg = Char(i) + 0.5
                        IGRaph(my,mx) = iplotc(iarg)
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
!
!     WRITE OUT THE GRAPH
!
      DO i = 1 , 45
         ip2 = i + 2
         iflag = ip2 - (ip2/5)*5
         k = ip2/5
         IF ( iflag/=0 ) WRITE (ipr,99009) (IGRaph(i,j),j=1,109)
99009    FORMAT (' ',20X,109A1)
         IF ( iflag==0 ) WRITE (ipr,99010) ylable(k) ,                  &
     &                          (IGRaph(i,j),j=1,109)
99010    FORMAT (' ',F20.7,109A1)
      ENDDO
      WRITE (ipr,99011) Xmin , x25 , xmid , x75 , Xmax
99011 FORMAT (' ',14X,F20.7,5X,F20.7,5X,F20.7,5X,F20.7,1X,F20.7)
!
      WRITE (ipr,99012) Yaxid , Xaxid , Plchid
99012 FORMAT (' ',9X,A4,A4,' (VERTICAL AXIS) VERSUS ',A4,A4,            &
     &        ' (HORIZONTAL AXIS)',20X,'THE PLOTTING CHARACTER IS ',A4, &
     &        A4)
      WRITE (ipr,99013) N
99013 FORMAT (' ',83X,'THE NUMBER OF OBSERVATIONS PLOTTED IS ',I8)
!
99014 FORMAT (' ','**************************************************', &
     &        '********************')
99015 FORMAT (' ','                   FATAL ERROR                    ')
99016 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
99017 FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
99018 FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
99019 FORMAT (' ','VALUE OF ',E15.8)
!
      END SUBROUTINE PLOT9
!*==plotc.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOTC(Y,X,Char,N)
      IMPLICIT NONE
!*--PLOTC18092
!*** Start of declarations inserted by SPAG
      REAL aim1 , Char , cutoff , hold , ratiox , ratioy , X , x25 ,    &
     &     x75 , xmax , xmid , xmin , Y , ylable , ymax , ymin
      INTEGER i , iarg , iflag , ip2 , ipr , j , k , mx , my , N , n2
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOTC
!
!     PURPOSE--THIS SUBROUTINE YIELDS A ONE-PAGE PRINTER PLOT
!              OF Y(I) VERSUS X(I) WITH SPECIAL PLOTTING
!              CHARACTERS.
!              THIS 'SPECIAL PLOTTING CHARACTER' CAPABILITY
!              ALLOWS THE DATA ANALYST TO INCORPORATE INFORMATION
!              FROM A THIRD VARIABLE (ASIDE FROM Y AND X) INTO
!              THE PLOT.
!              THE PLOT CHARACTER USED AT THE I-TH PLOTTING
!              POSITION (THAT IS, AT THE COORDINATE (X(I),Y(I)))
!              WILL BE
!              1 IF CHAR(I) IS BETWEEN  0.5 AND  1.5
!              2 IF CHAR(I) IS BETWEEN  1.5 AND  2.5
!                .
!                .
!                .
!              9 IF CHAR(I) IS BETWEEN  8.5 AND  9.5
!              0 IF CHAR(I) IS BETWEEN  9.5 AND 10.5
!              A IF CHAR(I) IS BETWEEN 10.5 AND 11.5
!              B IF CHAR(I) IS BETWEEN 11.5 AND 12.5
!              C IF CHAR(I) IS BETWEEN 12.5 AND 13.5
!                .
!                .
!                .
!              W IF CHAR(I) IS BETWEEN 32.5 AND 33.5
!              X IF CHAR(I) IS BETWEEN 33.5 AND 34.5
!              Y IF CHAR(I) IS BETWEEN 34.5 AND 35.5
!              Z IF CHAR(I) IS BETWEEN 35.5 AND 36.5
!              X IF CHAR(I) IS ANY VALUE OUTSIDE THE RANGE
!                                       0.5 TO  36.5.
!     INPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED VERTICALLY.
!                    --X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED HORIZONTALLY.
!                    --CHAR   = THE SINGLE PRECISION VECTOR OF
!                               OBSERVATIONS WHICH CONTROL THE
!                               VALUE OF EACH INDIVIDUAL PLOT
!                               CHARACTER.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR Y.
!     OUTPUT--A ONE-PAGE PRINTER PLOT OF Y(I) VERSUS X(I)
!             WITH SPECIAL PLOT CHARACTERS.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--VALUES IN THE VERTICAL AXIS VECTOR (Y),
!              THE HORIZONTAL AXIS VECTOR (X),
!              OR THE PLOT CHARACTER VECTOR (CHAR) WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR Y
!              (OR X, OR CHAR) ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR Y
!              (OR X, OR CHAR) FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN Y (OR X, OR CHAR) TO BE
!              PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN Y (OR X, OR CHAR) TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOTC
!              SUBROUTINE.
!     REFERENCES--FILLIBEN, 'STATISTICAL ANALYSIS OF INTERLAB
!                 FATIGUE TIME DATA', UNPUBLISHED MANUSCRIPT
!                 (AVAILABLE FROM AUTHOR)
!                 PRESENTED AT THE 'COMPUTER-ASSISTED DATA
!                 ANALYSIS' SESSION AT THE NATIONAL MEETING
!                 OF THE AMERICAN STATISTICAL ASSOCIATION,
!                 NEW YORK CITY, DECEMBER 27-30, 1973.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--OCTOBER   1974.
!     UPDATED         --NOVEMBER  1974.
!     UPDATED         --JANUARY   1975.
!     UPDATED         --JULY      1975.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --FEBRUARY  1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 IGRaph
      CHARACTER*4 iplotc
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22 , alph31 , alph32
      CHARACTER*4 alph41 , alph42
      CHARACTER*4 blank , hyphen , alphai , alphax
      CHARACTER*4 alpham , alphaa , alphad , alphan , equal
!
      DIMENSION Y(1)
      DIMENSION X(1)
      DIMENSION Char(1)
      DIMENSION ylable(11)
      DIMENSION iplotc(37)
      COMMON /BLOCK1/ IGRaph(55,130)
!
      DATA sbnam1 , sbnam2/'PLOT' , 'C   '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA alph31 , alph32/'THIR' , 'D   '/
      DATA alph41 , alph42/'FOUR' , 'TH  '/
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
      DATA alpham , alphaa , alphad , alphan , equal/'M' , 'A' , 'D' ,  &
     &     'N' , '='/
      DATA iplotc(1) , iplotc(2) , iplotc(3) , iplotc(4) , iplotc(5) ,  &
     &     iplotc(6) , iplotc(7) , iplotc(8) , iplotc(9) , iplotc(10) , &
     &     iplotc(11) , iplotc(12) , iplotc(13) , iplotc(14) ,          &
     &     iplotc(15) , iplotc(16) , iplotc(17) , iplotc(18) ,          &
     &     iplotc(19) , iplotc(20) , iplotc(21) , iplotc(22) ,          &
     &     iplotc(23) , iplotc(24) , iplotc(25) , iplotc(26) ,          &
     &     iplotc(27) , iplotc(28) , iplotc(29) , iplotc(30) ,          &
     &     iplotc(31) , iplotc(32) , iplotc(33) , iplotc(34) ,          &
     &     iplotc(35) , iplotc(36) , iplotc(37)/'1' , '2' , '3' , '4' , &
     &     '5' , '6' , '7' , '8' , '9' , '0' , 'A' , 'B' , 'C' , 'D' ,  &
     &     'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' ,  &
     &     'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' ,  &
     &     'Y' , 'Z' , 'X'/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      WRITE (ipr,99001)
99001 FORMAT ('1')
      IF ( N<1 ) THEN
         WRITE (ipr,99012)
         WRITE (ipr,99013)
         WRITE (ipr,99014) alph41 , alph42 , sbnam1 , sbnam2
         WRITE (ipr,99002) N
99002    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99012)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99012)
            WRITE (ipr,99013)
            WRITE (ipr,99014) alph41 , alph42 , sbnam1 , sbnam2
            WRITE (ipr,99003) N
99003       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99012)
            RETURN
         ELSE
!
            hold = Y(1)
            DO i = 2 , N
               IF ( Y(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99012)
            WRITE (ipr,99013)
            WRITE (ipr,99014) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99015) hold
            WRITE (ipr,99012)
            RETURN
         ENDIF
 50      hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99012)
         WRITE (ipr,99013)
         WRITE (ipr,99014) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99015) hold
         WRITE (ipr,99012)
         RETURN
      ENDIF
 100  hold = Char(1)
      DO i = 2 , N
         IF ( Char(i)/=hold ) GOTO 200
      ENDDO
      WRITE (ipr,99012)
      WRITE (ipr,99004)
99004 FORMAT (' ','               NON-FATAL DIAGNOSTIC               ')
      WRITE (ipr,99014) alph31 , alph32 , sbnam1 , sbnam2
      WRITE (ipr,99015) hold
      WRITE (ipr,99012)
!
 200  DO i = 1 , N
         IF ( Y(i)<cutoff ) GOTO 300
      ENDDO
      WRITE (ipr,99012)
      WRITE (ipr,99013)
      WRITE (ipr,99014) alph11 , alph12 , sbnam1 , sbnam2
      WRITE (ipr,99016)
      WRITE (ipr,99017) cutoff
      WRITE (ipr,99012)
      RETURN
 300  DO i = 1 , N
         IF ( X(i)<cutoff ) GOTO 400
      ENDDO
      WRITE (ipr,99012)
      WRITE (ipr,99013)
      WRITE (ipr,99014) alph21 , alph22 , sbnam1 , sbnam2
      WRITE (ipr,99016)
      WRITE (ipr,99017) cutoff
      WRITE (ipr,99012)
      RETURN
 400  DO i = 1 , N
         IF ( Char(i)<cutoff ) GOTO 500
      ENDDO
      WRITE (ipr,99012)
      WRITE (ipr,99013)
      WRITE (ipr,99014) alph31 , alph32 , sbnam1 , sbnam2
      WRITE (ipr,99016)
      WRITE (ipr,99017) cutoff
      WRITE (ipr,99012)
      RETURN
!
 500  n2 = 0
      DO i = 1 , N
         IF ( Y(i)<cutoff .AND. X(i)<cutoff .AND. Char(i)<cutoff ) THEN
            n2 = n2 + 1
            IF ( n2>=2 ) GOTO 600
         ENDIF
      ENDDO
      WRITE (ipr,99012)
      WRITE (ipr,99013)
      WRITE (ipr,99005) alph11 , alph12 , alph21 , alph22 , alph31 ,    &
     &                  alph32
99005 FORMAT (' ','THE ',A4,A4,', ',A4,A4,', AND ',A4,A4)
      WRITE (ipr,99006) sbnam1 , sbnam2
99006 FORMAT (' ','INPUT ARGUMENTS TO THE ',A4,A4,' SUBROUTINE')
      WRITE (ipr,99007)
99007 FORMAT (' ','ARE SUCH THAT TOO MANY POINTS HAVE BEEN',            &
     &        ' EXCLUDED FROM THE PLOT.')
      WRITE (ipr,99008) n2
99008 FORMAT (' ','ONLY ',I3,' POINTS ARE LEFT TO BE PLOTTED.')
      WRITE (ipr,99012)
      RETURN
!
!-----START POINT-----------------------------------------------------
!
!     DETERMINE THE VALUES TO BE LISTED ON THE LEFT VERTICAL AXIS
!
 600  DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  ymin = Y(i)
                  ymax = Y(i)
                  EXIT
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  IF ( Y(i)<ymin ) ymin = Y(i)
                  IF ( Y(i)>ymax ) ymax = Y(i)
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      DO i = 1 , 9
         aim1 = i - 1
         ylable(i) = ymax - (aim1/8.0)*(ymax-ymin)
      ENDDO
!
!     DETERMINE THE VALUES TO BE LISTED ON THE BOTTOM HORIZONTAL AXIS
!     DETERMINE XMIN, XMAX, XMID, X25 (=THE 25% POINT), AND
!     X75 (=THE 75% POINT)
!
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  xmin = X(i)
                  xmax = X(i)
                  EXIT
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  IF ( X(i)<xmin ) xmin = X(i)
                  IF ( X(i)>xmax ) xmax = X(i)
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      xmid = (xmin+xmax)/2.0
      x25 = 0.75*xmin + 0.25*xmax
      x75 = 0.25*xmin + 0.75*xmax
!
!     BLANK OUT THE GRAPH
!
      DO i = 1 , 45
         DO j = 1 , 109
            IGRaph(i,j) = blank
         ENDDO
      ENDDO
!
!     PRODUCE THE VERTICAL AXES
!
      DO i = 3 , 43
         IGRaph(i,5) = alphai
         IGRaph(i,109) = alphai
      ENDDO
      DO i = 3 , 43 , 5
         IGRaph(i,5) = hyphen
         IGRaph(i,109) = hyphen
      ENDDO
      IGRaph(3,1) = equal
      IGRaph(3,2) = alpham
      IGRaph(3,3) = alphaa
      IGRaph(3,4) = alphax
      IGRaph(23,1) = equal
      IGRaph(23,2) = alpham
      IGRaph(23,3) = alphai
      IGRaph(23,4) = alphad
      IGRaph(43,1) = equal
      IGRaph(43,2) = alpham
      IGRaph(43,3) = alphai
      IGRaph(43,4) = alphan
!
!     PRODUCE THE HORIZONTAL AXES
!
      DO j = 7 , 107
         IGRaph(1,j) = hyphen
         IGRaph(45,j) = hyphen
      ENDDO
      DO j = 7 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
      DO j = 20 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
!
!     DETERMINE THE (X,Y) PLOT POSITIONS
!
      ratioy = 40.0/(ymax-ymin)
      ratiox = 100.0/(xmax-xmin)
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  mx = ratiox*(X(i)-xmin) + 0.5
                  mx = mx + 7
                  my = ratioy*(Y(i)-ymin) + 0.5
                  my = 43 - my
                  iarg = 37
                  IF ( 0.5<Char(i) .AND. Char(i)<36.5 ) iarg = Char(i)  &
     &                 + 0.5
                  IGRaph(my,mx) = iplotc(iarg)
               ENDIF
            ENDIF
         ENDIF
      ENDDO
!
!     WRITE OUT THE GRAPH
!
      DO i = 1 , 45
         ip2 = i + 2
         iflag = ip2 - (ip2/5)*5
         k = ip2/5
         IF ( iflag/=0 ) WRITE (ipr,99009) (IGRaph(i,j),j=1,109)
!
99009    FORMAT (' ',20X,109A1)
         IF ( iflag==0 ) WRITE (ipr,99010) ylable(k) ,                  &
     &                          (IGRaph(i,j),j=1,109)
99010    FORMAT (' ',F20.7,109A1)
      ENDDO
      WRITE (ipr,99011) xmin , x25 , xmid , x75 , xmax
99011 FORMAT (' ',14X,F20.7,5X,F20.7,5X,F20.7,5X,F20.7,1X,F20.7)
!
99012 FORMAT (' ','**************************************************', &
     &        '********************')
99013 FORMAT (' ','                   FATAL ERROR                    ')
99014 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
99015 FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
99016 FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
99017 FORMAT (' ','VALUE OF ',E15.8)
!
      END SUBROUTINE PLOTC
!*==plotco.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOTCO(Y,N)
      IMPLICIT NONE
!*--PLOTCO18497
!*** Start of declarations inserted by SPAG
      REAL hold , ratioy , Y , ylable , ymax , ymin
      INTEGER i , iaxdel , idel , iflag , imax , imin , ipr , ix ,      &
     &        ixmax , ixmin , iz , j , jmax , jmin , k , mx , my , N ,  &
     &        numpag
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOTCO
!
!     THIS ROUTINE YIELDS A MULTI-PAGE (IF NECESSARY) PLOT OF THE AUTOCORRELATIO
!     COEFFICIENT R(K) VERSUS THE LAG K
!     THERE IS NO RESTRICTION ON THE MAXIMUM VALUE OF N FOR THIS ROUTINE.
!     PRINTING--YES
!     SUBROUTINES NEEDED--NONE
!     WRITTEN BY JAMES J. FILLIBEN, STATISTICAL ENGINEERING LABORATORY (205.03)
!     NATIONAL BUREAU OF STANDARDS, WASHINGTON, D.C. 20234     JUN 1972
!                                                      UPDATED FEB 1975
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 IGRaph
      CHARACTER*4 blank , star , hyphen , alphai
      DIMENSION Y(1)
      COMMON /BLOCK1/ IGRaph(55,130)
      DIMENSION ylable(11)
      DIMENSION ix(25)
!
      DATA blank , star , hyphen , alphai/' ' , '*' , '-' , 'I'/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE PLOTCO SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE PLOT&
     &CO SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         hold = Y(1)
         DO i = 2 , N
            IF ( Y(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE PLOTCO SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
!     DETERMINE THE Y VALUES TO BE LISTED ON THE LEFT VERTICAL AXIS
!
 50      ymin = -1.0
         ymax = 1.0
         DO i = 1 , 11
            ylable(i) = FLOAT(6-i)/5.0
         ENDDO
!
!     DETERMINE DISTANCES BETWEEN HORIZONTAL PLOT POINTS AND DISTANCES BETWEEN
!     HASH MARKS ON THE X AXIS
!
         IF ( N<=24 ) idel = 5
         IF ( 25<=N .AND. N<=40 ) idel = 3
         IF ( 41<=N .AND. N<=60 ) idel = 2
         IF ( 61<=N ) idel = 1
         iaxdel = 10
         IF ( N<=24 ) iaxdel = 5
         IF ( 25<=N .AND. N<=40 ) iaxdel = 15
!
!     DETERMINE THE NUMBER OF PAGES THE PLOT WILL TAKE UP
!
         numpag = ((N-1)/120) + 1
!
!     OPERATE  ON EACH PAGE
!
         DO iz = 1 , numpag
!
!     DETERMINE THE X-AXIS VALUES
!
            ixmin = 0
            ixmax = N
            IF ( N<=24 ) THEN
               DO i = 1 , 25
                  ix(i) = i - 1
               ENDDO
            ELSEIF ( 25<=N .AND. N<=40 ) THEN
               DO i = 1 , 9
                  ix(i) = 5*(i-1)
               ENDDO
            ELSEIF ( 41<=N .AND. N<=60 ) THEN
               DO i = 1 , 13
                  ix(i) = 5*(i-1)
               ENDDO
            ELSE
               ixmax = 120*iz
               ixmin = ixmax - 120
               i = 0
               DO
                  i = i + 1
                  ix(i) = ixmin + 10*(i-1)
                  IF ( i>=13 ) EXIT
               ENDDO
            ENDIF
!
!     BLANK OUT THE GRAPH
!
            DO i = 1 , 55
               DO j = 1 , 130
                  IGRaph(i,j) = blank
               ENDDO
            ENDDO
!
!     PRODUCE THE Y AXIS
!
            DO i = 5 , 55
               IGRaph(i,10) = alphai
               IGRaph(i,130) = alphai
            ENDDO
            DO i = 5 , 55 , 5
               IGRaph(i,10) = hyphen
               IGRaph(i,130) = hyphen
            ENDDO
!
!     PRODUCE THE X AXIS
!
            DO j = 10 , 130
               IGRaph(55,j) = hyphen
               IGRaph(30,j) = hyphen
               IGRaph(5,j) = hyphen
            ENDDO
            DO j = 10 , 130 , iaxdel
               IGRaph(55,j) = alphai
               IGRaph(5,j) = alphai
            ENDDO
!
!     DETERMINE THE (X,Y) PLOT POSITIONS
!
            imin = ixmin + 1
            imax = ixmax
            IF ( imax>N ) imax = N
            ratioy = 50.0/(ymax-ymin)
            DO i = imin , imax
               mx = MOD(i,120)
               mx = mx*idel
               IF ( mx==0 ) mx = 120
               mx = mx + 10
               my = ratioy*(Y(i)-ymin) + 0.5
               my = 55 - my
               IGRaph(my,mx) = star
               jmax = MAX0(my,30)
               jmin = MIN0(my,30)
               DO j = jmin , jmax
                  IGRaph(j,mx) = star
               ENDDO
            ENDDO
!
!     WRITE OUT THE GRAPH
!
            WRITE (ipr,99005)
99005       FORMAT ('1')
            IF ( iz==1 ) WRITE (ipr,99006) N
99006       FORMAT (                                                    &
     &          ' THE TOTAL NUMBER OF POINTS PLOTTED (ON ALL PAGES) IS '&
     &          ,I5)
            IF ( iz>=2 ) WRITE (ipr,99007)
99007       FORMAT (' ',                                                &
     &'THE PLOT ON THIS PAGE IS A CONTINUATION OF THE PLOT ON THE PREVIO&
     &US PAGE')
            WRITE (ipr,99008)
99008       FORMAT (' ')
            IF ( N<=24 ) WRITE (ipr,99011) (ix(i),i=1,25)
            IF ( 25<=N .AND. N<=40 ) WRITE (ipr,99012) (ix(i),i=1,9)
            IF ( 41<=N ) WRITE (ipr,99013) (ix(i),i=1,13)
            DO i = 5 , 55
               iflag = i - (i/5)*5
               k = i/5
               IF ( iflag/=0 ) WRITE (ipr,99009) (IGRaph(i,j),j=1,130)
99009          FORMAT (' ',130A1)
               IF ( iflag==0 ) WRITE (ipr,99010) ylable(k) ,            &
     &                                (IGRaph(i,j),j=10,130)
99010          FORMAT (' ',F9.2,130A1)
            ENDDO
            IF ( N<=24 ) WRITE (ipr,99011) (ix(i),i=1,25)
            IF ( 25<=N .AND. N<=40 ) WRITE (ipr,99012) (ix(i),i=1,9)
            IF ( 41<=N ) WRITE (ipr,99013) (ix(i),i=1,13)
         ENDDO
      ENDIF
99011 FORMAT (' ',6X,24(I4,1X),I4)
99012 FORMAT (' ',6X,8(I4,11X),I4)
99013 FORMAT (' ',6X,12(I4,6X),I4)
      END SUBROUTINE PLOTCO
!*==plotct.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOTCT(Y,X,Char,N)
      IMPLICIT NONE
!*--PLOTCT18703
!*** Start of declarations inserted by SPAG
      REAL aim1 , airow , anumcm , anumlm , anumr , anumrm , Char ,     &
     &     cutoff , delx , dely , hold , X , xlable , xmax , xmin ,     &
     &     xwidth , Y , ylable , ylower , ymax
      REAL ymin , yupper , ywidth
      INTEGER i , ia , icol , icolmx , ipr , irow , ixdel , N , n2 ,    &
     &        numcol , numlab , numr25 , numr50 , numr75 , numrow
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOTCT
!
!     PURPOSE--THIS SUBROUTINE YIELDS A NARROW-WIDTH (71-CHARACTER)
!              PLOT OF Y(I) VERSUS X(I) WITH SPECIAL PLOTTING
!              CHARACTERS.
!              ITS NARROW WIDTH MAKES IT APPROPRIATE FOR USE ON A
!              TERMINAL.
!              THIS 'SPECIAL PLOTTING CHARACTER' CAPABILITY
!              ALLOWS THE DATA ANALYST TO INCORPORATE INFORMATION
!              FROM A THIRD VARIABLE (ASIDE FROM Y AND X) INTO
!              THE PLOT.
!              THE PLOT CHARACTER USED AT THE I-TH PLOTTING
!              POSITION (THAT IS, AT THE COORDINATE (X(I),Y(I)))
!              WILL BE
!              1 IF CHAR(I) IS BETWEEN  0.5 AND  1.5
!              2 IF CHAR(I) IS BETWEEN  1.5 AND  2.5
!                .
!                .
!                .
!              9 IF CHAR(I) IS BETWEEN  8.5 AND  9.5
!              0 IF CHAR(I) IS BETWEEN  9.5 AND 10.5
!              A IF CHAR(I) IS BETWEEN 10.5 AND 11.5
!              B IF CHAR(I) IS BETWEEN 11.5 AND 12.5
!              C IF CHAR(I) IS BETWEEN 12.5 AND 13.5
!                .
!                .
!                .
!              W IF CHAR(I) IS BETWEEN 32.5 AND 33.5
!              X IF CHAR(I) IS BETWEEN 33.5 AND 34.5
!              Y IF CHAR(I) IS BETWEEN 34.5 AND 35.5
!              Z IF CHAR(I) IS BETWEEN 35.5 AND 36.5
!              X IF CHAR(I) IS ANY VALUE OUTSIDE THE RANGE
!                                       0.5 TO  36.5.
!     INPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED VERTICALLY.
!                    --X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED HORIZONTALLY.
!                    --CHAR   = THE SINGLE PRECISION VECTOR OF
!                               OBSERVATIONS WHICH CONTROL THE
!                               VALUE OF EACH INDIVIDUAL PLOT
!                               CHARACTER.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR Y.
!     OUTPUT--A NARROW-WIDTH (71-CHARACTER) TERMINAL PLOT
!             OF Y(I) VERSUS X(I) WITH SPECIAL PLOT CHARACTERS.
!             THE BODY OF THE PLOT (NOT COUNTING AXIS VALUES
!             AND MARGINS) IS 25 ROWS (LINES) AND 49 COLUMNS.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--VALUES IN THE VERTICAL AXIS VECTOR (Y),
!              THE HORIZONTAL AXIS VECTOR (X),
!              OR THE PLOT CHARACTER VECTOR (CHAR) WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR Y
!              (OR X, OR CHAR) ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR Y
!              (OR X, OR CHAR) FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN Y (OR X, OR CHAR) TO BE
!              PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN Y (OR X, OR CHAR) TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOTC
!              SUBROUTINE.
!            --NOTE THAT THE STORAGE REQUIREMENTS FOR THIS
!              (AND THE OTHER) TERMINAL PLOT SUBROUTINESS ARE .
!              VERY SMALL.
!              THIS IS DUE TO THE 'ONE LINE AT A TIME' ALGORITHM
!              EMPLOYED FOR THE PLOT.
!     REFERENCES--FILLIBEN, 'STATISTICAL ANALYSIS OF INTERLAB
!                 FATIGUE TIME DATA', UNPUBLISHED MANUSCRIPT
!                 (AVAILABLE FROM AUTHOR)
!                 PRESENTED AT THE 'COMPUTER-ASSISTED DATA
!                 ANALYSIS' SESSION AT THE NATIONAL MEETING
!                 OF THE AMERICAN STATISTICAL ASSOCIATION,
!                 NEW YORK CITY, DECEMBER 27-30, 1973.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--FEBRUARY  1974.
!     UPDATED         --APRIL     1974.
!     UPDATED         --OCTOBER   1974.
!     UPDATED         --OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 iline
      CHARACTER*4 iplotc
      CHARACTER*4 jplotc
      CHARACTER*4 iaxisc
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22 , alph31 , alph32
      CHARACTER*4 alph41 , alph42
      CHARACTER*4 blank , hyphen , alphai
!
      DIMENSION Y(1)
      DIMENSION X(1)
      DIMENSION Char(1)
      DIMENSION iline(72) , xlable(10)
      DIMENSION iplotc(37)
!
      DATA sbnam1 , sbnam2/'PLOT' , 'CT  '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA alph31 , alph32/'THIR' , 'D   '/
      DATA alph41 , alph42/'FOUR' , 'TH  '/
      DATA blank , hyphen , alphai/' ' , '-' , 'I'/
      DATA iplotc(1) , iplotc(2) , iplotc(3) , iplotc(4) , iplotc(5) ,  &
     &     iplotc(6) , iplotc(7) , iplotc(8) , iplotc(9) , iplotc(10) , &
     &     iplotc(11) , iplotc(12) , iplotc(13) , iplotc(14) ,          &
     &     iplotc(15) , iplotc(16) , iplotc(17) , iplotc(18) ,          &
     &     iplotc(19) , iplotc(20) , iplotc(21) , iplotc(22) ,          &
     &     iplotc(23) , iplotc(24) , iplotc(25) , iplotc(26) ,          &
     &     iplotc(27) , iplotc(28) , iplotc(29) , iplotc(30) ,          &
     &     iplotc(31) , iplotc(32) , iplotc(33) , iplotc(34) ,          &
     &     iplotc(35) , iplotc(36) , iplotc(37)/'1' , '2' , '3' , '4' , &
     &     '5' , '6' , '7' , '8' , '9' , '0' , 'A' , 'B' , 'C' , 'D' ,  &
     &     'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' ,  &
     &     'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' ,  &
     &     'Y' , 'Z' , 'X'/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99012)
         WRITE (ipr,99013)
         WRITE (ipr,99014) alph41 , alph42 , sbnam1 , sbnam2
         WRITE (ipr,99001) N
99001    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99012)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99012)
            WRITE (ipr,99013)
            WRITE (ipr,99014) alph41 , alph42 , sbnam1 , sbnam2
            WRITE (ipr,99002) N
99002       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99012)
            RETURN
         ELSE
!
            hold = Y(1)
            DO i = 2 , N
               IF ( Y(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99012)
            WRITE (ipr,99013)
            WRITE (ipr,99014) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99015) hold
            WRITE (ipr,99012)
            RETURN
         ENDIF
 50      hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99012)
         WRITE (ipr,99013)
         WRITE (ipr,99014) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99015) hold
         WRITE (ipr,99012)
         RETURN
      ENDIF
 100  hold = Char(1)
      DO i = 2 , N
         IF ( Char(i)/=hold ) GOTO 200
      ENDDO
      WRITE (ipr,99012)
      WRITE (ipr,99003)
99003 FORMAT (' ','               NON-FATAL DIAGNOSTIC               ')
      WRITE (ipr,99014) alph31 , alph32 , sbnam1 , sbnam2
      WRITE (ipr,99015) hold
      WRITE (ipr,99012)
!
 200  DO i = 1 , N
         IF ( Y(i)<cutoff ) GOTO 300
      ENDDO
      WRITE (ipr,99012)
      WRITE (ipr,99013)
      WRITE (ipr,99014) alph11 , alph12 , sbnam1 , sbnam2
      WRITE (ipr,99016)
      WRITE (ipr,99017) cutoff
      WRITE (ipr,99012)
      RETURN
 300  DO i = 1 , N
         IF ( X(i)<cutoff ) GOTO 400
      ENDDO
      WRITE (ipr,99012)
      WRITE (ipr,99013)
      WRITE (ipr,99014) alph21 , alph22 , sbnam1 , sbnam2
      WRITE (ipr,99016)
      WRITE (ipr,99017) cutoff
      WRITE (ipr,99012)
      RETURN
 400  DO i = 1 , N
         IF ( Char(i)<cutoff ) GOTO 500
      ENDDO
      WRITE (ipr,99012)
      WRITE (ipr,99013)
      WRITE (ipr,99014) alph31 , alph32 , sbnam1 , sbnam2
      WRITE (ipr,99016)
      WRITE (ipr,99017) cutoff
      WRITE (ipr,99012)
      RETURN
!
 500  n2 = 0
      DO i = 1 , N
         IF ( Y(i)<cutoff .AND. X(i)<cutoff .AND. Char(i)<cutoff ) THEN
            n2 = n2 + 1
            IF ( n2>=2 ) GOTO 600
         ENDIF
      ENDDO
      WRITE (ipr,99012)
      WRITE (ipr,99013)
      WRITE (ipr,99004) alph11 , alph12 , alph21 , alph22 , alph31 ,    &
     &                  alph32
99004 FORMAT (' ','THE ',A4,A4,', ',A4,A4,', AND ',A4,A4)
      WRITE (ipr,99005) sbnam1 , sbnam2
99005 FORMAT (' ','INPUT ARGUMENTS TO THE ',A4,A4,' SUBROUTINE')
      WRITE (ipr,99006)
99006 FORMAT (' ','ARE SUCH THAT TOO MANY POINTS HAVE BEEN',            &
     &        ' EXCLUDED FROM THE PLOT.')
      WRITE (ipr,99007) n2
99007 FORMAT (' ','ONLY ',I3,' POINTS ARE LEFT TO BE PLOTTED.')
      WRITE (ipr,99012)
      RETURN
!
!-----START POINT-----------------------------------------------------
!
!     DEFINE THE NUMBER OF ROWS AND COLUMNS WITHIN THE PLOT--THIS HAS
!     BEEN SET TO 25 ROWS AND 49 COLUMNS.
!
 600  numrow = 25
      numcol = 49
      anumr = numrow
      anumrm = numrow - 1
      anumcm = numcol - 1
      numr25 = (numrow/4) + 1
      numr50 = (numrow/2) + 1
      numr75 = 3*(numrow/4) + 1
      ixdel = (numcol-1)/4
      numlab = 5
      anumlm = numlab - 1
!
!     SKIP A LINE, WRITE OUT AN IDENTIFYING LINE FOR THE TYPE OF PLOT,
!     WRITE OUT THE TOP HORIZONTAL AXIS OF THE PLOT, AND SKIP 1 LINE
!     FOR A MARGIN WITHIN THE PLOT.
!
      WRITE (ipr,99008)
99008 FORMAT (' ')
      WRITE (ipr,99009)
!
99009 FORMAT (' ','THE FOLLOWING IS A PLOT OF Y(I) VERSUS X(I)')
      DO icol = 1 , numcol
         iline(icol) = hyphen
      ENDDO
      DO icol = 1 , numcol , ixdel
         iline(icol) = alphai
      ENDDO
      WRITE (ipr,99018) (iline(i),i=1,numcol)
      WRITE (ipr,99019) blank
!
!     DETERMINE THE MIN AND MAX VALUES OF Y, AND OF X.
!
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  ymin = Y(i)
                  ymax = Y(i)
                  xmin = X(i)
                  xmax = X(i)
                  EXIT
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  IF ( Y(i)<ymin ) ymin = Y(i)
                  IF ( Y(i)>ymax ) ymax = Y(i)
                  IF ( X(i)<xmin ) xmin = X(i)
                  IF ( X(i)>xmax ) xmax = X(i)
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      dely = ymax - ymin
      delx = xmax - xmin
      ywidth = dely/anumrm
      xwidth = delx/anumcm
!
!     DETERMINE AND WRITE OUT THE PLOT POSITIONS ONE LINE AT A TIME.
!     ALSO DETERMINE THE APPROPRIATE PLOT CHARACTERS.
!
      DO irow = 1 , numrow
         DO icol = 1 , numcol
            iline(icol) = blank
         ENDDO
         airow = irow
         yupper = ymax + (1.5-airow)*ywidth
         ylable = ymax + (1.0-airow)*ywidth
         ylower = ymax + (0.5-airow)*ywidth
         IF ( irow==numrow ) ylable = ymin
         DO i = 1 , N
            IF ( Y(i)<cutoff ) THEN
               IF ( X(i)<cutoff ) THEN
                  IF ( Char(i)<cutoff ) THEN
                     IF ( ylower<=Y(i) .AND. Y(i)<yupper ) THEN
                        icol = ((X(i)-xmin)/xwidth) + 1.5
                        ia = Char(i) + 0.5
                        IF ( 1<=ia .AND. ia<=36 ) THEN
                           jplotc = iplotc(ia)
                        ELSE
                           jplotc = iplotc(37)
                        ENDIF
                        iline(icol) = jplotc
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDDO
         icolmx = 1
         DO icol = 1 , numcol
            IF ( iline(icol)/=blank ) icolmx = icol
         ENDDO
         iaxisc = alphai
         IF ( irow==1 .OR. irow==numrow ) iaxisc = hyphen
         IF ( irow==numr25 .OR. irow==numr50 .OR. irow==numr75 )        &
     &        iaxisc = hyphen
         WRITE (ipr,99010) ylable , iaxisc , (iline(icol),icol=1,icolmx)
99010    FORMAT (' ',E14.7,1X,A1,2X,50A1)
      ENDDO
!
!     SKIP 1 LINE FOR A BOTTOM MARGIN WITHIN THE PLOT, WRITE OUT THE
!     BOTTOM HORIZONTAL AXIS, AND WRITE OUT THE X AXIS LABLES.
!
      WRITE (ipr,99019) blank
      DO icol = 1 , numcol
         iline(icol) = hyphen
      ENDDO
      DO icol = 1 , numcol , ixdel
         iline(icol) = alphai
      ENDDO
      WRITE (ipr,99018) (iline(icol),icol=1,numcol)
      DO i = 1 , numlab
         aim1 = i - 1
         xlable(i) = xmin + (aim1/anumlm)*delx
      ENDDO
      WRITE (ipr,99011) (xlable(i),i=1,numlab)
99011 FORMAT (' ',9X,5E12.4)
!
99012 FORMAT (' ','**************************************************', &
     &        '********************')
99013 FORMAT (' ','                   FATAL ERROR                    ')
99014 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
99015 FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
99016 FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
99017 FORMAT (' ','VALUE OF ',E15.8)
99018 FORMAT (' ',18X,54A1)
99019 FORMAT (' ',15X,A1)
!
      END SUBROUTINE PLOTCT
!*==plot.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOT(Y,X,N)
      IMPLICIT NONE
!*--PLOT15719
!*** Start of declarations inserted by SPAG
      REAL aim1 , cutoff , hold , ratiox , ratioy , X , x25 , x75 ,     &
     &     xmax , xmid , xmin , Y , ylable , ymax , ymin
      INTEGER i , iflag , ip2 , ipr , j , k , mx , my , N , n2
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOT
!
!     PURPOSE--THIS SUBROUTINE YIELDS A ONE-PAGE PRINTER PLOT
!              OF Y(I) VERSUS X(I).
!     INPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED VERTICALLY.
!                    --X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED HORIZONTALLY.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR Y.
!     OUTPUT--A ONE-PAGE PRINTER PLOT OF Y(I) VERSUS X(I).
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--VALUES IN THE VERTICAL AXIS VECTOR (Y)
!              OR THE HORIZONTAL AXIS VECTOR (X) WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR Y
!              (OR X) ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR Y
!              (OR X) FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN Y (OR X) TO BE PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN Y (OR X) TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOT
!              SUBROUTINE.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --OCTOBER   1974.
!     UPDATED         --NOVEMBER  1974.
!     UPDATED         --JANUARY   1975.
!     UPDATED         --JULY      1975.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --FEBRUARY  1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 IGRaph
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22 , alph31 , alph32
      CHARACTER*4 blank , hyphen , alphai , alphax
      CHARACTER*4 alpham , alphaa , alphad , alphan , equal
      DIMENSION Y(1)
      DIMENSION X(1)
      DIMENSION ylable(11)
      COMMON /BLOCK1/ IGRaph(55,130)
!
      DATA sbnam1 , sbnam2/'PLOT' , '    '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA alph31 , alph32/'THIR' , 'D   '/
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
      DATA alpham , alphaa , alphad , alphan , equal/'M' , 'A' , 'D' ,  &
     &     'N' , '='/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      WRITE (ipr,99001)
99001 FORMAT ('1')
      IF ( N<1 ) THEN
         WRITE (ipr,99011)
         WRITE (ipr,99012)
         WRITE (ipr,99013) alph31 , alph32 , sbnam1 , sbnam2
         WRITE (ipr,99002) N
99002    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99011)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99011)
            WRITE (ipr,99012)
            WRITE (ipr,99013) alph31 , alph32 , sbnam1 , sbnam2
            WRITE (ipr,99003) N
99003       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99011)
            RETURN
         ELSE
!
            hold = Y(1)
            DO i = 2 , N
               IF ( Y(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99011)
            WRITE (ipr,99012)
            WRITE (ipr,99013) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99014) hold
            WRITE (ipr,99011)
            RETURN
         ENDIF
 50      hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99011)
         WRITE (ipr,99012)
         WRITE (ipr,99013) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99014) hold
         WRITE (ipr,99011)
         RETURN
      ENDIF
!
 100  DO i = 1 , N
         IF ( Y(i)<cutoff ) GOTO 200
      ENDDO
      WRITE (ipr,99011)
      WRITE (ipr,99012)
      WRITE (ipr,99013) alph11 , alph12 , sbnam1 , sbnam2
      WRITE (ipr,99015)
      WRITE (ipr,99016) cutoff
      WRITE (ipr,99011)
      RETURN
 200  DO i = 1 , N
         IF ( X(i)<cutoff ) GOTO 300
      ENDDO
      WRITE (ipr,99011)
      WRITE (ipr,99012)
      WRITE (ipr,99013) alph21 , alph22 , sbnam1 , sbnam2
      WRITE (ipr,99015)
      WRITE (ipr,99016) cutoff
      WRITE (ipr,99011)
      RETURN
!
 300  n2 = 0
      DO i = 1 , N
         IF ( Y(i)<cutoff .AND. X(i)<cutoff ) THEN
            n2 = n2 + 1
            IF ( n2>=2 ) GOTO 400
         ENDIF
      ENDDO
      WRITE (ipr,99011)
      WRITE (ipr,99012)
      WRITE (ipr,99004) alph11 , alph12 , alph21 , alph22
99004 FORMAT (' ','THE ',A4,A4,', AND ',A4,A4)
      WRITE (ipr,99005) sbnam1 , sbnam2
99005 FORMAT (' ','INPUT ARGUMENTS TO THE ',A4,A4,' SUBROUTINE')
      WRITE (ipr,99006)
99006 FORMAT (' ','ARE SUCH THAT TOO MANY POINTS HAVE BEEN',            &
     &        ' EXCLUDED FROM THE PLOT.')
      WRITE (ipr,99007) n2
99007 FORMAT (' ','ONLY ',I3,' POINTS ARE LEFT TO BE PLOTTED.')
      WRITE (ipr,99011)
      RETURN
!
!-----START POINT-----------------------------------------------------
!
!     DETERMINE THE VALUES TO BE LISTED ON THE LEFT VERTICAL AXIS
!
 400  DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               ymin = Y(i)
               ymax = Y(i)
               EXIT
            ENDIF
         ENDIF
      ENDDO
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Y(i)<ymin ) ymin = Y(i)
               IF ( Y(i)>ymax ) ymax = Y(i)
            ENDIF
         ENDIF
      ENDDO
      DO i = 1 , 9
         aim1 = i - 1
         ylable(i) = ymax - (aim1/8.0)*(ymax-ymin)
      ENDDO
!
!     DETERMINE THE VALUES TO BE LISTED ON THE BOTTOM HORIZONTAL AXIS
!     DETERMINE XMIN, XMAX, XMID, X25 (=THE 25% POINT), AND
!     X75 (=THE 75% POINT)
!
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               xmin = X(i)
               xmax = X(i)
               EXIT
            ENDIF
         ENDIF
      ENDDO
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( X(i)<xmin ) xmin = X(i)
               IF ( X(i)>xmax ) xmax = X(i)
            ENDIF
         ENDIF
      ENDDO
      xmid = (xmin+xmax)/2.0
      x25 = 0.75*xmin + 0.25*xmax
      x75 = 0.25*xmin + 0.75*xmax
!
!     BLANK OUT THE GRAPH
!
      DO i = 1 , 45
         DO j = 1 , 109
            IGRaph(i,j) = blank
         ENDDO
      ENDDO
!
!     PRODUCE THE VERTICAL AXES
!
      DO i = 3 , 43
         IGRaph(i,5) = alphai
         IGRaph(i,109) = alphai
      ENDDO
      DO i = 3 , 43 , 5
         IGRaph(i,5) = hyphen
         IGRaph(i,109) = hyphen
      ENDDO
      IGRaph(3,1) = equal
      IGRaph(3,2) = alpham
      IGRaph(3,3) = alphaa
      IGRaph(3,4) = alphax
      IGRaph(23,1) = equal
      IGRaph(23,2) = alpham
      IGRaph(23,3) = alphai
      IGRaph(23,4) = alphad
      IGRaph(43,1) = equal
      IGRaph(43,2) = alpham
      IGRaph(43,3) = alphai
      IGRaph(43,4) = alphan
!
!     PRODUCE THE HORIZONTAL AXES
!
      DO j = 7 , 107
         IGRaph(1,j) = hyphen
         IGRaph(45,j) = hyphen
      ENDDO
      DO j = 7 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
      DO j = 20 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
!
!     DETERMINE THE (X,Y) PLOT POSITIONS
!
      ratioy = 40.0/(ymax-ymin)
      ratiox = 100.0/(xmax-xmin)
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               mx = ratiox*(X(i)-xmin) + 0.5
               mx = mx + 7
               my = ratioy*(Y(i)-ymin) + 0.5
               my = 43 - my
               IGRaph(my,mx) = alphax
            ENDIF
         ENDIF
      ENDDO
!
!     WRITE OUT THE GRAPH
!
      DO i = 1 , 45
         ip2 = i + 2
         iflag = ip2 - (ip2/5)*5
         k = ip2/5
         IF ( iflag/=0 ) WRITE (ipr,99008) (IGRaph(i,j),j=1,109)
!
99008    FORMAT (' ',20X,109A1)
         IF ( iflag==0 ) WRITE (ipr,99009) ylable(k) ,                  &
     &                          (IGRaph(i,j),j=1,109)
99009    FORMAT (' ',F20.7,109A1)
      ENDDO
      WRITE (ipr,99010) xmin , x25 , xmid , x75 , xmax
99010 FORMAT (' ',14X,F20.7,5X,F20.7,5X,F20.7,5X,F20.7,1X,F20.7)
!
99011 FORMAT (' ','**************************************************', &
     &        '********************')
99012 FORMAT (' ','                   FATAL ERROR                    ')
99013 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
99014 FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
99015 FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
99016 FORMAT (' ','VALUE OF ',E15.8)
!
      END SUBROUTINE PLOT
!*==plotsc.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOTSC(Y,X,Char,N,D,Dmin,Dmax)
      IMPLICIT NONE
!*--PLOTSC19492
!*** Start of declarations inserted by SPAG
      REAL aim1 , Char , cutoff , D , Dmax , Dmin , hold , ratiox ,     &
     &     ratioy , X , x25 , x75 , xmax , xmid , xmin , Y , ylable ,   &
     &     ymax , ymin
      INTEGER i , iarg , iflag , ip2 , ipr , j , k , mx , my , N , n2
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOTSC
!
!     PURPOSE--THIS SUBROUTINE YIELDS A ONE-PAGE PRINTER PLOT
!              OF Y(I) VERSUS X(I):
!              1) WITH SPECIAL PLOT CHARACTERS; AND
!              2) WITH ONLY THOSE POINTS (X(I),Y(I)) PLOTTED
!                 FOR WHICH THE CORRESPONDING VALUE OF D(I)
!                 IS BETWEEN THE SPECIFIED VALUES OF DMIN AND DMAX.
!
!              THE 'SPECIAL PLOTTING CHARACTER' CAPABILITY
!              ALLOWS THE DATA ANALYST TO INCORPORATE INFORMATION
!              FROM A THIRD VARIABLE (ASIDE FROM Y AND X) INTO
!              THE PLOT.
!              THE PLOT CHARACTER USED AT THE I-TH PLOTTING
!              POSITION (THAT IS, AT THE COORDINATE (X(I),Y(I)))
!              WILL BE
!              1 IF CHAR(I) IS BETWEEN  0.5 AND  1.5
!              2 IF CHAR(I) IS BETWEEN  1.5 AND  2.5
!                .
!                .
!                .
!              9 IF CHAR(I) IS BETWEEN  8.5 AND  9.5
!              0 IF CHAR(I) IS BETWEEN  9.5 AND 10.5
!              A IF CHAR(I) IS BETWEEN 10.5 AND 11.5
!              B IF CHAR(I) IS BETWEEN 11.5 AND 12.5
!              C IF CHAR(I) IS BETWEEN 12.5 AND 13.5
!                .
!                .
!                .
!              W IF CHAR(I) IS BETWEEN 32.5 AND 33.5
!              X IF CHAR(I) IS BETWEEN 33.5 AND 34.5
!              Y IF CHAR(I) IS BETWEEN 34.5 AND 35.5
!              Z IF CHAR(I) IS BETWEEN 35.5 AND 36.5
!              X IF CHAR(I) IS ANY VALUE OUTSIDE THE RANGE
!                                       0.5 TO  36.5.
!              THE USE OF THE SUBSET DEFINTION VECTOR D
!              GIVES THE DATA ANALYST THE CAPABILITY OF
!              PLOTTING SUBSETS OF THE DATA,
!              WHERE THE SUBSET IS DEFINED
!              BY VALUES IN THE VECTOR D.
!
!     INPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED VERTICALLY.
!                    --X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED HORIZONTALLY.
!                    --CHAR   = THE SINGLE PRECISION VECTOR OF
!                               OBSERVATIONS WHICH CONTROL THE
!                               VALUE OF EACH INDIVIDUAL PLOT
!                               CHARACTER.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR Y.
!                    --D      = THE SINGLE PRECISION VECTOR
!                               WHICH 'DEFINES' THE VARIOUS
!                               POSSIBLE SUBSETS.
!                    --DMIN   = THE SINGLE PRECISION VALUE
!                               WHICH DEFINES THE LOWER BOUND
!                               (INCLUSIVELY) OF THE PARTICULAR
!                               SUBSET OF INTEREST TO BE PLOTTED.
!                    --DMAX   = THE SINGLE PRECISION VALUE
!                               WHICH DEFINES THE UPPER BOUND
!                               (INCLUSIVELY) OF THE PARTICULAR
!                               SUBSET OF INTEREST TO BE PLOTTED.
!     OUTPUT--A ONE-PAGE PRINTER PLOT OF Y(I) VERSUS X(I),
!             WITH SPECIAL PLOT CHARACTERS,
!             AND FOR ONLY OF A SPECIFIED SUBSET OF THE DATA.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--FOR A GIVEN DUMMY INDEX I,
!              IF D(I) IS SMALLER THAN DMIN OR LARGER THAN DMAX,
!              THEN THE CORRESPONDING POINT (X(I),Y(I))
!              WILL NOT BE PLOTTED.
!            --VALUES IN THE VERTICAL AXIS VECTOR (Y),
!              THE HORIZONTAL AXIS VECTOR (X),
!              OR THE PLOT CHARACTER VECTOR (CHAR) WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR Y
!              (OR X, OR CHAR) ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR Y
!              (OR X, OR CHAR) FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN Y (OR X, OR CHAR) TO BE
!              PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN Y (OR X, OR CHAR) TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOTC
!              SUBROUTINE.
!     REFERENCES--FILLIBEN, 'STATISTICAL ANALYSIS OF INTERLAB
!                 FATIGUE TIME DATA', UNPUBLISHED MANUSCRIPT
!                 (AVAILABLE FROM AUTHOR)
!                 PRESENTED AT THE 'COMPUTER-ASSISTED DATA
!                 ANALYSIS' SESSION AT THE NATIONAL MEETING
!                 OF THE AMERICAN STATISTICAL ASSOCIATION,
!                 NEW YORK CITY, DECEMBER 27-30, 1973.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --FEBRUARY  1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 IGRaph
      CHARACTER*4 iplotc
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22 , alph31 , alph32
      CHARACTER*4 alph41 , alph42 , alph51 , alph52
      CHARACTER*4 blank , hyphen , alphai , alphax
      CHARACTER*4 alpham , alphaa , alphad , alphan , equal
!
      DIMENSION Y(1)
      DIMENSION X(1)
      DIMENSION D(1)
      DIMENSION Char(1)
      DIMENSION ylable(11)
      DIMENSION iplotc(37)
      COMMON /BLOCK1/ IGRaph(55,130)
!
      DATA sbnam1 , sbnam2/'PLOT' , 'SC  '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA alph31 , alph32/'THIR' , 'D   '/
      DATA alph41 , alph42/'FOUR' , 'TH  '/
      DATA alph51 , alph52/'FIFT' , 'H   '/
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
      DATA alpham , alphaa , alphad , alphan , equal/'M' , 'A' , 'D' ,  &
     &     'N' , '='/
      DATA iplotc(1) , iplotc(2) , iplotc(3) , iplotc(4) , iplotc(5) ,  &
     &     iplotc(6) , iplotc(7) , iplotc(8) , iplotc(9) , iplotc(10) , &
     &     iplotc(11) , iplotc(12) , iplotc(13) , iplotc(14) ,          &
     &     iplotc(15) , iplotc(16) , iplotc(17) , iplotc(18) ,          &
     &     iplotc(19) , iplotc(20) , iplotc(21) , iplotc(22) ,          &
     &     iplotc(23) , iplotc(24) , iplotc(25) , iplotc(26) ,          &
     &     iplotc(27) , iplotc(28) , iplotc(29) , iplotc(30) ,          &
     &     iplotc(31) , iplotc(32) , iplotc(33) , iplotc(34) ,          &
     &     iplotc(35) , iplotc(36) , iplotc(37)/'1' , '2' , '3' , '4' , &
     &     '5' , '6' , '7' , '8' , '9' , '0' , 'A' , 'B' , 'C' , 'D' ,  &
     &     'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' ,  &
     &     'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' ,  &
     &     'Y' , 'Z' , 'X'/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      WRITE (ipr,99001)
99001 FORMAT ('1')
      IF ( N<1 ) THEN
         WRITE (ipr,99014)
         WRITE (ipr,99015)
         WRITE (ipr,99017) alph41 , alph42 , sbnam1 , sbnam2
         WRITE (ipr,99002) N
99002    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99014)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99014)
            WRITE (ipr,99015)
            WRITE (ipr,99017) alph41 , alph42 , sbnam1 , sbnam2
            WRITE (ipr,99003) N
99003       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99014)
            RETURN
         ELSE
!
            hold = Y(1)
            DO i = 2 , N
               IF ( Y(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99014)
            WRITE (ipr,99015)
            WRITE (ipr,99017) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99018) hold
            WRITE (ipr,99014)
            RETURN
         ENDIF
 50      hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99014)
         WRITE (ipr,99015)
         WRITE (ipr,99017) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99018) hold
         WRITE (ipr,99014)
         RETURN
      ENDIF
 100  hold = Char(1)
      DO i = 2 , N
         IF ( Char(i)/=hold ) GOTO 200
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99016)
      WRITE (ipr,99017) alph31 , alph32 , sbnam1 , sbnam2
      WRITE (ipr,99018) hold
      WRITE (ipr,99014)
 200  hold = D(1)
      DO i = 2 , N
         IF ( D(i)/=hold ) GOTO 300
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99016)
      WRITE (ipr,99017) alph51 , alph52 , sbnam1 , sbnam2
      WRITE (ipr,99018) hold
      WRITE (ipr,99014)
!
 300  DO i = 1 , N
         IF ( Y(i)<cutoff ) GOTO 400
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99017) alph11 , alph12 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99014)
      RETURN
 400  DO i = 1 , N
         IF ( X(i)<cutoff ) GOTO 500
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99017) alph21 , alph22 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99014)
      RETURN
 500  DO i = 1 , N
         IF ( Char(i)<cutoff ) GOTO 600
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99017) alph31 , alph32 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99014)
      RETURN
 600  DO i = 1 , N
         IF ( D(i)<cutoff ) GOTO 700
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99017) alph51 , alph52 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99014)
      RETURN
!
 700  DO i = 1 , N
         IF ( Dmin<D(i) .AND. D(i)<Dmax ) GOTO 800
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99017) alph51 , alph52 , sbnam1 , sbnam2
      WRITE (ipr,99004)
99004 FORMAT (' ','HAS ALL ELEMENTS OUTSIDE THE INTERVAL')
      WRITE (ipr,99005) Dmin , Dmax
99005 FORMAT (' ','(',E15.8,',',E15.8,')',' AS DEFINED BY')
      WRITE (ipr,99006)
99006 FORMAT (' ','THE SIXTH  AND SEVENTH INPUT ARGUMENTS.')
      WRITE (ipr,99014)
      RETURN
!
 800  n2 = 0
      DO i = 1 , N
         IF ( Y(i)<cutoff .AND. X(i)<cutoff .AND. Char(i)<cutoff .AND.  &
     &        D(i)<cutoff ) THEN
            IF ( Dmin<D(i) .AND. D(i)<Dmax ) n2 = n2 + 1
            IF ( n2>=2 ) GOTO 900
         ENDIF
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99007) alph11 , alph12 , alph21 , alph22 , alph31 ,    &
     &                  alph32 , alph51 , alph52
99007 FORMAT (' ','THE ',A4,A4,', ',A4,A4,', ',A4,A4,', AND ',A4,A4)
      WRITE (ipr,99008) sbnam1 , sbnam2
99008 FORMAT (' ','INPUT ARGUMENTS TO THE ',A4,A4,' SUBROUTINE')
      WRITE (ipr,99009)
99009 FORMAT (' ','ARE SUCH THAT TOO MANY POINTS HAVE BEEN',            &
     &        ' EXCLUDED FROM THE PLOT.')
      WRITE (ipr,99010) n2
99010 FORMAT (' ','ONLY ',I3,' POINTS ARE LEFT TO BE PLOTTED.')
      WRITE (ipr,99014)
      RETURN
!
!-----START POINT-----------------------------------------------------
!
!     DETERMINE THE VALUES TO BE LISTED ON THE LEFT VERTICAL AXIS
!
 900  DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  IF ( D(i)>=Dmin ) THEN
                     IF ( D(i)<=Dmax ) THEN
                        ymin = Y(i)
                        ymax = Y(i)
                        EXIT
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  IF ( D(i)>=Dmin ) THEN
                     IF ( D(i)<=Dmax ) THEN
                        IF ( Y(i)<ymin ) ymin = Y(i)
                        IF ( Y(i)>ymax ) ymax = Y(i)
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      DO i = 1 , 9
         aim1 = i - 1
         ylable(i) = ymax - (aim1/8.0)*(ymax-ymin)
      ENDDO
!
!     DETERMINE THE VALUES TO BE LISTED ON THE BOTTOM HORIZONTAL AXIS
!     DETERMINE XMIN, XMAX, XMID, X25 (=THE 25% POINT), AND
!     X75 (=THE 75% POINT)
!
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  IF ( D(i)>=Dmin ) THEN
                     IF ( D(i)<=Dmax ) THEN
                        xmin = X(i)
                        xmax = X(i)
                        EXIT
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  IF ( D(i)>=Dmin ) THEN
                     IF ( D(i)<=Dmax ) THEN
                        IF ( X(i)<xmin ) xmin = X(i)
                        IF ( X(i)>xmax ) xmax = X(i)
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      xmid = (xmin+xmax)/2.0
      x25 = 0.75*xmin + 0.25*xmax
      x75 = 0.25*xmin + 0.75*xmax
!
!     BLANK OUT THE GRAPH
!
      DO i = 1 , 45
         DO j = 1 , 109
            IGRaph(i,j) = blank
         ENDDO
      ENDDO
!
!     PRODUCE THE VERTICAL AXES
!
      DO i = 3 , 43
         IGRaph(i,5) = alphai
         IGRaph(i,109) = alphai
      ENDDO
      DO i = 3 , 43 , 5
         IGRaph(i,5) = hyphen
         IGRaph(i,109) = hyphen
      ENDDO
      IGRaph(3,1) = equal
      IGRaph(3,2) = alpham
      IGRaph(3,3) = alphaa
      IGRaph(3,4) = alphax
      IGRaph(23,1) = equal
      IGRaph(23,2) = alpham
      IGRaph(23,3) = alphai
      IGRaph(23,4) = alphad
      IGRaph(43,1) = equal
      IGRaph(43,2) = alpham
      IGRaph(43,3) = alphai
      IGRaph(43,4) = alphan
!
!     PRODUCE THE HORIZONTAL AXES
!
      DO j = 7 , 107
         IGRaph(1,j) = hyphen
         IGRaph(45,j) = hyphen
      ENDDO
      DO j = 7 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
      DO j = 20 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
!
!     DETERMINE THE (X,Y) PLOT POSITIONS
!
      ratioy = 40.0/(ymax-ymin)
      ratiox = 100.0/(xmax-xmin)
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  IF ( D(i)>=Dmin ) THEN
                     IF ( D(i)<=Dmax ) THEN
                        mx = ratiox*(X(i)-xmin) + 0.5
                        mx = mx + 7
                        my = ratioy*(Y(i)-ymin) + 0.5
                        my = 43 - my
                        iarg = 37
                        IF ( 0.5<Char(i) .AND. Char(i)<36.5 )           &
     &                       iarg = Char(i) + 0.5
                        IGRaph(my,mx) = iplotc(iarg)
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
!
!     WRITE OUT THE GRAPH
!
      DO i = 1 , 45
         ip2 = i + 2
         iflag = ip2 - (ip2/5)*5
         k = ip2/5
         IF ( iflag/=0 ) WRITE (ipr,99011) (IGRaph(i,j),j=1,109)
!
99011    FORMAT (' ',20X,109A1)
         IF ( iflag==0 ) WRITE (ipr,99012) ylable(k) ,                  &
     &                          (IGRaph(i,j),j=1,109)
99012    FORMAT (' ',F20.7,109A1)
      ENDDO
      WRITE (ipr,99013) xmin , x25 , xmid , x75 , xmax
99013 FORMAT (' ',14X,F20.7,5X,F20.7,5X,F20.7,5X,F20.7,1X,F20.7)
!
99014 FORMAT (' ','**************************************************', &
     &        '********************')
99015 FORMAT (' ','                   FATAL ERROR                    ')
99016 FORMAT (' ','               NON-FATAL DIAGNOSTIC               ')
99017 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
99018 FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
99019 FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
99020 FORMAT (' ','VALUE OF ',E15.8)
!
      END SUBROUTINE PLOTSC
!*==plots.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOTS(Y,X,N,D,Dmin,Dmax)
      IMPLICIT NONE
!*--PLOTS19100
!*** Start of declarations inserted by SPAG
      REAL aim1 , cutoff , D , Dmax , Dmin , hold , ratiox , ratioy ,   &
     &     X , x25 , x75 , xmax , xmid , xmin , Y , ylable , ymax , ymin
      INTEGER i , iflag , ip2 , ipr , j , k , mx , my , N , n2
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOTS
!
!     PURPOSE--THIS SUBROUTINE YIELDS A ONE-PAGE PRINTER PLOT
!              OF Y(I) VERSUS X(I):
!              1) WITH ONLY THOSE POINTS (X(I),Y(I)) PLOTTED
!                 FOR WHICH THE CORRESPONDING VALUE OF D(I)
!                 IS BETWEEN THE SPECIFIED VALUES OF DMIN AND DMAX.
!
!              THE USE OF THE SUBSET DEFINITION VECTOR D
!              GIVES THE DATA ANALYST THE CAPABILITY OF
!              PLOTTING SUBSETS OF THE DATA,
!              WHERE THE SUBSET IS DEFINED
!              BY VALUES IN THE VECTOR D.
!
!     INPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED VERTICALLY.
!                    --X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED HORIZONTALLY.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR Y.
!                    --D      = THE SINGLE PRECISION VECTOR
!                               WHICH 'DEFINES' THE VARIOUS
!                               POSSIBLE SUBSETS.
!                    --DMIN   = THE SINGLE PRECISION VALUE
!                               WHICH DEFINES THE LOWER BOUND
!                               (INCLUSIVELY) OF THE PARTICULAR
!                               SUBSET OF INTEREST TO BE PLOTTED.
!                    --DMAX   = THE SINGLE PRECISION VALUE
!                               WHICH DEFINES THE UPPER BOUND
!                               (INCLUSIVELY) OF THE PARTICULAR
!                               SUBSET OF INTEREST TO BE PLOTTED.
!     OUTPUT--A ONE-PAGE PRINTER PLOT OF Y(I) VERSUS X(I),
!             FOR ONLY OF A SPECIFIED SUBSET OF THE DATA.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--FOR A GIVEN DUMMY INDEX I,
!              IF D(I) IS SMALLER THAN DMIN OR LARGER THAN DMAX,
!              THEN THE CORRESPONDING POINT (X(I),Y(I))
!              WILL NOT BE PLOTTED.
!            --VALUES IN THE VERTICAL AXIS VECTOR (Y)
!              OR THE HORIZONTAL AXIS VECTOR (X) WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR Y
!              (OR X) ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR Y
!              (OR X) FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN Y (OR X) TO BE PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN Y (OR X) TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOT
!              SUBROUTINE.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 IGRaph
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22 , alph31 , alph32
      CHARACTER*4 alph41 , alph42
      CHARACTER*4 blank , hyphen , alphai , alphax
      CHARACTER*4 alpham , alphaa , alphad , alphan , equal
!
      DIMENSION Y(1)
      DIMENSION X(1)
      DIMENSION D(1)
      DIMENSION ylable(11)
      COMMON /BLOCK1/ IGRaph(55,130)
!
      DATA sbnam1 , sbnam2/'PLOT' , 'S   '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA alph31 , alph32/'THIR' , 'D   '/
      DATA alph41 , alph42/'FOUR' , 'TH  '/
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
      DATA alpham , alphaa , alphad , alphan , equal/'M' , 'A' , 'D' ,  &
     &     'N' , '='/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      WRITE (ipr,99001)
99001 FORMAT ('1')
      IF ( N<1 ) THEN
         WRITE (ipr,99015)
         WRITE (ipr,99016)
         WRITE (ipr,99017) alph31 , alph32 , sbnam1 , sbnam2
         WRITE (ipr,99002) N
99002    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99015)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99015)
            WRITE (ipr,99016)
            WRITE (ipr,99017) alph31 , alph32 , sbnam1 , sbnam2
            WRITE (ipr,99003) N
99003       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99015)
            RETURN
         ELSE
!
            hold = Y(1)
            DO i = 2 , N
               IF ( Y(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99015)
            WRITE (ipr,99016)
            WRITE (ipr,99017) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99018) hold
            WRITE (ipr,99015)
            RETURN
         ENDIF
 50      hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99015)
         WRITE (ipr,99016)
         WRITE (ipr,99017) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99018) hold
         WRITE (ipr,99015)
         RETURN
      ENDIF
 100  hold = D(1)
      DO i = 2 , N
         IF ( D(i)/=hold ) GOTO 200
      ENDDO
      WRITE (ipr,99015)
      WRITE (ipr,99004)
99004 FORMAT (' ','               NON-FATAL DIAGNOSTIC               ')
      WRITE (ipr,99017) alph41 , alph42 , sbnam1 , sbnam2
      WRITE (ipr,99018) hold
      WRITE (ipr,99015)
!
 200  DO i = 1 , N
         IF ( Y(i)<cutoff ) GOTO 300
      ENDDO
      WRITE (ipr,99015)
      WRITE (ipr,99016)
      WRITE (ipr,99017) alph11 , alph12 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99015)
      RETURN
 300  DO i = 1 , N
         IF ( X(i)<cutoff ) GOTO 400
      ENDDO
      WRITE (ipr,99015)
      WRITE (ipr,99016)
      WRITE (ipr,99017) alph21 , alph22 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99015)
      RETURN
 400  DO i = 1 , N
         IF ( D(i)<cutoff ) GOTO 500
      ENDDO
      WRITE (ipr,99015)
      WRITE (ipr,99016)
      WRITE (ipr,99017) alph41 , alph42 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99015)
      RETURN
!
 500  DO i = 1 , N
         IF ( Dmin<D(i) .AND. D(i)<Dmax ) GOTO 600
      ENDDO
      WRITE (ipr,99015)
      WRITE (ipr,99016)
      WRITE (ipr,99017) alph41 , alph42 , sbnam1 , sbnam2
      WRITE (ipr,99005)
99005 FORMAT (' ','HAS ALL ELEMENTS OUTSIDE THE INTERVAL')
      WRITE (ipr,99006) Dmin , Dmax
99006 FORMAT (' ','(',E15.8,',',E15.8,')',' AS DEFINED BY')
      WRITE (ipr,99007)
99007 FORMAT (' ','THE FIFTH  AND SIXTH  INPUT ARGUMENTS.')
      WRITE (ipr,99015)
      RETURN
!
 600  n2 = 0
      DO i = 1 , N
         IF ( Y(i)<cutoff .AND. X(i)<cutoff .AND. D(i)<cutoff ) THEN
            IF ( Dmin<D(i) .AND. D(i)<Dmax ) n2 = n2 + 1
            IF ( n2>=2 ) GOTO 700
         ENDIF
      ENDDO
      WRITE (ipr,99015)
      WRITE (ipr,99016)
      WRITE (ipr,99008) alph11 , alph12 , alph21 , alph22 , alph41 ,    &
     &                  alph42
99008 FORMAT (' ','THE ',A4,A4,', ',A4,A4,', AND ',A4,A4)
      WRITE (ipr,99009) sbnam1 , sbnam2
99009 FORMAT (' ','INPUT ARGUMENTS TO THE ',A4,A4,' SUBROUTINE')
      WRITE (ipr,99010)
99010 FORMAT (' ','ARE SUCH THAT TOO MANY POINTS HAVE BEEN',            &
     &        ' EXCLUDED FROM THE PLOT.')
      WRITE (ipr,99011) n2
99011 FORMAT (' ','ONLY ',I3,' POINTS ARE LEFT TO BE PLOTTED.')
      WRITE (ipr,99015)
      RETURN
!
!-----START POINT-----------------------------------------------------
!
!     DETERMINE THE VALUES TO BE LISTED ON THE LEFT VERTICAL AXIS
!
 700  DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( D(i)>=Dmin ) THEN
                  IF ( D(i)<=Dmax ) THEN
                     ymin = Y(i)
                     ymax = Y(i)
                     EXIT
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( D(i)>=Dmin ) THEN
                  IF ( D(i)<=Dmax ) THEN
                     IF ( Y(i)<ymin ) ymin = Y(i)
                     IF ( Y(i)>ymax ) ymax = Y(i)
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      DO i = 1 , 9
         aim1 = i - 1
         ylable(i) = ymax - (aim1/8.0)*(ymax-ymin)
      ENDDO
!
!     DETERMINE THE VALUES TO BE LISTED ON THE BOTTOM HORIZONTAL AXIS
!     DETERMINE XMIN, XMAX, XMID, X25 (=THE 25% POINT), AND
!     X75 (=THE 75% POINT)
!
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( D(i)>=Dmin ) THEN
                  IF ( D(i)<=Dmax ) THEN
                     xmin = X(i)
                     xmax = X(i)
                     EXIT
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( D(i)>=Dmin ) THEN
                  IF ( D(i)<=Dmax ) THEN
                     IF ( X(i)<xmin ) xmin = X(i)
                     IF ( X(i)>xmax ) xmax = X(i)
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      xmid = (xmin+xmax)/2.0
      x25 = 0.75*xmin + 0.25*xmax
      x75 = 0.25*xmin + 0.75*xmax
!
!     BLANK OUT THE GRAPH
!
      DO i = 1 , 45
         DO j = 1 , 109
            IGRaph(i,j) = blank
         ENDDO
      ENDDO
!
!     PRODUCE THE VERTICAL AXES
!
      DO i = 3 , 43
         IGRaph(i,5) = alphai
         IGRaph(i,109) = alphai
      ENDDO
      DO i = 3 , 43 , 5
         IGRaph(i,5) = hyphen
         IGRaph(i,109) = hyphen
      ENDDO
      IGRaph(3,1) = equal
      IGRaph(3,2) = alpham
      IGRaph(3,3) = alphaa
      IGRaph(3,4) = alphax
      IGRaph(23,1) = equal
      IGRaph(23,2) = alpham
      IGRaph(23,3) = alphai
      IGRaph(23,4) = alphad
      IGRaph(43,1) = equal
      IGRaph(43,2) = alpham
      IGRaph(43,3) = alphai
      IGRaph(43,4) = alphan
!
!     PRODUCE THE HORIZONTAL AXES
!
      DO j = 7 , 107
         IGRaph(1,j) = hyphen
         IGRaph(45,j) = hyphen
      ENDDO
      DO j = 7 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
      DO j = 20 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
!
!     DETERMINE THE (X,Y) PLOT POSITIONS
!
      ratioy = 40.0/(ymax-ymin)
      ratiox = 100.0/(xmax-xmin)
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( D(i)>=Dmin ) THEN
                  IF ( D(i)<=Dmax ) THEN
                     mx = ratiox*(X(i)-xmin) + 0.5
                     mx = mx + 7
                     my = ratioy*(Y(i)-ymin) + 0.5
                     my = 43 - my
                     IGRaph(my,mx) = alphax
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
!
!     WRITE OUT THE GRAPH
!
      DO i = 1 , 45
         ip2 = i + 2
         iflag = ip2 - (ip2/5)*5
         k = ip2/5
         IF ( iflag/=0 ) WRITE (ipr,99012) (IGRaph(i,j),j=1,109)
!
99012    FORMAT (' ',20X,109A1)
         IF ( iflag==0 ) WRITE (ipr,99013) ylable(k) ,                  &
     &                          (IGRaph(i,j),j=1,109)
99013    FORMAT (' ',F20.7,109A1)
      ENDDO
      WRITE (ipr,99014) xmin , x25 , xmid , x75 , xmax
99014 FORMAT (' ',14X,F20.7,5X,F20.7,5X,F20.7,5X,F20.7,1X,F20.7)
!
99015 FORMAT (' ','**************************************************', &
     &        '********************')
99016 FORMAT (' ','                   FATAL ERROR                    ')
99017 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
99018 FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
99019 FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
99020 FORMAT (' ','VALUE OF ',E15.8)
!
      END SUBROUTINE PLOTS
!*==plotsp.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOTSP(Y,N,Idf)
      IMPLICIT NONE
!*--PLOTSP19976
!*** Start of declarations inserted by SPAG
      REAL ai , an , df , hold , pp025 , pp975 , ratiox , ratioy ,      &
     &     slower , spmax , spmin , supper , xi , Y , ylable , ymax ,   &
     &     ymin
      INTEGER i , Idf , iflag , ipr , j , k , mx , my , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOTSP
!
!     THIS ROUTINE YIELDS A ONE-PAGE PLOT OF THE SPECTRUM, ALONG WITH UPPER
!     AND LOWER LIMITS OF THE SPECTRUM.
!     THE CONVENTION HAS BEEN FOLLOWED THAT IF THE INTEGER INPUT PARAMETER IDF
!     HAS THE VALUE 0, THEN NO CONFIDENCE LIMITS WILL BE COMPUTED AND ONLY THE
!     SPECTRUM ITSELF WILL BE PLOTTED OUT.
!     MULTIPLE PLOT POINTS ARE NOT INDICATED.
!     THE FIRST POINT WILL BE PLOTTED ON THE LEFT VERTICAL AXIS
!     THE LAST POINT WILL BE PLOTTED ON THE RIGHT VERTICAL AXIS
!     THERE IS NO RESTRICTION ON THE MAXIMUM VALUE OF N FOR THIS ROUTINE.
!     PRINTING--YES
!     SUBROUTINES NEEDED--CHSPPF.
!     WRITTEN BY JAMES J. FILLIBEN, STATISTICAL ENGINEERING LABORATORY (205.03)
!     NATIONAL BUREAU OF STANDARDS, WASHINGTON, D.C. 20234     JUN 1972
!                                                      UPDATED FEB 1975
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 IGRaph
      CHARACTER*4 blank , hyphen , alphai , alphax , dot
!
      DIMENSION Y(1)
      DIMENSION ylable(11)
      COMMON /BLOCK1/ IGRaph(55,130)
!
      DATA blank , hyphen , alphai/' ' , '-' , 'I'/
      DATA alphax/'X'/
      DATA dot/'.'/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE PLOTSP SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE PLOT&
     &SP SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         hold = Y(1)
         DO i = 2 , N
            IF ( Y(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE PLOTSP SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     DETERMINE THE MINIMUM AND MAXIMUM OF THE SPECTRUM
!
         spmin = Y(1)
         spmax = Y(1)
         DO i = 2 , N
            IF ( Y(i)<spmin ) spmin = Y(i)
            IF ( Y(i)>spmax ) spmax = Y(i)
         ENDDO
!
!     COMPUTE THE MAXIMUM VALUE OF THE UPPER CONFIDENCE LIMIT
!     AND THE MINIMUM VALUE OF THE LOWER CONFIDENCE LIMIT--THESE TWO VALUES
!     WILL DEFINE THE RANGE OF VALUES TO BE LISTED ON THE VERTICAL AXIS
!
         IF ( Idf==0 ) THEN
            ymin = spmin
            ymax = spmax
         ELSE
            df = Idf
            CALL CHSPPF(.975,Idf,pp975)
            CALL CHSPPF(.025,Idf,pp025)
            ymax = df*spmax/pp025
            ymin = df*spmin/pp975
         ENDIF
!
!     DETERMINE THE 11 VALUES TO BE LISTED ON THE LEFT VERTICAL AXIS
!
         DO i = 1 , 11
            ylable(i) = ymax - ((FLOAT(i-1))/10.0)*(ymax-ymin)
         ENDDO
!
!     BLANK OUT THE GRAPH
         DO i = 1 , 55
            DO j = 1 , 130
               IGRaph(i,j) = blank
            ENDDO
         ENDDO
!
!     PRODUCE THE Y AXIS
         DO i = 5 , 55
            IGRaph(i,10) = alphai
            IGRaph(i,130) = alphai
         ENDDO
         DO i = 5 , 55 , 5
            IGRaph(i,10) = hyphen
            IGRaph(i,130) = hyphen
         ENDDO
!
!     PRODUCE THE X AXIS
         DO j = 10 , 130
            IGRaph(55,j) = hyphen
            IGRaph(5,j) = hyphen
         ENDDO
         DO j = 10 , 130 , 10
            IGRaph(55,j) = alphai
            IGRaph(5,j) = alphai
         ENDDO
!
!     DETERMINE THE (X,Y) PLOT POSITIONS
         ratioy = 50.0/(ymax-ymin)
         ratiox = 240.0
         DO i = 1 , N
            ai = i
            xi = (ai-1.0)/(2.0*(an-1.0))
            mx = ratiox*xi + 0.5
            mx = mx + 10
            IF ( Idf/=0 ) THEN
               supper = df*Y(i)/pp025
               slower = df*Y(i)/pp975
               my = ratioy*(supper-ymin) + 0.5
               my = 55 - my
               IGRaph(my,mx) = dot
               my = ratioy*(slower-ymin) + 0.5
               my = 55 - my
               IGRaph(my,mx) = dot
            ENDIF
            my = ratioy*(Y(i)-ymin) + 0.5
            my = 55 - my
            IGRaph(my,mx) = alphax
         ENDDO
!
!     WRITE OUT THE GRAPH
         WRITE (ipr,99005)
99005    FORMAT ('1')
         DO i = 5 , 55
            iflag = i - (i/5)*5
            k = i/5
            IF ( iflag/=0 ) WRITE (ipr,99006) (IGRaph(i,j),j=1,130)
99006       FORMAT (' ',130A1)
            IF ( iflag==0 ) WRITE (ipr,99007) ylable(k) ,               &
     &                             (IGRaph(i,j),j=10,130)
99007       FORMAT (' ',F9.2,130A1)
         ENDDO
         WRITE (ipr,99008)
99008    FORMAT (' ',                                                   &
     &'FREQ   .000      .042      .083      .125      .167      .208    &
     &  .250      .292      .333      .375      .417      .458      .500&
     &')
         WRITE (ipr,99009)
99009    FORMAT (' ',                                                   &
     &'PERIOD INF       24.0      12.0      8.00      6.00      4.80    &
     &  4.00      3.43      3.00      2.67      2.40      2.18      2.00&
     &')
      ENDIF
      END SUBROUTINE PLOTSP
!*==plotst.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOTST(Y,X,N,D,Dmin,Dmax)
      IMPLICIT NONE
!*--PLOTST20155
!*** Start of declarations inserted by SPAG
      REAL aim1 , airow , anumcm , anumlm , anumr , anumrm , cutoff ,   &
     &     D , delx , dely , Dmax , Dmin , hold , X , xlable , xmax ,   &
     &     xmin , xwidth , Y , ylable
      REAL ylower , ymax , ymin , yupper , ywidth
      INTEGER i , icol , icolmx , ipr , irow , ixdel , N , n2 , numcol ,&
     &        numlab , numr25 , numr50 , numr75 , numrow
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOTST
!
!     PURPOSE--THIS SUBROUTINE YIELDS A NARROW-WIDTH (71-CHARACTER)
!              OF Y(I) VERSUS X(I):
!              1) WITH ONLY THOSE POINTS (X(I),Y(I)) PLOTTED
!                 FOR WHICH THE CORRESPONDING VALUE OF D(I)
!                 IS BETWEEN THE SPECIFIED VALUES OF DMIN AND DMAX.
!
!              ITS NARROW WIDTH MAKES IT
!              APPROPRIATE FOR USE ON A TERMINAL.
!
!              THE USE OF THE SUBSET DEFINTION VECTOR D
!              GIVES THE DATA ANALYST THE CAPABILITY OF
!              PLOTTING SUBSETS OF THE DATA,
!              WHERE THE SUBSET IS DEFINED
!              BY VALUES IN THE VECTOR D.
!
!     INPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED VERTICALLY.
!                    --X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED HORIZONTALLY.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR Y.
!                    --D      = THE SINGLE PRECISION VECTOR
!                               WHICH 'DEFINES' THE VARIOUS
!                               POSSIBLE SUBSETS.
!                    --DMIN   = THE SINGLE PRECISION VALUE
!                               WHICH DEFINES THE LOWER BOUND
!                               (INCLUSIVELY) OF THE PARTICULAR
!                               SUBSET OF INTEREST TO BE PLOTTED.
!                    --DMAX   = THE SINGLE PRECISION VALUE
!                               WHICH DEFINES THE UPPER BOUND
!                               (INCLUSIVELY) OF THE PARTICULAR
!                               SUBSET OF INTEREST TO BE PLOTTED.
!     OUTPUT--A NARROW-WIDTH (71-CHARACTER) TERMINAL PLOT
!             OF Y(I) VERSUS X(I),
!             FOR ONLY OF A SPECIFIED SUBSET OF THE DATA.
!             THE BODY OF THE PLOT (NOT COUNTING AXIS VALUES
!             AND MARGINS) IS 25 ROWS (LINES) AND 49 COLUMNS.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--FOR A GIVEN DUMMY INDEX I,
!              IF D(I) IS SMALLER THAN DMIN OR LARGER THAN DMAX,
!              THEN THE CORRESPONDING POINT (X(I),Y(I))
!              WILL NOT BE PLOTTED.
!            --VALUES IN THE VERTICAL AXIS VECTOR (Y)
!              OR THE HORIZONTAL AXIS VECTOR (X) WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR Y
!              (OR X) ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR Y
!              (OR X) FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN Y (OR X) TO BE PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN Y (OR X) TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOT
!              SUBROUTINE.
!            --NOTE THAT THE STORAGE REQUIREMENTS FOR THIS
!              (AND THE OTHER) TERMINAL PLOT SUBROUTINESS ARE .
!              VERY SMALL.
!              THIS IS DUE TO THE 'ONE LINE AT A TIME' ALGORITHM
!              EMPLOYED FOR THE PLOT.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 iline
      CHARACTER*4 iaxisc
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22 , alph31 , alph32
      CHARACTER*4 alph41 , alph42
      CHARACTER*4 blank , hyphen , alphai , alphax
!
      DIMENSION Y(1)
      DIMENSION X(1)
      DIMENSION D(1)
      DIMENSION iline(72) , xlable(10)
!
      DATA sbnam1 , sbnam2/'PLOT' , 'ST  '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA alph31 , alph32/'THIR' , 'D   '/
      DATA alph41 , alph42/'FOUR' , 'TH  '/
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99015)
         WRITE (ipr,99016)
         WRITE (ipr,99017) alph31 , alph32 , sbnam1 , sbnam2
         WRITE (ipr,99001) N
99001    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99015)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99015)
            WRITE (ipr,99016)
            WRITE (ipr,99017) alph31 , alph32 , sbnam1 , sbnam2
            WRITE (ipr,99002) N
99002       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99015)
            RETURN
         ELSE
!
            hold = Y(1)
            DO i = 2 , N
               IF ( Y(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99015)
            WRITE (ipr,99016)
            WRITE (ipr,99017) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99018) hold
            WRITE (ipr,99015)
            RETURN
         ENDIF
 50      hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99015)
         WRITE (ipr,99016)
         WRITE (ipr,99017) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99018) hold
         WRITE (ipr,99015)
         RETURN
      ENDIF
 100  hold = D(1)
      DO i = 2 , N
         IF ( D(i)/=hold ) GOTO 200
      ENDDO
      WRITE (ipr,99015)
      WRITE (ipr,99003)
99003 FORMAT (' ','               NON-FATAL DIAGNOSTIC               ')
      WRITE (ipr,99017) alph41 , alph42 , sbnam1 , sbnam2
      WRITE (ipr,99018) hold
      WRITE (ipr,99015)
!
 200  DO i = 1 , N
         IF ( Y(i)<cutoff ) GOTO 300
      ENDDO
      WRITE (ipr,99015)
      WRITE (ipr,99016)
      WRITE (ipr,99017) alph11 , alph12 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99015)
      RETURN
 300  DO i = 1 , N
         IF ( X(i)<cutoff ) GOTO 400
      ENDDO
      WRITE (ipr,99015)
      WRITE (ipr,99016)
      WRITE (ipr,99017) alph21 , alph22 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99015)
      RETURN
 400  DO i = 1 , N
         IF ( D(i)<cutoff ) GOTO 500
      ENDDO
      WRITE (ipr,99015)
      WRITE (ipr,99016)
      WRITE (ipr,99017) alph41 , alph42 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99015)
      RETURN
!
 500  DO i = 1 , N
         IF ( Dmin<D(i) .AND. D(i)<Dmax ) GOTO 600
      ENDDO
      WRITE (ipr,99015)
      WRITE (ipr,99016)
      WRITE (ipr,99017) alph41 , alph42 , sbnam1 , sbnam2
      WRITE (ipr,99004)
99004 FORMAT (' ','HAS ALL ELEMENTS OUTSIDE THE INTERVAL')
      WRITE (ipr,99005) Dmin , Dmax
99005 FORMAT (' ','(',E15.8,',',E15.8,')',' AS DEFINED BY')
      WRITE (ipr,99006)
99006 FORMAT (' ','THE FIFTH  AND SIXTH  INPUT ARGUMENTS.')
      WRITE (ipr,99015)
      RETURN
!
 600  n2 = 0
      DO i = 1 , N
         IF ( Y(i)<cutoff .AND. X(i)<cutoff .AND. D(i)<cutoff ) THEN
            IF ( Dmin<D(i) .AND. D(i)<Dmax ) n2 = n2 + 1
            IF ( n2>=2 ) GOTO 700
         ENDIF
      ENDDO
      WRITE (ipr,99015)
      WRITE (ipr,99016)
      WRITE (ipr,99007) alph11 , alph12 , alph21 , alph22 , alph41 ,    &
     &                  alph42
99007 FORMAT (' ','THE ',A4,A4,', ',A4,A4,', AND ',A4,A4)
      WRITE (ipr,99008) sbnam1 , sbnam2
99008 FORMAT (' ','INPUT ARGUMENTS TO THE ',A4,A4,' SUBROUTINE')
      WRITE (ipr,99009)
99009 FORMAT (' ','ARE SUCH THAT TOO MANY POINTS HAVE BEEN',            &
     &        ' EXCLUDED FROM THE PLOT.')
      WRITE (ipr,99010) n2
99010 FORMAT (' ','ONLY ',I3,' POINTS ARE LEFT TO BE PLOTTED.')
      WRITE (ipr,99015)
      RETURN
!
!-----START POINT-----------------------------------------------------
!
!     DEFINE THE NUMBER OF ROWS AND COLUMNS WITHIN THE PLOT--
!     THIS HAS BEEN SET TO 25 ROWS AND 49 COLUMNS.
!
 700  numrow = 25
      numcol = 49
      anumr = numrow
      anumrm = numrow - 1
      anumcm = numcol - 1
      numr25 = (numrow/4) + 1
      numr50 = (numrow/2) + 1
      numr75 = 3*(numrow/4) + 1
      ixdel = (numcol-1)/4
      numlab = 5
      anumlm = numlab - 1
!
!     SKIP A LINE, WRITE OUT AN IDENTIFYING LINE FOR THE TYPE OF PLOT,
!     WRITE OUT THE TOP HORIZONTAL AXIS OF THE PLOT, AND SKIP 1 LINE
!     FOR A MARGIN WITHIN THE PLOT.
!
      WRITE (ipr,99011)
99011 FORMAT (' ')
      WRITE (ipr,99012)
!
99012 FORMAT (' ',                                                      &
     &'THE FOLLOWING IS A PLOT OF Y(I) (VERTICALLY) VERSUS X(I) (HORIZON&
     &TALLY)')
      DO icol = 1 , numcol
         iline(icol) = hyphen
      ENDDO
      DO icol = 1 , numcol , ixdel
         iline(icol) = alphai
      ENDDO
      WRITE (ipr,99021) (iline(i),i=1,numcol)
      WRITE (ipr,99022) blank
!
!     DETERMINE THE MIN AND MAX VALUES OF Y, AND OF X.
!
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( D(i)>=Dmin ) THEN
                  IF ( D(i)<=Dmax ) THEN
                     ymin = Y(i)
                     ymax = Y(i)
                     xmin = X(i)
                     xmax = X(i)
                     EXIT
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( D(i)>=Dmin ) THEN
                  IF ( D(i)<=Dmax ) THEN
                     IF ( Y(i)<ymin ) ymin = Y(i)
                     IF ( Y(i)>ymax ) ymax = Y(i)
                     IF ( X(i)<xmin ) xmin = X(i)
                     IF ( X(i)>xmax ) xmax = X(i)
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      dely = ymax - ymin
      delx = xmax - xmin
      ywidth = dely/anumrm
      xwidth = delx/anumcm
!
!     DETERMINE AND WRITE OUT THE PLOT POSITIONS ONE LINE AT A TIME.
!
      DO irow = 1 , numrow
         DO icol = 1 , numcol
            iline(icol) = blank
         ENDDO
         airow = irow
         yupper = ymax + (1.5-airow)*ywidth
         ylable = ymax + (1.0-airow)*ywidth
         ylower = ymax + (0.5-airow)*ywidth
         IF ( irow==numrow ) ylable = ymin
         DO i = 1 , N
            IF ( Y(i)<cutoff ) THEN
               IF ( X(i)<cutoff ) THEN
                  IF ( D(i)>=Dmin ) THEN
                     IF ( D(i)<=Dmax ) THEN
                        IF ( ylower<=Y(i) .AND. Y(i)<yupper ) THEN
                           icol = ((X(i)-xmin)/xwidth) + 1.5
                           iline(icol) = alphax
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDDO
         icolmx = 1
         DO icol = 1 , numcol
            IF ( iline(icol)==alphax ) icolmx = icol
         ENDDO
         iaxisc = alphai
         IF ( irow==1 .OR. irow==numrow ) iaxisc = hyphen
         IF ( irow==numr25 .OR. irow==numr50 .OR. irow==numr75 )        &
     &        iaxisc = hyphen
         WRITE (ipr,99013) ylable , iaxisc , (iline(icol),icol=1,icolmx)
99013    FORMAT (' ',E14.7,1X,A1,2X,50A1)
      ENDDO
!
!     SKIP 1 LINE FOR A BOTTOM MARGIN WITHIN THE PLOT, WRITE OUT THE
!     BOTTOM HORIZONTAL AXIS, AND WRITE OUT THE X AXIS LABLES.
!
      WRITE (ipr,99022) blank
      DO icol = 1 , numcol
         iline(icol) = hyphen
      ENDDO
      DO icol = 1 , numcol , ixdel
         iline(icol) = alphai
      ENDDO
      WRITE (ipr,99021) (iline(icol),icol=1,numcol)
      DO i = 1 , numlab
         aim1 = i - 1
         xlable(i) = xmin + (aim1/anumlm)*delx
      ENDDO
      WRITE (ipr,99014) (xlable(i),i=1,numlab)
99014 FORMAT (' ',9X,5E12.4)
!
99015 FORMAT (' ','**************************************************', &
     &        '********************')
99016 FORMAT (' ','                   FATAL ERROR                    ')
99017 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
99018 FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
99019 FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
99020 FORMAT (' ','VALUE OF ',E15.8)
99021 FORMAT (' ',18X,54A1)
99022 FORMAT (' ',15X,A1)
!
      END SUBROUTINE PLOTST
!*==plott.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOTT(Y,X,N)
      IMPLICIT NONE
!*--PLOTT20537
!*** Start of declarations inserted by SPAG
      REAL aim1 , airow , anumcm , anumlm , anumr , anumrm , cutoff ,   &
     &     delx , dely , hold , X , xlable , xmax , xmin , xwidth , Y , &
     &     ylable , ylower , ymax , ymin
      REAL yupper , ywidth
      INTEGER i , icol , icolmx , ipr , irow , ixdel , N , n2 , numcol ,&
     &        numlab , numr25 , numr50 , numr75 , numrow
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOTT
!
!     PURPOSE--THIS SUBROUTINE YIELDS A NARROW-WIDTH (71-CHARACTER)
!              PLOT OF Y(I) VERSUS X(I).  ITS NARROW WIDTH MAKES IT
!              APPROPRIATE FOR USE ON A TERMINAL.
!     INPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED VERTICALLY.
!                    --X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED HORIZONTALLY.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR Y.
!     OUTPUT--A NARROW-WIDTH (71-CHARACTER) TERMINAL PLOT
!             OF Y(I) VERSUS X(I).
!             THE BODY OF THE PLOT (NOT COUNTING AXIS VALUES
!             AND MARGINS) IS 25 ROWS (LINES) AND 49 COLUMNS.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--VALUES IN THE VERTICAL AXIS VECTOR (Y)
!              OR THE HORIZONTAL AXIS VECTOR (X) WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR Y
!              (OR X) ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR Y
!              (OR X) FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN Y (OR X) TO BE PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN Y (OR X) TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOT
!              SUBROUTINE.
!            --NOTE THAT THE STORAGE REQUIREMENTS FOR THIS
!              (AND THE OTHER) TERMINAL PLOT SUBROUTINESS ARE .
!              VERY SMALL.
!              THIS IS DUE TO THE 'ONE LINE AT A TIME' ALGORITHM
!              EMPLOYED FOR THE PLOT.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--FEBRUARY  1974.
!     UPDATED         --APRIL     1974.
!     UPDATED         --OCTOBER   1974.
!     UPDATED         --OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 iline
      CHARACTER*4 iaxisc
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22 , alph31 , alph32
      CHARACTER*4 blank , hyphen , alphai , alphax
!
      DIMENSION Y(1)
      DIMENSION X(1)
      DIMENSION iline(72) , xlable(10)
!
      DATA sbnam1 , sbnam2/'PLOT' , 'T   '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA alph31 , alph32/'THIR' , 'D   '/
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99011)
         WRITE (ipr,99012)
         WRITE (ipr,99013) alph31 , alph32 , sbnam1 , sbnam2
         WRITE (ipr,99001) N
99001    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99011)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99011)
            WRITE (ipr,99012)
            WRITE (ipr,99013) alph31 , alph32 , sbnam1 , sbnam2
            WRITE (ipr,99002) N
99002       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99011)
            RETURN
         ELSE
!
            hold = Y(1)
            DO i = 2 , N
               IF ( Y(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99011)
            WRITE (ipr,99012)
            WRITE (ipr,99013) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99014) hold
            WRITE (ipr,99011)
            RETURN
         ENDIF
 50      hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99011)
         WRITE (ipr,99012)
         WRITE (ipr,99013) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99014) hold
         WRITE (ipr,99011)
         RETURN
      ENDIF
!
 100  DO i = 1 , N
         IF ( Y(i)<cutoff ) GOTO 200
      ENDDO
      WRITE (ipr,99011)
      WRITE (ipr,99012)
      WRITE (ipr,99013) alph11 , alph12 , sbnam1 , sbnam2
      WRITE (ipr,99015)
      WRITE (ipr,99016) cutoff
      WRITE (ipr,99011)
      RETURN
 200  DO i = 1 , N
         IF ( X(i)<cutoff ) GOTO 300
      ENDDO
      WRITE (ipr,99011)
      WRITE (ipr,99012)
      WRITE (ipr,99013) alph21 , alph22 , sbnam1 , sbnam2
      WRITE (ipr,99015)
      WRITE (ipr,99016) cutoff
      WRITE (ipr,99011)
      RETURN
!
 300  n2 = 0
      DO i = 1 , N
         IF ( Y(i)<cutoff .AND. X(i)<cutoff ) THEN
            n2 = n2 + 1
            IF ( n2>=2 ) GOTO 400
         ENDIF
      ENDDO
      WRITE (ipr,99011)
      WRITE (ipr,99012)
      WRITE (ipr,99003) alph11 , alph12 , alph21 , alph22
99003 FORMAT (' ','THE ',A4,A4,', AND ',A4,A4)
      WRITE (ipr,99004) sbnam1 , sbnam2
99004 FORMAT (' ','INPUT ARGUMENTS TO THE ',A4,A4,' SUBROUTINE')
      WRITE (ipr,99005)
99005 FORMAT (' ','ARE SUCH THAT TOO MANY POINTS HAVE BEEN',            &
     &        ' EXCLUDED FROM THE PLOT.')
      WRITE (ipr,99006) n2
99006 FORMAT (' ','ONLY ',I3,' POINTS ARE LEFT TO BE PLOTTED.')
      WRITE (ipr,99011)
      RETURN
!
!-----START POINT-----------------------------------------------------
!
!     DEFINE THE NUMBER OF ROWS AND COLUMNS WITHIN THE PLOT--
!     THIS HAS BEEN SET TO 25 ROWS AND 49 COLUMNS.
!
 400  numrow = 25
      numcol = 49
      anumr = numrow
      anumrm = numrow - 1
      anumcm = numcol - 1
      numr25 = (numrow/4) + 1
      numr50 = (numrow/2) + 1
      numr75 = 3*(numrow/4) + 1
      ixdel = (numcol-1)/4
      numlab = 5
      anumlm = numlab - 1
!
!     SKIP A LINE, WRITE OUT AN IDENTIFYING LINE FOR THE TYPE OF PLOT,
!     WRITE OUT THE TOP HORIZONTAL AXIS OF THE PLOT, AND SKIP 1 LINE
!     FOR A MARGIN WITHIN THE PLOT.
!
      WRITE (ipr,99007)
99007 FORMAT (' ')
      WRITE (ipr,99008)
!
99008 FORMAT (' ',                                                      &
     &'THE FOLLOWING IS A PLOT OF Y(I) (VERTICALLY) VERSUS X(I) (HORIZON&
     &TALLY)')
      DO icol = 1 , numcol
         iline(icol) = hyphen
      ENDDO
      DO icol = 1 , numcol , ixdel
         iline(icol) = alphai
      ENDDO
      WRITE (ipr,99017) (iline(i),i=1,numcol)
      WRITE (ipr,99018) blank
!
!     DETERMINE THE MIN AND MAX VALUES OF Y, AND OF X.
!
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               ymin = Y(i)
               ymax = Y(i)
               xmin = X(i)
               xmax = X(i)
               EXIT
            ENDIF
         ENDIF
      ENDDO
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Y(i)<ymin ) ymin = Y(i)
               IF ( Y(i)>ymax ) ymax = Y(i)
               IF ( X(i)<xmin ) xmin = X(i)
               IF ( X(i)>xmax ) xmax = X(i)
            ENDIF
         ENDIF
      ENDDO
      dely = ymax - ymin
      delx = xmax - xmin
      ywidth = dely/anumrm
      xwidth = delx/anumcm
!
!     DETERMINE AND WRITE OUT THE PLOT POSITIONS ONE LINE AT A TIME.
!
      DO irow = 1 , numrow
         DO icol = 1 , numcol
            iline(icol) = blank
         ENDDO
         airow = irow
         yupper = ymax + (1.5-airow)*ywidth
         ylable = ymax + (1.0-airow)*ywidth
         ylower = ymax + (0.5-airow)*ywidth
         IF ( irow==numrow ) ylable = ymin
         DO i = 1 , N
            IF ( Y(i)<cutoff ) THEN
               IF ( X(i)<cutoff ) THEN
                  IF ( ylower<=Y(i) .AND. Y(i)<yupper ) THEN
                     icol = ((X(i)-xmin)/xwidth) + 1.5
                     iline(icol) = alphax
                  ENDIF
               ENDIF
            ENDIF
         ENDDO
         icolmx = 1
         DO icol = 1 , numcol
            IF ( iline(icol)==alphax ) icolmx = icol
         ENDDO
         iaxisc = alphai
         IF ( irow==1 .OR. irow==numrow ) iaxisc = hyphen
         IF ( irow==numr25 .OR. irow==numr50 .OR. irow==numr75 )        &
     &        iaxisc = hyphen
         WRITE (ipr,99009) ylable , iaxisc , (iline(icol),icol=1,icolmx)
99009    FORMAT (' ',E14.7,1X,A1,2X,50A1)
      ENDDO
!
!     SKIP 1 LINE FOR A BOTTOM MARGIN WITHIN THE PLOT, WRITE OUT THE
!     BOTTOM HORIZONTAL AXIS, AND WRITE OUT THE X AXIS LABLES.
!
      WRITE (ipr,99018) blank
      DO icol = 1 , numcol
         iline(icol) = hyphen
      ENDDO
      DO icol = 1 , numcol , ixdel
         iline(icol) = alphai
      ENDDO
      WRITE (ipr,99017) (iline(icol),icol=1,numcol)
      DO i = 1 , numlab
         aim1 = i - 1
         xlable(i) = xmin + (aim1/anumlm)*delx
      ENDDO
      WRITE (ipr,99010) (xlable(i),i=1,numlab)
99010 FORMAT (' ',9X,5E12.4)
!
99011 FORMAT (' ','**************************************************', &
     &        '********************')
99012 FORMAT (' ','                   FATAL ERROR                    ')
99013 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
99014 FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
99015 FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
99016 FORMAT (' ','VALUE OF ',E15.8)
99017 FORMAT (' ',18X,54A1)
99018 FORMAT (' ',15X,A1)
!
      END SUBROUTINE PLOTT
!*==plotu.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOTU(X,N)
      IMPLICIT NONE
!*--PLOTU20843
!*** Start of declarations inserted by SPAG
      REAL ai , an , anum , cwidsd , cwidth , height , hold , promax ,  &
     &     promin , ratiox , ratioy , s , sum , sum1 , sum2 , sum23 ,   &
     &     sum3 , width , WS , X
      REAL X2 , x25 , x75 , xmax , xmax2 , xmean , xmid , xmin , xmin2 ,&
     &     Y2 , ylable , ymax , ymin , z , zautoc , zdeva , zdevb ,     &
     &     zmax , zmean , zmean1
      REAL zmean2 , zmed , zmin , zrange , zrdeva , zrdevb , zsd
      INTEGER i , ibax , ibaxis , ibaxm1 , ibaxm2 , ievodd , ilax ,     &
     &        ilaxis , ilaxm1 , ilaxm2 , ilaxm3 , ilaxm4 , ilaxp2 ,     &
     &        ilower , inc , ip1 , iplot , ipr , irax , iraxis
      INTEGER iraxm2 , irev , iskipm , itax , itaxis , itaxp1 , itaxp2 ,&
     &        iupper , ixdel , ixmid , iy , iydel , iymid , j , j1 ,    &
     &        j2 , j3 , j4 , mt , mx
      INTEGER my , N , n2 , nhalf , nhalfp , nm1 , nmi , numcla ,       &
     &        numdis , nummax , nummin , numout
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOTU
!
!     PURPOSE--THIS SUBROUTINE PRODUCES THE FOLLOWING 4 PLOTS--
!              ALL ON THE SAME PRINTER PAGE--
!              1) DATA PLOT--X(I) VERSUS I
!              2) AUTOREGRESSION PLOT--X(I) VERSUS X(I-1)
!              3) HISTOGRAM
!              4) NORMAL PROBABILITY PLOT
!              IN ADDITION, LOCATION, SCALE, AND AUTOCORRELATION
!              SUMMARY STATISTICS ARE PRINTED OUT AUTOMATICALLY
!              ON THE SAME PAGE.
!              THESE PLOTS GIVE THE DATA ANALYST A QUICK
!              FIRST-PASS CHECK AT SOME OF
!              THE UNDERLYING ASSUMPTIONS TYPICALLY MADE--
!              CONSTANT LOCATION, CONSTANT SCALE, NO OUTLIERS,
!              UNAUTOCORRELATED DATA, SYMMETRY, NORMALITY.
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED) OBSERVATIONS.
!                      N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--4 PLOTS (ALL ON THE SAME PRINTER PAGE)--
!             1) DATA PLOT--X(I) VERSUS I
!             2) AUTOREGRESSION PLOT--X(I) VERSUS X(I-1)
!             3) HISTOGRAM
!             4) NORMAL PROBABILITY PLOT
!             PLUS LOCATION, SCALE, AND
!             AUTOCORRELATION SUMMARY STATISTICS.
!     PRINTING--YES
!     RESTRICTIONS--THE MINIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 2.
!                 --THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, NORPPF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, 'SOME USEFUL COMPUTERIZED TECHNIQUES
!                 FOR DATA ANALYSIS', (UNPUBLISHED MANUSCRIPT
!                 AVAILABLE FROM AUTHOR), 1975.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --FILLIBEN, 'THE PROBABILITY PLOT CORRELATION COEFFICIENT
!                 TEST FOR NORMALITY', TECHNOMETRICS, 1975, PAGES 111-117.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1974.
!     UPDATED         --JANUARY   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --MAY       1976.
!     UPDATED         --FEBRUARY  1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 IGRaph
      CHARACTER*4 blank , hyphen , alphai , alphax
      CHARACTER*4 alpham , alphaa , alphad , alphan , equal
!
      DIMENSION X(1)
      DIMENSION X2(7500) , Y2(7500)
      DIMENSION ylable(45,4)
      DIMENSION xmin(4) , xmax(4) , xmid(4) , x25(4) , x75(4)
      DIMENSION itaxis(4) , ibaxis(4) , ilaxis(4) , iraxis(4)
      COMMON /BLOCK1/ IGRaph(55,130)
      COMMON /BLOCK2/ WS(15000)
!CCCC COMMON IGRAPH(45,110)
      EQUIVALENCE (X2(1),WS(1))
      EQUIVALENCE (Y2(1),WS(7501))
!
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
      DATA alpham , alphaa , alphad , alphan , equal/'M' , 'A' , 'D' ,  &
     &     'N' , '='/
      DATA itaxis(1) , ibaxis(1) , ilaxis(1) , iraxis(1)/1 , 19 , 5 ,   &
     &     49/
      DATA itaxis(2) , ibaxis(2) , ilaxis(2) , iraxis(2)/1 , 19 , 54 ,  &
     &     98/
      DATA itaxis(3) , ibaxis(3) , ilaxis(3) , iraxis(3)/27 , 45 , 5 ,  &
     &     49/
      DATA itaxis(4) , ibaxis(4) , ilaxis(4) , iraxis(4)/27 , 45 , 54 , &
     &     98/
!
      ipr = 6
      ilower = 2
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      WRITE (ipr,99001)
99001 FORMAT ('1')
      IF ( N<ilower .OR. N>iupper ) THEN
         WRITE (ipr,99002) ilower , iupper
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE PLOTU  SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (',I1,',',I6,') INTERVAL *****')
         WRITE (ipr,99003) N
99003    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT (A VECTOR) TO THE PL&
     &OTU  SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
         RETURN
      ENDIF
!
!-----START POINT-----------------------------------------------------
!
!     PRODUCE THE FIRST PLOT (UPPER LEFT)--X(I) VERSUS I
!
!     DETERMINE THE VERTICAL AXIS VECTOR Y2, THE HORIZONTAL
!     AXIS VECTOR X2, AND THE PLOT SAMPLE SIZE N2 FOR THIS
!     PARTICUAR PLOT.
!
 100  n2 = N
      DO i = 1 , n2
         Y2(i) = X(i)
         X2(i) = i
      ENDDO
!
      iplot = 1
!
!
!*********************************************************************
!
!     OPERATE ON A PARTICULAR PLOT
!
 200  itax = itaxis(iplot)
      ibax = ibaxis(iplot)
      ilax = ilaxis(iplot)
      irax = iraxis(iplot)
!
      itaxp2 = itax + 2
      ibaxm2 = ibax - 2
      ilaxp2 = ilax + 2
      iraxm2 = irax - 2
      ilaxm4 = ilax - 4
      ilaxm3 = ilax - 3
      ilaxm2 = ilax - 2
      ilaxm1 = ilax - 1
      iymid = (itaxp2+ibaxm2)/2
      ixmid = (ilaxp2+iraxm2)/2
      height = ibaxm2 - itaxp2
      width = iraxm2 - ilaxp2
!
!     BLANK OUT THE GRAPH
!
      DO i = itax , ibax
         DO j = ilaxm4 , irax
            IGRaph(i,j) = blank
         ENDDO
      ENDDO
!
!     PRODUCE THE Y AXIS
!
      DO i = itaxp2 , ibaxm2
         IGRaph(i,ilax) = alphai
         IGRaph(i,irax) = alphai
      ENDDO
      iydel = (ibaxm2-itaxp2)/2
      DO i = itaxp2 , ibaxm2 , iydel
         IGRaph(i,ilax) = hyphen
         IGRaph(i,irax) = hyphen
      ENDDO
      IGRaph(itaxp2,ilaxm4) = equal
      IGRaph(itaxp2,ilaxm3) = alpham
      IGRaph(itaxp2,ilaxm2) = alphaa
      IGRaph(itaxp2,ilaxm1) = alphax
      IGRaph(iymid,ilaxm4) = equal
      IGRaph(iymid,ilaxm3) = alpham
      IGRaph(iymid,ilaxm2) = alphai
      IGRaph(iymid,ilaxm1) = alphad
      IGRaph(ibaxm2,ilaxm4) = equal
      IGRaph(ibaxm2,ilaxm3) = alpham
      IGRaph(ibaxm2,ilaxm2) = alphai
      IGRaph(ibaxm2,ilaxm1) = alphan
!
!     PRODUCE THE X AXIS
!
      DO j = ilaxp2 , iraxm2
         IGRaph(itax,j) = hyphen
         IGRaph(ibax,j) = hyphen
      ENDDO
      ixdel = (iraxm2-ilaxp2)/4
      DO j = ilaxp2 , iraxm2 , ixdel
         IGRaph(itax,j) = alphai
         IGRaph(ibax,j) = alphai
      ENDDO
!
!     DETERMINE THE VALUES TO BE LISTED ON THE LEFT VERTICAL AXIS
!
      ymin = Y2(1)
      ymax = Y2(1)
      DO i = 1 , n2
         IF ( Y2(i)<ymin ) ymin = Y2(i)
         IF ( Y2(i)>ymax ) ymax = Y2(i)
      ENDDO
      IF ( iplot==3 ) ymin = 1.0
      DO i = itaxp2 , ibaxm2
         anum = i - itaxp2
         ylable(i,iplot) = ymax - (anum/height)*(ymax-ymin)
      ENDDO
!
!     DETERMINE XMIN, XMAX, XMID, X25 (=THE 25% POINT), AND
!     X75 (=THE 75% POINT)
!
      xmin2 = X2(1)
      xmax2 = X2(1)
      DO i = 1 , n2
         IF ( X2(i)<xmin2 ) xmin2 = X2(i)
         IF ( X2(i)>xmax2 ) xmax2 = X2(i)
      ENDDO
      xmin(iplot) = xmin2
      xmax(iplot) = xmax2
      xmid(iplot) = (xmin2+xmax2)/2.0
      x25(iplot) = 0.75*xmin2 + 0.25*xmax2
      x75(iplot) = 0.25*xmin2 + 0.75*xmax2
!
!     DETERMINE THE (X,Y) PLOT POSITIONS
!
      ratioy = 0.0
      ratiox = 0.0
      IF ( ymax>ymin ) ratioy = height/(ymax-ymin)
      IF ( xmax(iplot)>xmin(iplot) )                                    &
     &     ratiox = width/(xmax(iplot)-xmin(iplot))
      IF ( iplot==3 ) THEN
!
         DO i = 1 , n2
            IF ( Y2(i)>0.5 ) THEN
               mx = ratiox*(X2(i)-xmin(iplot)) + 0.5
               mx = mx + ilaxp2
               my = ratioy*(Y2(i)-ymin) + 0.5
               my = ibaxm2 - my
               IGRaph(my,mx) = alphax
               DO iy = my , ibaxm2
                  IGRaph(iy,mx) = alphax
               ENDDO
            ENDIF
         ENDDO
      ELSE
         DO i = 1 , n2
            mx = ratiox*(X2(i)-xmin(iplot)) + 0.5
            mx = mx + ilaxp2
            my = ratioy*(Y2(i)-ymin) + 0.5
            my = ibaxm2 - my
            IGRaph(my,mx) = alphax
         ENDDO
      ENDIF
!
      IF ( iplot==1 ) THEN
!
!*********************************************************************
!
!     PRODUCE THE SECOND PLOT (UPPER RIGHT)--X(I) VERSUS X(I-1)
!
!     DETERMINE THE VERTICAL AXIS VECTOR Y2, THE HORIZONTAL
!     AXIS VECTOR X2, AND THE PLOT SAMPLE SIZE N2 FOR THIS
!     PARTICULAR PLOT.
!
         n2 = N - 1
         DO i = 1 , n2
            ip1 = i + 1
            Y2(i) = X(ip1)
            X2(i) = X(i)
         ENDDO
!
         iplot = 2
         GOTO 200
      ELSEIF ( iplot==2 ) THEN
!
!*********************************************************************
!
!     PRODUCE THE THIRD PLOT (LOWER LEFT)-A HISTOGRAM
!
         n2 = 41
         inc = 3
!
!     COMPUTE THE SAMPLE MEAN AND SAMPLE STANDARD DEVIATION
!
         an = N
         sum = 0.0
         DO i = 1 , N
            sum = sum + X(i)
         ENDDO
         xmean = sum/an
         sum = 0.0
         DO i = 1 , N
            sum = sum + (X(i)-xmean)**2
         ENDDO
         s = SQRT(sum/(an-1.0))
!
!     FORM THE FREQUENCY TABLE (Y2) WHICH CORRESPONDS TO A HISTOGRAM
!     WITH 41 CLASSES AND A CLASS WIDTH OF THREE TENTHS OF A SAMPLE STANDARD
!     DEVIATION.
!
         DO i = 1 , 41
            Y2(i) = 0.0
         ENDDO
!
         numout = 0
         DO i = 1 , N
            z = (X(i)-xmean)/s
            IF ( -6.0<=z .AND. z<=6.0 ) THEN
               mt = ((z+6.0)/0.3) + 1.5
               Y2(mt) = Y2(mt) + 1.0
            ELSE
               numout = numout + 1
            ENDIF
         ENDDO
!
         DO i = 1 , 41
            ai = i
            X2(i) = xmean + ((ai-21.0)*0.3)*s
         ENDDO
!
         numcla = 41
         cwidsd = 0.3
         cwidth = cwidsd*s
!
         iplot = 3
         GOTO 200
      ELSEIF ( iplot==3 ) THEN
!
!*********************************************************************
!
!     PRODUCE THE FOURTH PLOT (LOWER RIGHT)--A NORMAL PROBABILITY PLOT
!
!     DETERMINE THE VERTICAL AXIS VECTOR Y2, THE HORIZONTAL
!     AXIS VECTOR X2, AND THE PLOT SAMPLE SIZE N2 FOR THIS
!     PARTICUAR PLOT.
!
         n2 = N
         CALL SORT(X,N,Y2)
         CALL UNIMED(N,X2)
         DO i = 1 , N
            CALL NORPPF(X2(i),X2(i))
         ENDDO
!
         iplot = 4
         GOTO 200
      ELSE
!
!********************************************************************
!
!     COMPUTE SUMMARY STATISTICS
!
         zmin = Y2(1)
         zmax = Y2(N)
         zrange = zmax - zmin
         zmean = xmean
         zsd = s
         zdevb = zmean - zmin
         zrdevb = 0.0
         IF ( zmean/=0.0 ) zrdevb = 100.0*zdevb/zmean
         IF ( zrdevb<0.0 ) zrdevb = -zrdevb
         zdeva = zmax - zmean
         zrdeva = 0.0
         IF ( zmean/=0.0 ) zrdeva = 100.0*zdeva/zmean
         IF ( zrdeva<0.0 ) zrdeva = -zrdeva
!
!     DETERMINE THE NUMBER OF DISTINCT POINTS
!
         numdis = 1
         nm1 = N - 1
         DO i = 1 , nm1
            ip1 = i + 1
            IF ( Y2(i)/=Y2(ip1) ) numdis = numdis + 1
         ENDDO
!
!     COMPUTE THE SAMPLE MEDIAN
!
         nhalf = N/2
         ievodd = N - 2*(N/2)
         IF ( ievodd==0 ) THEN
            nhalfp = nhalf + 1
            zmed = (Y2(nhalf)+Y2(nhalfp))/2.0
         ELSE
            zmed = Y2(nhalf)
         ENDIF
!
!     DETERMINE THE FREQUENCY OF THE SAMPLE MIN AND MAX
!
         nummin = 1
         nm1 = N - 1
         DO i = 1 , nm1
            ip1 = i + 1
            IF ( Y2(i)==Y2(ip1) ) nummin = nummin + 1
            IF ( Y2(i)/=Y2(ip1) ) EXIT
         ENDDO
         nummax = 1
         DO i = 1 , nm1
            irev = N - i + 1
            nmi = N - i
            IF ( Y2(irev)==Y2(nmi) ) nummax = nummax + 1
            IF ( Y2(irev)/=Y2(nmi) ) EXIT
         ENDDO
         promin = nummin
         promin = 100.0*promin/an
         promax = nummax
         promax = 100.0*promax/an
!
!     COMPUTE THE AUTOCORRELATION
!
         zmean1 = (an*zmean-X(N))/(an-1.0)
         zmean2 = (an*zmean-X(1))/(an-1.0)
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         nm1 = N - 1
         DO i = 1 , nm1
            ip1 = i + 1
            sum1 = sum1 + (X(i)-zmean1)*(X(ip1)-zmean2)
            sum2 = sum2 + (X(i)-zmean1)**2
            sum3 = sum3 + (X(ip1)-zmean2)**2
         ENDDO
         sum23 = sum2*sum3
         zautoc = 9999.99
         IF ( sum23>0.0 ) zautoc = sum1/(SQRT(sum23))
         zautoc = 100.0*zautoc
!
!     WRITE EVERYTHING OUT
!
         itax = itaxis(1)
         ibax = ibaxis(1)
         itaxp1 = itax + 1
         itaxp2 = itax + 2
         ibaxm1 = ibax - 1
         ibaxm2 = ibax - 2
         j1 = ilaxis(1) - 4
         j2 = iraxis(1)
         j3 = ilaxis(2) - 4
         j4 = iraxis(2)
         WRITE (ipr,99005)
!
99005    FORMAT (' ',20X,12X,'PLOT OF X(I) VERSUS I',41X,'PLOT OF ',    &
     &           'X(I) VERSUS X(I-1)')
         WRITE (ipr,99018) (IGRaph(itax,j),j=j1,j2) ,                   &
     &                     (IGRaph(itax,j),j=j3,j4)
         WRITE (ipr,99018) (IGRaph(itaxp1,j),j=j1,j2) ,                 &
     &                     (IGRaph(itaxp1,j),j=j3,j4)
         DO i = itaxp2 , ibaxm2
            WRITE (ipr,99019) ylable(i,1) , (IGRaph(i,j),j=j1,j2) ,     &
     &                        ylable(i,2) , (IGRaph(i,j),j=j3,j4)
         ENDDO
         WRITE (ipr,99018) (IGRaph(ibaxm1,j),j=j1,j2) ,                 &
     &                     (IGRaph(ibaxm1,j),j=j3,j4)
         WRITE (ipr,99018) (IGRaph(ibax,j),j=j1,j2) ,                   &
     &                     (IGRaph(ibax,j),j=j3,j4)
         WRITE (ipr,99020) xmin(1) , x25(1) , xmid(1) , x75(1) , xmax(1)&
     &                     , xmin(2) , x25(2) , xmid(2) , x75(2) ,      &
     &                     xmax(2)
!
         iskipm = 2
         DO i = 1 , iskipm
            WRITE (ipr,99006)
99006       FORMAT (' ')
         ENDDO
!
         itax = itaxis(3)
         ibax = ibaxis(3)
         itaxp1 = itax + 1
         itaxp2 = itax + 2
         ibaxm1 = ibax - 1
         ibaxm2 = ibax - 2
         j1 = ilaxis(3) - 4
         j2 = iraxis(3)
         j3 = ilaxis(4) - 4
         j4 = iraxis(4)
         WRITE (ipr,99007)
99007    FORMAT (' ',38X,'HISTOGRAM',49X,'NORMAL PROBABILITY PLOT')
         WRITE (ipr,99018) (IGRaph(itax,j),j=j1,j2) ,                   &
     &                     (IGRaph(itax,j),j=j3,j4)
         WRITE (ipr,99018) (IGRaph(itaxp1,j),j=j1,j2) ,                 &
     &                     (IGRaph(itaxp1,j),j=j3,j4)
         DO i = itaxp2 , ibaxm2
            WRITE (ipr,99019) ylable(i,3) , (IGRaph(i,j),j=j1,j2) ,     &
     &                        ylable(i,4) , (IGRaph(i,j),j=j3,j4)
         ENDDO
         WRITE (ipr,99018) (IGRaph(ibaxm1,j),j=j1,j2) ,                 &
     &                     (IGRaph(ibaxm1,j),j=j3,j4)
         WRITE (ipr,99018) (IGRaph(ibax,j),j=j1,j2) ,                   &
     &                     (IGRaph(ibax,j),j=j3,j4)
         WRITE (ipr,99020) xmin(3) , x25(3) , xmid(3) , x75(3) , xmax(3)&
     &                     , xmin(4) , x25(4) , xmid(4) , x75(4) ,      &
     &                     xmax(4)
         WRITE (ipr,99008)
99008    FORMAT (' ',20X,' -6        -3         0         3         6')
         WRITE (ipr,99009) numcla , N , numdis
99009    FORMAT (' ',20X,'NUMBER OF CLASSES = ',I3,42X,'SAMPLE SIZE =', &
     &           I9,' DISTINCT POINTS =',I6)
         WRITE (ipr,99010) cwidth , cwidsd , zmin , nummin , promin
99010    FORMAT (' ',20X,'CLASS WIDTH = ',E14.7,' = ',F3.1,             &
     &           ' STANDARD DEVIATIONS',11X,'MINIMUM =',F13.6,          &
     &           ' COUNT =',I5,' (',F7.2,'%)')
         WRITE (ipr,99011) numout , zmed
99011    FORMAT (' ',16X,I5,' OBSERVATIONS WERE IN EXCESS OF 6 STANDARD'&
     &           ,' DEVIATIONS',11X,'MEDIAN =',F14.6)
         WRITE (ipr,99012) zmean
99012    FORMAT (' ',20X,                                               &
     &      'ABOUT THE SAMPLE MEAN AND SO WERE NOT PRINTED IN HISTOGRAM'&
     &      ,7X,'MEAN =',F16.6)
         WRITE (ipr,99013) zmax , nummax , promax
99013    FORMAT (' ',85X,'MAXIMUM =',F13.6,' COUNT =',I5,' (',F7.2,'%)')
         WRITE (ipr,99014) zsd , zrange
99014    FORMAT (' ',85X,'ST. DEV. =',F12.6,' RANGE =',F16.6)
         WRITE (ipr,99015) zdevb , zrdevb
99015    FORMAT (' ',20X,65X,'MAX DEV. BELOW MEAN =',F14.6,' (',F7.2,   &
     &           '%)')
         WRITE (ipr,99016) zdeva , zrdeva
99016    FORMAT (' ',85X,'MAX DEV. ABOVE MEAN =',F14.6,' (',F7.2,'%)')
         WRITE (ipr,99017) zautoc
99017    FORMAT (' ',85X,'AUTOCORR. =',F10.2,'%')
      ENDIF
99018 FORMAT (' ',16X,4A1,45A1,16X,4A1,45A1)
99019 FORMAT (' ',F16.7,4A1,45A1,F16.7,4A1,45A1)
99020 FORMAT (' ',17X,5F10.4,15X,4F10.4,F9.3)
!
      END SUBROUTINE PLOTU
!*==plotx.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOTX(X,N)
      IMPLICIT NONE
!*--PLOTX21389
!*** Start of declarations inserted by SPAG
      REAL aim1 , cutoff , hold , ratiox , ratioy , X , x25 , x75 , xi ,&
     &     xmax , xmid , xmin , ylable , ymax , ymin
      INTEGER i , iflag , ip2 , ipr , j , k , mx , my , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOTX
!
!     PURPOSE--THIS SUBROUTINE YIELDS A ONE-PAGE PRINTER PLOT
!              OF X(I) VERSUS I.
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED VERTICALLY.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--A ONE-PAGE PRINTER PLOT OF X(I) VERSUS I.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--VALUES IN THE VERTICAL AXIS VECTOR (X) WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR X
!              ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR X
!              FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN X TO BE PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN X TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOTX
!              SUBROUTINE.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --JANUARY   1975.
!     UPDATED         --JULY      1975.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --FEBRUARY  1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 IGRaph
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22
      CHARACTER*4 blank , hyphen , alphai , alphax
      CHARACTER*4 alpham , alphaa , alphad , alphan , equal
!
      DIMENSION X(1)
      DIMENSION ylable(11)
      COMMON /BLOCK1/ IGRaph(55,130)
!
      DATA sbnam1 , sbnam2/'PLOT' , 'X   '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
      DATA alpham , alphaa , alphad , alphan , equal/'M' , 'A' , 'D' ,  &
     &     'N' , '='/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      WRITE (ipr,99001)
99001 FORMAT ('1')
      IF ( N<1 ) THEN
         WRITE (ipr,99011)
         WRITE (ipr,99012)
         WRITE (ipr,99013) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99002) N
99002    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99011)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99011)
            WRITE (ipr,99012)
            WRITE (ipr,99013) alph21 , alph22 , sbnam1 , sbnam2
            WRITE (ipr,99003) N
99003       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99011)
            RETURN
         ELSE
!
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99011)
            WRITE (ipr,99012)
            WRITE (ipr,99013) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99004) hold
99004       FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
            WRITE (ipr,99011)
            RETURN
         ENDIF
!
 50      DO i = 1 , N
            IF ( X(i)<cutoff ) GOTO 100
         ENDDO
         WRITE (ipr,99011)
         WRITE (ipr,99012)
         WRITE (ipr,99013) alph11 , alph12 , sbnam1 , sbnam2
         WRITE (ipr,99005)
99005    FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
         WRITE (ipr,99006) cutoff
99006    FORMAT (' ','VALUE OF ',E15.8)
         WRITE (ipr,99011)
         RETURN
      ENDIF
!
!-----START POINT-----------------------------------------------------
!
!     DETERMINE THE VALUES TO BE LISTED ON THE LEFT VERTICAL AXIS
!
 100  DO i = 1 , N
         IF ( X(i)<cutoff ) THEN
            ymin = X(i)
            ymax = X(i)
            EXIT
         ENDIF
      ENDDO
      DO i = 1 , N
         IF ( X(i)<cutoff ) THEN
            IF ( X(i)<ymin ) ymin = X(i)
            IF ( X(i)>ymax ) ymax = X(i)
         ENDIF
      ENDDO
      DO i = 1 , 9
         aim1 = i - 1
         ylable(i) = ymax - (aim1/8.0)*(ymax-ymin)
      ENDDO
!
!     DETERMINE THE VALUES TO BE LISTED ON THE BOTTOM HORIZONTAL AXIS.
!     DETERMINE XMIN, XMAX, XMID, X25 (=THE 25% POINT), AND
!     X75 (=THE 75% POINT).
!
      xmin = 1.0
      xmax = N
      xmid = (xmin+xmax)/2.0
      x25 = 0.75*xmin + 0.25*xmax
      x75 = 0.25*xmin + 0.75*xmax
!
!     BLANK OUT THE GRAPH
!
      DO i = 1 , 45
         DO j = 1 , 109
            IGRaph(i,j) = blank
         ENDDO
      ENDDO
!
!     PRODUCE THE VERTICAL AXES
!
      DO i = 3 , 43
         IGRaph(i,5) = alphai
         IGRaph(i,109) = alphai
      ENDDO
      DO i = 3 , 43 , 5
         IGRaph(i,5) = hyphen
         IGRaph(i,109) = hyphen
      ENDDO
      IGRaph(3,1) = equal
      IGRaph(3,2) = alpham
      IGRaph(3,3) = alphaa
      IGRaph(3,4) = alphax
      IGRaph(23,1) = equal
      IGRaph(23,2) = alpham
      IGRaph(23,3) = alphai
      IGRaph(23,4) = alphad
      IGRaph(43,1) = equal
      IGRaph(43,2) = alpham
      IGRaph(43,3) = alphai
      IGRaph(43,4) = alphan
!
!     PRODUCE THE HORIZONTAL AXES
!
      DO j = 7 , 107
         IGRaph(1,j) = hyphen
         IGRaph(45,j) = hyphen
      ENDDO
      DO j = 7 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
      DO j = 20 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
!
!     DETERMINE THE (X,Y) PLOT POSITIONS
!
      ratioy = 40.0/(ymax-ymin)
      ratiox = 100.0/(xmax-xmin)
      DO i = 1 , N
         IF ( X(i)<cutoff ) THEN
            xi = i
            mx = ratiox*(xi-xmin) + 0.5
            mx = mx + 7
            my = ratioy*(X(i)-ymin) + 0.5
            my = 43 - my
            IGRaph(my,mx) = alphax
         ENDIF
      ENDDO
!
!     WRITE OUT THE GRAPH
!
      WRITE (ipr,99007)
!
99007 FORMAT (' ',                                                      &
     &'THE FOLLOWING IS A PLOT OF X(I) (VERTICALLY) VERSUS I (HORIZONTAL&
     &LY)')
      DO i = 1 , 45
         ip2 = i + 2
         iflag = ip2 - (ip2/5)*5
         k = ip2/5
         IF ( iflag/=0 ) WRITE (ipr,99008) (IGRaph(i,j),j=1,109)
99008    FORMAT (' ',20X,109A1)
         IF ( iflag==0 ) WRITE (ipr,99009) ylable(k) ,                  &
     &                          (IGRaph(i,j),j=1,109)
99009    FORMAT (' ',F20.7,109A1)
      ENDDO
      WRITE (ipr,99010) xmin , x25 , xmid , x75 , xmax
99010 FORMAT (' ',14X,F20.7,5X,F20.7,5X,F20.7,5X,F20.7,1X,F20.7)
!
99011 FORMAT (' ','**************************************************', &
     &        '********************')
99012 FORMAT (' ','                   FATAL ERROR                    ')
99013 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
!
      END SUBROUTINE PLOTX
!*==plotxt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOTXT(X,N)
      IMPLICIT NONE
!*--PLOTXT21638
!*** Start of declarations inserted by SPAG
      REAL ai , ailabl , aim1 , aimax , aimin , airow , aiwidt ,        &
     &     anumcm , anumlm , anumr , anumrm , cutoff , delai , delx ,   &
     &     hold , X , xlable , xlower , xmax , xmin
      REAL xupper , xwidth
      INTEGER i , icol , icolmx , ipr , irow , ixdel , N , numcol ,     &
     &        numlab , numr25 , numr50 , numr75 , numrow
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOTXT
!
!     PURPOSE--THIS SUBROUTINE YIELDS A NARROW-WIDTH (71-CHARACTER)
!              PLOT OF X(I) VERSUS I.  ITS NARROW WIDTH MAKES IT
!              APPROPRIATE FOR USE ON A TERMINAL.
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED VERTICALLY.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--A NARROW-WIDTH (71-CHARACTER) TERMINAL PLOT
!             OF X(I) VERSUS I.
!             THE BODY OF THE PLOT (NOT COUNTING AXIS VALUES
!             AND MARGINS) IS 25 ROWS (LINES) AND 49 COLUMNS.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--VALUES IN THE VERTICAL AXIS VECTOR (X) WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR X
!              ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR X
!              FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN X TO BE PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN X TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOTX
!              SUBROUTINE.
!            --NOTE THAT THE STORAGE REQUIREMENTS FOR THIS
!              (AND THE OTHER) TERMINAL PLOT SUBROUTINESS ARE .
!              VERY SMALL.
!              THIS IS DUE TO THE 'ONE LINE AT A TIME' ALGORITHM
!              EMPLOYED FOR THE PLOT.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--FEBRUARY  1974.
!     UPDATED         --APRIL     1974.
!     UPDATED         --OCTOBER   1974.
!     UPDATED         --OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 iline
      CHARACTER*4 iaxisc
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22
      CHARACTER*4 blank , hyphen , alphai , alphax
!
      DIMENSION X(1)
      DIMENSION iline(72) , ailabl(10)
!
      DATA sbnam1 , sbnam2/'PLOT' , 'XT  '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99010)
         WRITE (ipr,99011)
         WRITE (ipr,99012) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99001) N
99001    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99010)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99010)
            WRITE (ipr,99011)
            WRITE (ipr,99012) alph21 , alph22 , sbnam1 , sbnam2
            WRITE (ipr,99002) N
99002       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99010)
            RETURN
         ELSE
!
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99010)
            WRITE (ipr,99011)
            WRITE (ipr,99012) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99003) hold
99003       FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
            WRITE (ipr,99010)
            RETURN
         ENDIF
!
 50      DO i = 1 , N
            IF ( X(i)<cutoff ) GOTO 100
         ENDDO
         WRITE (ipr,99010)
         WRITE (ipr,99011)
         WRITE (ipr,99012) alph11 , alph12 , sbnam1 , sbnam2
         WRITE (ipr,99004)
99004    FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
         WRITE (ipr,99005) cutoff
99005    FORMAT (' ','VALUE OF ',E15.8)
         WRITE (ipr,99010)
         RETURN
      ENDIF
!
!-----START POINT-----------------------------------------------------
!
!     DEFINE THE NUMBER OF ROWS AND COLUMNS WITHIN THE PLOT--
!     THIS HAS BEEN SET TO 25 ROWS AND 49 COLUMNS.
!
 100  numrow = 25
      numcol = 49
      anumr = numrow
      anumrm = numrow - 1
      anumcm = numcol - 1
      numr25 = (numrow/4) + 1
      numr50 = (numrow/2) + 1
      numr75 = 3*(numrow/4) + 1
      ixdel = (numcol-1)/4
      numlab = 5
      anumlm = numlab - 1
!
!     WRITE OUT THE TOP HORIZONTAL AXIS OF THE PLOT, AND SKIP 1 LINE
!     FOR A MARGIN WITHIN THE PLOT.
!
      WRITE (ipr,99006)
99006 FORMAT (' ')
      WRITE (ipr,99007)
!
99007 FORMAT (' ','THE FOLLOWING IS A PLOT OF X(I) (VERTICALLY) ',      &
     &        'VERSUS I (HORIZONTALLY')
      DO icol = 1 , numcol
         iline(icol) = hyphen
      ENDDO
      DO icol = 1 , numcol , ixdel
         iline(icol) = alphai
      ENDDO
      WRITE (ipr,99013) (iline(i),i=1,numcol)
      WRITE (ipr,99014) blank
!
!     DETERMINE THE MIN AND MAX VALUES OF X, AND OF I.
!
      xmin = X(1)
      xmax = X(1)
      aimin = 1
      aimax = N
      DO i = 1 , N
         IF ( X(i)<cutoff ) THEN
            IF ( X(i)<xmin ) xmin = X(i)
            IF ( X(i)>xmax ) xmax = X(i)
         ENDIF
      ENDDO
      delx = xmax - xmin
      delai = aimax - aimin
      xwidth = delx/anumrm
      aiwidt = delai/anumcm
!
!     DETERMINE AND WRITE OUT THE PLOT POSITIONS ONE LINE AT A TIME.
!
      DO irow = 1 , numrow
         DO icol = 1 , numcol
            iline(icol) = blank
         ENDDO
         airow = irow
         xupper = xmax + (1.5-airow)*xwidth
         xlable = xmax + (1.0-airow)*xwidth
         xlower = xmax + (0.5-airow)*xwidth
         IF ( irow==numrow ) xlable = xmin
         DO i = 1 , N
            ai = i
            IF ( X(i)<cutoff ) THEN
               IF ( xlower<=X(i) .AND. X(i)<xupper ) THEN
                  icol = ((ai-aimin)/aiwidt) + 1.5
                  iline(icol) = alphax
               ENDIF
            ENDIF
         ENDDO
         icolmx = 1
         DO icol = 1 , numcol
            IF ( iline(icol)==alphax ) icolmx = icol
         ENDDO
         iaxisc = alphai
         IF ( irow==1 .OR. irow==numrow ) iaxisc = hyphen
         IF ( irow==numr25 .OR. irow==numr50 .OR. irow==numr75 )        &
     &        iaxisc = hyphen
         WRITE (ipr,99008) xlable , iaxisc , (iline(icol),icol=1,icolmx)
99008    FORMAT (' ',E14.7,1X,A1,2X,50A1)
      ENDDO
!
!     SKIP 1 LINE FOR A BOTTOM MARGIN WITHIN THE PLOT, WRITE OUT THE
!     BOTTOM HORIZONTAL AXIS, AND WRITE OUT THE X AXIS LABLES.
!
      WRITE (ipr,99014) blank
      DO icol = 1 , numcol
         iline(icol) = hyphen
      ENDDO
      DO icol = 1 , numcol , ixdel
         iline(icol) = alphai
      ENDDO
      WRITE (ipr,99013) (iline(icol),icol=1,numcol)
      DO i = 1 , numlab
         aim1 = i - 1
         ailabl(i) = aimin + (aim1/anumlm)*delai
      ENDDO
      WRITE (ipr,99009) (ailabl(i),i=1,numlab)
99009 FORMAT (' ',9X,5E12.4)
!
99010 FORMAT (' ','**************************************************', &
     &        '********************')
99011 FORMAT (' ','                   FATAL ERROR                    ')
99012 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
99013 FORMAT (' ',18X,54A1)
99014 FORMAT (' ',15X,A1)
!
      END SUBROUTINE PLOTXT
!*==plotxx.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLOTXX(X,N)
      IMPLICIT NONE
!*--PLOTXX21883
!*** Start of declarations inserted by SPAG
      REAL aim1 , cutoff , hold , ratiox , ratioy , X , x25 , x75 ,     &
     &     xmax , xmid , xmin , ylable , ymax , ymin
      INTEGER i , iflag , im1 , ip2 , ipr , j , k , mx , my , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLOTXX
!
!     PURPOSE--THIS SUBROUTINE YIELDS A ONE-PAGE PRINTER PLOT
!              OF X(I) VERSUS X(I-1).
!              THIS TYPE OF PLOT (WHICH IS CALLED AN
!              AUTOCORRELATION PLOT OR A LAG 1 PLOT)
!              IS USEFUL IN EXAMINING FOR
!              AUTOCORRELATION IN A SEQUENCE OF OBSERVATIONS.
!              UNCORRELATED DATA WILL PRODUCE AN AUTOCORRELATION
!              PLOT WITH NO APPARENT STRUCTURE; AUTOCORRELATED
!              DATA WILL PRODUCE AN AUTOCORRELATION PLOT WITH
!              LINEAR, ELLIPTICAL, OR OTHER KINDS OF STRUCTURE.
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED) OBSERVATIONS
!                               TO BE GRAPHICALLY TESTED FOR
!                               AUTOCORRELATION.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--A ONE-PAGE PRINTER PLOT OF X(I) VERSUS X(I-1).
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--VALUES IN THE INPUT VECTOR X WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR X
!              ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR X
!              FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN X TO BE PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN X TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOTXX
!              SUBROUTINE.
!     REFERENCES--FILLIBEN, 'SOME USEFUL PROCEDURES FOR THE
!                 STATISTICAL ANALYSIS OF DATA', UNPUBLISHED
!                 MANUSCRIPT (AVAILABLE FROM AUTHOR)
!                 PRESENTED AT THE FALL CONFERENCE
!                 OF THE CHEMICAL DIVISION OF THE AMERICAN
!                 SOCIETY FOR QUALITY CONTROL, KNOXVILLE,
!                 TENNESSEE, OCTOBER 19-20, 1972.
!               --FILLIBEN, 'DATA EXPLORATION USING STAND-ALONE
!                 SUBROUTINES', UNPUBLISHED MANUSCRIPT
!                 (AVAILABLE FROM AUTHOR)
!                 PRESENTED AT THE 'STRATEGY FOR DATA ANALYSIS
!                 BY COMPUTERS' SESSION AT THE NATIONAL
!                 MEETING OF THE AMERICAN STATISTICAL ASSOCIATION,
!                 ST. LOUIS, MISSOURI, AUGUST 26-29, 1974.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --OCTOBER   1974.
!     UPDATED         --NOVEMBER  1974.
!     UPDATED         --JANUARY   1975.
!     UPDATED         --JULY      1975.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --FEBRUARY  1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 IGRaph
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22
      CHARACTER*4 blank , hyphen , alphai , alphax
      CHARACTER*4 alpham , alphaa , alphad , alphan , equal
!
      DIMENSION X(1)
      DIMENSION ylable(11)
      COMMON /BLOCK1/ IGRaph(55,130)
!
      DATA sbnam1 , sbnam2/'PLOT' , 'XX  '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
      DATA alpham , alphaa , alphad , alphan , equal/'M' , 'A' , 'D' ,  &
     &     'N' , '='/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      WRITE (ipr,99001)
99001 FORMAT ('1')
      IF ( N<1 ) THEN
         WRITE (ipr,99011)
         WRITE (ipr,99012)
         WRITE (ipr,99013) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99002) N
99002    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99011)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99011)
            WRITE (ipr,99012)
            WRITE (ipr,99013) alph21 , alph22 , sbnam1 , sbnam2
            WRITE (ipr,99003) N
99003       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99011)
            RETURN
         ELSE
!
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99011)
            WRITE (ipr,99012)
            WRITE (ipr,99013) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99004) hold
99004       FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
            WRITE (ipr,99011)
            RETURN
         ENDIF
!
 50      DO i = 1 , N
            IF ( X(i)<cutoff ) GOTO 100
         ENDDO
         WRITE (ipr,99011)
         WRITE (ipr,99012)
         WRITE (ipr,99013) alph11 , alph12 , sbnam1 , sbnam2
         WRITE (ipr,99005)
99005    FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
         WRITE (ipr,99006) cutoff
99006    FORMAT (' ','VALUE OF ',E15.8)
         WRITE (ipr,99011)
         RETURN
      ENDIF
!
!-----START POINT-----------------------------------------------------
!
!     DETERMINE THE VALUES TO BE LISTED ON THE LEFT VERTICAL AXIS
!
 100  DO i = 1 , N
         IF ( X(i)<cutoff ) THEN
            ymin = X(i)
            ymax = X(i)
            EXIT
         ENDIF
      ENDDO
      DO i = 1 , N
         IF ( X(i)<cutoff ) THEN
            IF ( X(i)<ymin ) ymin = X(i)
            IF ( X(i)>ymax ) ymax = X(i)
         ENDIF
      ENDDO
      DO i = 1 , 9
         aim1 = i - 1
         ylable(i) = ymax - (aim1/8.0)*(ymax-ymin)
      ENDDO
!
!     DETERMINE THE VALUES TO BE LISTED ON THE BOTTOM HORIZONTAL AXIS.
!     DETERMINE XMIN, XMAX, XMID, X25 (=THE 25% POINT), AND
!     X75 (=THE 75% POINT).
!
      xmin = ymin
      xmax = ymax
      xmid = (xmin+xmax)/2.0
      x25 = 0.75*xmin + 0.25*xmax
      x75 = 0.25*xmin + 0.75*xmax
!
!     BLANK OUT THE GRAPH
!
      DO i = 1 , 45
         DO j = 1 , 109
            IGRaph(i,j) = blank
         ENDDO
      ENDDO
!
!     PRODUCE THE VERTICAL AXES
!
      DO i = 3 , 43
         IGRaph(i,5) = alphai
         IGRaph(i,109) = alphai
      ENDDO
      DO i = 3 , 43 , 5
         IGRaph(i,5) = hyphen
         IGRaph(i,109) = hyphen
      ENDDO
      IGRaph(3,1) = equal
      IGRaph(3,2) = alpham
      IGRaph(3,3) = alphaa
      IGRaph(3,4) = alphax
      IGRaph(23,1) = equal
      IGRaph(23,2) = alpham
      IGRaph(23,3) = alphai
      IGRaph(23,4) = alphad
      IGRaph(43,1) = equal
      IGRaph(43,2) = alpham
      IGRaph(43,3) = alphai
      IGRaph(43,4) = alphan
!
!     PRODUCE THE HORIZONTAL AXES
!
      DO j = 7 , 107
         IGRaph(1,j) = hyphen
         IGRaph(45,j) = hyphen
      ENDDO
      DO j = 7 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
      DO j = 20 , 107 , 25
         IGRaph(1,j) = alphai
         IGRaph(45,j) = alphai
      ENDDO
!
!     DETERMINE THE (X,Y) PLOT POSITIONS
!
      ratioy = 40.0/(ymax-ymin)
      ratiox = 100.0/(xmax-xmin)
      DO i = 2 , N
         im1 = i - 1
         IF ( X(i)<cutoff ) THEN
            IF ( X(im1)<cutoff ) THEN
               mx = ratiox*(X(im1)-xmin) + 0.5
               mx = mx + 7
               my = ratioy*(X(i)-ymin) + 0.5
               my = 43 - my
               IGRaph(my,mx) = alphax
            ENDIF
         ENDIF
      ENDDO
!
!     WRITE OUT THE GRAPH
!
      WRITE (ipr,99007)
!
99007 FORMAT (' ',                                                      &
     &'THE FOLLOWING IS A PLOT OF X(I) (VERTICALLY) VERSUS X(I-1) (HORIZ&
     &ONTALLY)')
      DO i = 1 , 45
         ip2 = i + 2
         iflag = ip2 - (ip2/5)*5
         k = ip2/5
         IF ( iflag/=0 ) WRITE (ipr,99008) (IGRaph(i,j),j=1,109)
99008    FORMAT (' ',20X,109A1)
         IF ( iflag==0 ) WRITE (ipr,99009) ylable(k) ,                  &
     &                          (IGRaph(i,j),j=1,109)
99009    FORMAT (' ',F20.7,109A1)
      ENDDO
      WRITE (ipr,99010) xmin , x25 , xmid , x75 , xmax
99010 FORMAT (' ',14X,F20.7,5X,F20.7,5X,F20.7,5X,F20.7,1X,F20.7)
!
99011 FORMAT (' ','**************************************************', &
     &        '********************')
99012 FORMAT (' ','                   FATAL ERROR                    ')
99013 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
!
      END SUBROUTINE PLOTXX
!*==pltsct.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLTSCT(Y,X,Char,N,D,Dmin,Dmax)
      IMPLICIT NONE
!*--PLTSCT22158
!*** Start of declarations inserted by SPAG
      REAL aim1 , airow , anumcm , anumlm , anumr , anumrm , Char ,     &
     &     cutoff , D , delx , dely , Dmax , Dmin , hold , X , xlable , &
     &     xmax , xmin , xwidth , Y
      REAL ylable , ylower , ymax , ymin , yupper , ywidth
      INTEGER i , ia , icol , icolmx , ipr , irow , ixdel , N , n2 ,    &
     &        numcol , numlab , numr25 , numr50 , numr75 , numrow
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLTSCT
!
!     PURPOSE--THIS SUBROUTINE YIELDS A NARROW-WIDTH (71-CHARACTER)
!              PLOT OF Y(I) VERSUS X(I):
!              1) WITH SPECIAL PLOT CHARACTERS; AND
!              2) WITH ONLY THOSE POINTS (X(I),Y(I)) PLOTTED
!                 FOR WHICH THE CORRESPONDING VALUE OF D(I)
!                 IS BETWEEN THE SPECIFIED VALUES OF DMIN AND DMAX.
!
!              ITS NARROW WIDTH MAKES IT APPROPRIATE FOR USE ON A
!              TERMINAL.
!              THE 'SPECIAL PLOTTING CHARACTER' CAPABILITY
!              ALLOWS THE DATA ANALYST TO INCORPORATE INFORMATION
!              FROM A THIRD VARIABLE (ASIDE FROM Y AND X) INTO
!              THE PLOT.
!              THE PLOT CHARACTER USED AT THE I-TH PLOTTING
!              POSITION (THAT IS, AT THE COORDINATE (X(I),Y(I)))
!              WILL BE
!              1 IF CHAR(I) IS BETWEEN  0.5 AND  1.5
!              2 IF CHAR(I) IS BETWEEN  1.5 AND  2.5
!                .
!                .
!                .
!              9 IF CHAR(I) IS BETWEEN  8.5 AND  9.5
!              0 IF CHAR(I) IS BETWEEN  9.5 AND 10.5
!              A IF CHAR(I) IS BETWEEN 10.5 AND 11.5
!              B IF CHAR(I) IS BETWEEN 11.5 AND 12.5
!              C IF CHAR(I) IS BETWEEN 12.5 AND 13.5
!                .
!                .
!                .
!              W IF CHAR(I) IS BETWEEN 32.5 AND 33.5
!              X IF CHAR(I) IS BETWEEN 33.5 AND 34.5
!              Y IF CHAR(I) IS BETWEEN 34.5 AND 35.5
!              Z IF CHAR(I) IS BETWEEN 35.5 AND 36.5
!              X IF CHAR(I) IS ANY VALUE OUTSIDE THE RANGE
!                                       0.5 TO  36.5.
!              THE USE OF THE SUBSET DEFINTION VECTOR D
!              GIVES THE DATA ANALYST THE CAPABILITY OF
!              PLOTTING SUBSETS OF THE DATA,
!              WHERE THE SUBSET IS DEFINED
!              BY VALUES IN THE VECTOR D.
!
!     INPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED VERTICALLY.
!                    --X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS
!                               TO BE PLOTTED HORIZONTALLY.
!                    --CHAR   = THE SINGLE PRECISION VECTOR OF
!                               OBSERVATIONS WHICH CONTROL THE
!                               VALUE OF EACH INDIVIDUAL PLOT
!                               CHARACTER.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR Y.
!                    --D      = THE SINGLE PRECISION VECTOR
!                               WHICH 'DEFINES' THE VARIOUS
!                               POSSIBLE SUBSETS.
!                    --DMIN   = THE SINGLE PRECISION VALUE
!                               WHICH DEFINES THE LOWER BOUND
!                               (INCLUSIVELY) OF THE PARTICULAR
!                               SUBSET OF INTEREST TO BE PLOTTED.
!                    --DMAX   = THE SINGLE PRECISION VALUE
!                               WHICH DEFINES THE UPPER BOUND
!                               (INCLUSIVELY) OF THE PARTICULAR
!                               SUBSET OF INTEREST TO BE PLOTTED.
!     OUTPUT--A NARROW-WIDTH (71-CHARACTER) TERMINAL PLOT
!             OF Y(I) VERSUS X(I) WITH SPECIAL PLOT CHARACTERS
!             AND FOR ONLY A SPECIFIED SUBSET OF THE DATA.
!             THE BODY OF THE PLOT (NOT COUNTING AXIS VALUES
!             AND MARGINS) IS 25 ROWS (LINES) AND 49 COLUMNS.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--FOR A GIVEN DUMMY INDEX I,
!              IF D(I) IS SMALLER THAN DMIN OR LARGER THAN DMAX,
!              THEN THE CORRESPONDING POINT (X(I),Y(I))
!              WILL NOT BE PLOTTED.
!            --VALUES IN THE VERTICAL AXIS VECTOR (Y),
!              THE HORIZONTAL AXIS VECTOR (X),
!              OR THE PLOT CHARACTER VECTOR (CHAR) WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR Y
!              (OR X, OR CHAR) ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR Y
!              (OR X, OR CHAR) FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN Y (OR X, OR CHAR) TO BE
!              PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN Y (OR X, OR CHAR) TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOTC
!              SUBROUTINE.
!     REFERENCES--FILLIBEN, 'STATISTICAL ANALYSIS OF INTERLAB
!                 FATIGUE TIME DATA', UNPUBLISHED MANUSCRIPT
!                 (AVAILABLE FROM AUTHOR)
!                 PRESENTED AT THE 'COMPUTER-ASSISTED DATA
!                 ANALYSIS' SESSION AT THE NATIONAL MEETING
!                 OF THE AMERICAN STATISTICAL ASSOCIATION,
!                 NEW YORK CITY, DECEMBER 27-30, 1973.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 iline
      CHARACTER*4 iaxisc
      CHARACTER*4 iplotc
      CHARACTER*4 jplotc
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22 , alph31 , alph32
      CHARACTER*4 alph41 , alph42 , alph51 , alph52
      CHARACTER*4 blank , hyphen , alphai
!
      DIMENSION Y(1)
      DIMENSION X(1)
      DIMENSION Char(1)
      DIMENSION D(1)
      DIMENSION iline(72) , xlable(10)
      DIMENSION iplotc(37)
!
      DATA sbnam1 , sbnam2/'PLTS' , 'CT  '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA alph31 , alph32/'THIR' , 'D   '/
      DATA alph41 , alph42/'FOUR' , 'TH  '/
      DATA alph51 , alph52/'FIFT' , 'H   '/
      DATA blank , hyphen , alphai/' ' , '-' , 'I'/
      DATA iplotc(1) , iplotc(2) , iplotc(3) , iplotc(4) , iplotc(5) ,  &
     &     iplotc(6) , iplotc(7) , iplotc(8) , iplotc(9) , iplotc(10) , &
     &     iplotc(11) , iplotc(12) , iplotc(13) , iplotc(14) ,          &
     &     iplotc(15) , iplotc(16) , iplotc(17) , iplotc(18) ,          &
     &     iplotc(19) , iplotc(20) , iplotc(21) , iplotc(22) ,          &
     &     iplotc(23) , iplotc(24) , iplotc(25) , iplotc(26) ,          &
     &     iplotc(27) , iplotc(28) , iplotc(29) , iplotc(30) ,          &
     &     iplotc(31) , iplotc(32) , iplotc(33) , iplotc(34) ,          &
     &     iplotc(35) , iplotc(36) , iplotc(37)/'1' , '2' , '3' , '4' , &
     &     '5' , '6' , '7' , '8' , '9' , '0' , 'A' , 'B' , 'C' , 'D' ,  &
     &     'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' ,  &
     &     'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' ,  &
     &     'Y' , 'Z' , 'X'/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99014)
         WRITE (ipr,99015)
         WRITE (ipr,99017) alph41 , alph42 , sbnam1 , sbnam2
         WRITE (ipr,99001) N
99001    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99014)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99014)
            WRITE (ipr,99015)
            WRITE (ipr,99017) alph41 , alph42 , sbnam1 , sbnam2
            WRITE (ipr,99002) N
99002       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99014)
            RETURN
         ELSE
!
            hold = Y(1)
            DO i = 2 , N
               IF ( Y(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99014)
            WRITE (ipr,99015)
            WRITE (ipr,99017) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99018) hold
            WRITE (ipr,99014)
            RETURN
         ENDIF
 50      hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99014)
         WRITE (ipr,99015)
         WRITE (ipr,99017) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99018) hold
         WRITE (ipr,99014)
         RETURN
      ENDIF
 100  hold = Char(1)
      DO i = 2 , N
         IF ( Char(i)/=hold ) GOTO 200
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99016)
      WRITE (ipr,99017) alph31 , alph32 , sbnam1 , sbnam2
      WRITE (ipr,99018) hold
      WRITE (ipr,99014)
 200  hold = D(1)
      DO i = 2 , N
         IF ( D(i)/=hold ) GOTO 300
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99016)
      WRITE (ipr,99017) alph51 , alph52 , sbnam1 , sbnam2
      WRITE (ipr,99018) hold
      WRITE (ipr,99014)
!
 300  DO i = 1 , N
         IF ( Y(i)<cutoff ) GOTO 400
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99017) alph11 , alph12 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99014)
      RETURN
 400  DO i = 1 , N
         IF ( X(i)<cutoff ) GOTO 500
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99017) alph21 , alph22 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99014)
      RETURN
 500  DO i = 1 , N
         IF ( Char(i)<cutoff ) GOTO 600
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99017) alph31 , alph32 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99014)
      RETURN
 600  DO i = 1 , N
         IF ( D(i)<cutoff ) GOTO 700
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99017) alph51 , alph52 , sbnam1 , sbnam2
      WRITE (ipr,99019)
      WRITE (ipr,99020) cutoff
      WRITE (ipr,99014)
      RETURN
!
 700  DO i = 1 , N
         IF ( Dmin<D(i) .AND. D(i)<Dmax ) GOTO 800
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99017) alph51 , alph52 , sbnam1 , sbnam2
      WRITE (ipr,99003)
99003 FORMAT (' ','HAS ALL ELEMENTS OUTSIDE THE INTERVAL')
      WRITE (ipr,99004) Dmin , Dmax
99004 FORMAT (' ','(',E15.8,',',E15.8,')',' AS DEFINED BY')
      WRITE (ipr,99005)
99005 FORMAT (' ','THE SIXTH  AND SEVENTH INPUT ARGUMENTS.')
      WRITE (ipr,99014)
      RETURN
!
 800  n2 = 0
      DO i = 1 , N
         IF ( Y(i)<cutoff .AND. X(i)<cutoff .AND. Char(i)<cutoff .AND.  &
     &        D(i)<cutoff ) THEN
            IF ( Dmin<D(i) .AND. D(i)<Dmax ) n2 = n2 + 1
            IF ( n2>=2 ) GOTO 900
         ENDIF
      ENDDO
      WRITE (ipr,99014)
      WRITE (ipr,99015)
      WRITE (ipr,99006) alph11 , alph12 , alph21 , alph22 , alph31 ,    &
     &                  alph32 , alph51 , alph52
99006 FORMAT (' ','THE ',A4,A4,', ',A4,A4,', ',A4,A4,', AND ',A4,A4)
      WRITE (ipr,99007) sbnam1 , sbnam2
99007 FORMAT (' ','INPUT ARGUMENTS TO THE ',A4,A4,' SUBROUTINE')
      WRITE (ipr,99008)
99008 FORMAT (' ','ARE SUCH THAT TOO MANY POINTS HAVE BEEN',            &
     &        ' EXCLUDED FROM THE PLOT.')
      WRITE (ipr,99009) n2
99009 FORMAT (' ','ONLY ',I3,' POINTS ARE LEFT TO BE PLOTTED.')
      WRITE (ipr,99014)
      RETURN
!
!-----START POINT-----------------------------------------------------
!
!     DEFINE THE NUMBER OF ROWS AND COLUMNS WITHIN THE PLOT--THIS HAS
!     BEEN SET TO 25 ROWS AND 49 COLUMNS.
!
 900  numrow = 25
      numcol = 49
      anumr = numrow
      anumrm = numrow - 1
      anumcm = numcol - 1
      numr25 = (numrow/4) + 1
      numr50 = (numrow/2) + 1
      numr75 = 3*(numrow/4) + 1
      ixdel = (numcol-1)/4
      numlab = 5
      anumlm = numlab - 1
!
!     SKIP A LINE, WRITE OUT AN IDENTIFYING LINE FOR THE TYPE OF PLOT,
!     WRITE OUT THE TOP HORIZONTAL AXIS OF THE PLOT, AND SKIP 1 LINE
!     FOR A MARGIN WITHIN THE PLOT.
!
      WRITE (ipr,99010)
99010 FORMAT (' ')
      WRITE (ipr,99011)
!
99011 FORMAT (' ','THE FOLLOWING IS A PLOT OF Y(I) VERSUS X(I)')
      DO icol = 1 , numcol
         iline(icol) = hyphen
      ENDDO
      DO icol = 1 , numcol , ixdel
         iline(icol) = alphai
      ENDDO
      WRITE (ipr,99021) (iline(i),i=1,numcol)
      WRITE (ipr,99022) blank
!
!     DETERMINE THE MIN AND MAX VALUES OF Y, AND OF X.
!
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  IF ( D(i)>=Dmin ) THEN
                     IF ( D(i)<=Dmax ) THEN
                        ymin = Y(i)
                        ymax = Y(i)
                        xmin = X(i)
                        xmax = X(i)
                        EXIT
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      DO i = 1 , N
         IF ( Y(i)<cutoff ) THEN
            IF ( X(i)<cutoff ) THEN
               IF ( Char(i)<cutoff ) THEN
                  IF ( D(i)>=Dmin ) THEN
                     IF ( D(i)<=Dmax ) THEN
                        IF ( Y(i)<ymin ) ymin = Y(i)
                        IF ( Y(i)>ymax ) ymax = Y(i)
                        IF ( X(i)<xmin ) xmin = X(i)
                        IF ( X(i)>xmax ) xmax = X(i)
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      dely = ymax - ymin
      delx = xmax - xmin
      ywidth = dely/anumrm
      xwidth = delx/anumcm
!
!     DETERMINE AND WRITE OUT THE PLOT POSITIONS ONE LINE AT A TIME.
!     ALSO DETERMINE THE APPROPRIATE PLOT CHARACTERS.
!
      DO irow = 1 , numrow
         DO icol = 1 , numcol
            iline(icol) = blank
         ENDDO
         airow = irow
         yupper = ymax + (1.5-airow)*ywidth
         ylable = ymax + (1.0-airow)*ywidth
         ylower = ymax + (0.5-airow)*ywidth
         IF ( irow==numrow ) ylable = ymin
         DO i = 1 , N
            IF ( Y(i)<cutoff ) THEN
               IF ( X(i)<cutoff ) THEN
                  IF ( Char(i)<cutoff ) THEN
                     IF ( D(i)>=Dmin ) THEN
                        IF ( D(i)<=Dmax ) THEN
                           IF ( ylower<=Y(i) .AND. Y(i)<yupper ) THEN
                              icol = ((X(i)-xmin)/xwidth) + 1.5
                              ia = Char(i) + 0.5
                              IF ( 1<=ia .AND. ia<=36 ) THEN
                                 jplotc = iplotc(ia)
                              ELSE
                                 jplotc = iplotc(37)
                              ENDIF
                              iline(icol) = jplotc
                           ENDIF
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDDO
         icolmx = 1
         DO icol = 1 , numcol
            IF ( iline(icol)/=blank ) icolmx = icol
         ENDDO
         iaxisc = alphai
         IF ( irow==1 .OR. irow==numrow ) iaxisc = hyphen
         IF ( irow==numr25 .OR. irow==numr50 .OR. irow==numr75 )        &
     &        iaxisc = hyphen
         WRITE (ipr,99012) ylable , iaxisc , (iline(icol),icol=1,icolmx)
99012    FORMAT (' ',E14.7,1X,A1,2X,50A1)
      ENDDO
!
!     SKIP 1 LINE FOR A BOTTOM MARGIN WITHIN THE PLOT, WRITE OUT THE
!     BOTTOM HORIZONTAL AXIS, AND WRITE OUT THE X AXIS LABLES.
!
      WRITE (ipr,99022) blank
      DO icol = 1 , numcol
         iline(icol) = hyphen
      ENDDO
      DO icol = 1 , numcol , ixdel
         iline(icol) = alphai
      ENDDO
      WRITE (ipr,99021) (iline(icol),icol=1,numcol)
      DO i = 1 , numlab
         aim1 = i - 1
         xlable(i) = xmin + (aim1/anumlm)*delx
      ENDDO
      WRITE (ipr,99013) (xlable(i),i=1,numlab)
99013 FORMAT (' ',9X,5E12.4)
!
99014 FORMAT (' ','**************************************************', &
     &        '********************')
99015 FORMAT (' ','                   FATAL ERROR                    ')
99016 FORMAT (' ','               NON-FATAL DIAGNOSTIC               ')
99017 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
99018 FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
99019 FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
99020 FORMAT (' ','VALUE OF ',E15.8)
99021 FORMAT (' ',18X,54A1)
99022 FORMAT (' ',15X,A1)
!
      END SUBROUTINE PLTSCT
!*==pltxxt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PLTXXT(X,N)
      IMPLICIT NONE
!*--PLTXXT22621
!*** Start of declarations inserted by SPAG
      REAL aim1 , airow , anumcm , anumlm , anumr , anumrm , cutoff ,   &
     &     delx , hold , X , x2labl , xcwidt , xlable , xlower , xmax , &
     &     xmin , xrwidt , xupper
      INTEGER i , icol , icolmx , im1 , ipr , irow , ixdel , N ,        &
     &        numcol , numlab , numr25 , numr50 , numr75 , numrow
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PLTXXT
!
!     PURPOSE--THIS SUBROUTINE YIELDS A NARROW-WIDTH (71-CHARACTER)
!              PLOT OF X(I) VERSUS X(I-1).  ITS NARROW WIDTH MAKES IT
!              APPROPRIATE FOR USE ON A TERMINAL.
!              THIS TYPE OF PLOT (WHICH IS CALLED AN
!              AUTOCORRELATION PLOT OR A LAG 1 PLOT)
!              IS USEFUL IN EXAMINING FOR
!              AUTOCORRELATION IN A SEQUENCE OF OBSERVATIONS.
!              UNCORRELATED DATA WILL PRODUCE AN AUTOCORRELATION
!              PLOT WITH NO APPARENT STRUCTURE; AUTOCORRELATED
!              DATA WILL PRODUCE AN AUTOCORRELATION PLOT WITH
!              LINEAR, ELLIPTICAL, OR OTHER KINDS OF STRUCTURE.
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED) OBSERVATIONS
!                               TO BE GRAPHICALLY TESTED FOR
!                               AUTOCORRELATION.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--A NARROW-WIDTH (71-CHARACTER) TERMINAL PLOT
!             OF X(I) VERSUS X(I-1).
!             THE BODY OF THE PLOT (NOT COUNTING AXIS VALUES
!             AND MARGINS) IS 25 ROWS (LINES) AND 49 COLUMNS.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--VALUES IN THE VERTICAL AXIS VECTOR (X) WHICH ARE
!              EQUAL TO OR IN EXCESS OF 10.0**10 WILL NOT BE
!              PLOTTED.
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VECTOR X
!              ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THE VECTOR X
!              FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS IN X TO BE PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN X TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY, FOR EXAMPLE, USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLTXXT
!              SUBROUTINE.
!            --NOTE THAT THE STORAGE REQUIREMENTS FOR THIS
!              (AND THE OTHER) TERMINAL PLOT SUBROUTINESS ARE .
!              VERY SMALL.
!              THIS IS DUE TO THE 'ONE LINE AT A TIME' ALGORITHM
!              EMPLOYED FOR THE PLOT.
!     REFERENCES--FILLIBEN, 'SOME USEFUL PROCEDURES FOR THE
!                 STATISTICAL ANALYSIS OF DATA', UNPUBLISHED
!                 MANUSCRIPT (AVAILABLE FROM AUTHOR)
!                 PRESENTED AT THE FALL CONFERENCE
!                 OF THE CHEMICAL DIVISION OF THE AMERICAN
!                 SOCIETY FOR QUALITY CONTROL, KNOXVILLE,
!                 TENNESSEE, OCTOBER 19-20, 1972.
!               --FILLIBEN, 'DATA EXPLORATION USING STAND-ALONE
!                 SUBROUTINES', UNPUBLISHED MANUSCRIPT
!                 (AVAILABLE FROM AUTHOR)
!                 PRESENTED AT THE 'STRATEGY FOR DATA ANALYSIS
!                 BY COMPUTERS' SESSION AT THE NATIONAL
!                 MEETING OF THE AMERICAN STATISTICAL ASSOCIATION,
!                 ST. LOUIS, MISSOURI, AUGUST 26-29, 1974.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--FEBRUARY  1974.
!     UPDATED         --APRIL     1974.
!     UPDATED         --OCTOBER   1974.
!     UPDATED         --OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1977.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 iline
      CHARACTER*4 iaxisc
      CHARACTER*4 sbnam1 , sbnam2
      CHARACTER*4 alph11 , alph12 , alph21 , alph22
      CHARACTER*4 blank , hyphen , alphai , alphax
!
      DIMENSION X(1)
      DIMENSION iline(72) , x2labl(10)
!
      DATA sbnam1 , sbnam2/'PLTX' , 'XT  '/
      DATA alph11 , alph12/'FIRS' , 'T   '/
      DATA alph21 , alph22/'SECO' , 'ND  '/
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
!
      ipr = 6
      cutoff = (10.0**10) - 1000.0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99010)
         WRITE (ipr,99011)
         WRITE (ipr,99012) alph21 , alph22 , sbnam1 , sbnam2
         WRITE (ipr,99001) N
99001    FORMAT (' ','IS NON-NEGATIVE (WITH VALUE = ',I8,')')
         WRITE (ipr,99010)
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99010)
            WRITE (ipr,99011)
            WRITE (ipr,99012) alph21 , alph22 , sbnam1 , sbnam2
            WRITE (ipr,99002) N
99002       FORMAT (' ','HAS THE VALUE 1')
            WRITE (ipr,99010)
            RETURN
         ELSE
!
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99010)
            WRITE (ipr,99011)
            WRITE (ipr,99012) alph11 , alph12 , sbnam1 , sbnam2
            WRITE (ipr,99003) hold
99003       FORMAT (' ','HAS ALL ELEMENTS = ',E15.8)
            WRITE (ipr,99010)
            RETURN
         ENDIF
!
 50      DO i = 1 , N
            IF ( X(i)<cutoff ) GOTO 100
         ENDDO
         WRITE (ipr,99010)
         WRITE (ipr,99011)
         WRITE (ipr,99012) alph11 , alph12 , sbnam1 , sbnam2
         WRITE (ipr,99004)
99004    FORMAT (' ','HAS ALL ELEMENTS IN EXCESS OF THE CUTOFF')
         WRITE (ipr,99005) cutoff
99005    FORMAT (' ','VALUE OF ',E15.8)
         WRITE (ipr,99010)
         RETURN
      ENDIF
!
!-----START POINT-----------------------------------------------------
!
!     DEFINE THE NUMBER OF ROWS AND COLUMNS WITHIN THE PLOT--
!     THIS HAS BEEN SET TO 25 ROWS AND 49 COLUMNS.
!
 100  numrow = 25
      numcol = 49
      anumr = numrow
      anumrm = numrow - 1
      anumcm = numcol - 1
      numr25 = (numrow/4) + 1
      numr50 = (numrow/2) + 1
      numr75 = 3*(numrow/4) + 1
      ixdel = (numcol-1)/4
      numlab = 5
      anumlm = numlab - 1
!
!     WRITE OUT THE TOP HORIZONTAL AXIS OF THE PLOT, AND SKIP 1 LINE
!     FOR A MARGIN WITHIN THE PLOT.
!
      WRITE (ipr,99006)
99006 FORMAT (' ')
      WRITE (ipr,99007)
!
99007 FORMAT (' ',                                                      &
     &'THE FOLLOWING IS A PLOT OF X(I) (VERTICALLY) VS. ,  21HX(I-1) (HO&
     &RIZONTALLY)')
      DO icol = 1 , numcol
         iline(icol) = hyphen
      ENDDO
      DO icol = 1 , numcol , ixdel
         iline(icol) = alphai
      ENDDO
      WRITE (ipr,99013) (iline(i),i=1,numcol)
      WRITE (ipr,99014) blank
!
!     DETERMINE THE MIN AND MAX VALUES OF X.
!
      xmin = X(1)
      xmax = X(1)
      DO i = 1 , N
         IF ( X(i)<cutoff ) THEN
            IF ( X(i)<xmin ) xmin = X(i)
            IF ( X(i)>xmax ) xmax = X(i)
         ENDIF
      ENDDO
      delx = xmax - xmin
      xrwidt = delx/anumrm
      xcwidt = delx/anumcm
!
!     DETERMINE AND WRITE OUT THE PLOT POSITIONS ONE LINE AT A TIME.
!
      DO irow = 1 , numrow
         DO icol = 1 , numcol
            iline(icol) = blank
         ENDDO
         airow = irow
         xupper = xmax + (1.5-airow)*xrwidt
         xlable = xmax + (1.0-airow)*xrwidt
         xlower = xmax + (0.5-airow)*xrwidt
         IF ( irow==numrow ) xlable = xmin
         DO i = 2 , N
            im1 = i - 1
            IF ( X(im1)<cutoff ) THEN
               IF ( X(i)<cutoff ) THEN
                  IF ( xlower<=X(i) .AND. X(i)<xupper ) THEN
                     icol = ((X(im1)-xmin)/xcwidt) + 1.5
                     iline(icol) = alphax
                  ENDIF
               ENDIF
            ENDIF
         ENDDO
         icolmx = 1
         DO icol = 1 , numcol
            IF ( iline(icol)==alphax ) icolmx = icol
         ENDDO
         iaxisc = alphai
         IF ( irow==1 .OR. irow==numrow ) iaxisc = hyphen
         IF ( irow==numr25 .OR. irow==numr50 .OR. irow==numr75 )        &
     &        iaxisc = hyphen
         WRITE (ipr,99008) xlable , iaxisc , (iline(icol),icol=1,icolmx)
99008    FORMAT (' ',E14.7,1X,A1,2X,50A1)
      ENDDO
!
!     SKIP 1 LINE FOR A BOTTOM MARGIN WITHIN THE PLOT, WRITE OUT THE
!     BOTTOM HORIZONTAL AXIS, AND WRITE OUT THE X AXIS LABLES.
!
      WRITE (ipr,99014) blank
      DO icol = 1 , numcol
         iline(icol) = hyphen
      ENDDO
      DO icol = 1 , numcol , ixdel
         iline(icol) = alphai
      ENDDO
      WRITE (ipr,99013) (iline(icol),icol=1,numcol)
      DO i = 1 , numlab
         aim1 = i - 1
         x2labl(i) = xmin + (aim1/anumlm)*delx
      ENDDO
      WRITE (ipr,99009) (x2labl(i),i=1,numlab)
99009 FORMAT (' ',9X,5E12.4)
!
99010 FORMAT (' ','**************************************************', &
     &        '********************')
99011 FORMAT (' ','                   FATAL ERROR                    ')
99012 FORMAT (' ','THE ',A4,A4,' INPUT ARGUMENT TO THE ',A4,A4,         &
     &        ' SUBROUTINE')
99013 FORMAT (' ',18X,54A1)
99014 FORMAT (' ',15X,A1)
!
      END SUBROUTINE PLTXXT
!*==poicdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE POICDF(X,Alamba,Cdf)
      IMPLICIT NONE
!*--POICDF22887
!*** Start of declarations inserted by SPAG
      REAL Alamba , Cdf , del , fintx , gcdf , spchi , X
      INTEGER i , ievodd , imax , imin , intx , ipr , nu
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT POICDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE AT THE SINGLE PRECISION VALUE X
!              FOR THE POISSON DISTRIBUTION
!              WITH SINGLE PRECISION
!              TAIL LENGTH PARAMETER = ALAMBA.
!              THE POISSON DISTRIBUTION USED
!              HEREIN HAS MEAN = ALAMBA
!              AND STANDARD DEVIATION = SQRT(ALAMBA).
!              THIS DISTRIBUTION IS DEFINED FOR
!              ALL DISCRETE NON-NEGATIVE INTEGER  X--X = 0, 1, 2, ... .
!              THIS DISTRIBUTION HAS THE PROBABILITY FUNCTION
!              F(X) = EXP(-ALAMBA) * ALAMBA**X / X!.
!              THE POISSON DISTRIBUTION IS THE
!              DISTRIBUTION OF THE NUMBER OF EVENTS
!              IN THE INTERVAL (0,ALAMBA) WHEN
!              THE WAITING TIME BETWEEN EVENTS
!              IS EXPONENTIALLY DISTRIBUTED
!              WITH MEAN = 1 AND STANDARD DEVIATION = 1.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE
!                                AT WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!                                X SHOULD BE NON-NEGATIVE AND
!                                INTEGRAL-VALUED.
!                     --ALAMBA = THE SINGLE PRECISION VALUE
!                                OF THE TAIL LENGTH PARAMETER.
!                                ALAMBA SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF
!             FOR THE POISSON DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER = ALAMBA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--X SHOULD BE NON-NEGATIVE AND INTEGRAL-VALUED.
!                 --ALAMBA SHOULD BE POSITIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NORCDF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--DSQRT, DATAN.
!     MODE OF INTERNAL OPERATIONS--DOUBLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--THE SINGLE PRECISION TAIL LENGTH
!              PARAMETER ALAMBA IS     NOT     RESTRICTED
!              TO ONLY INTEGER VALUES.
!              ALAMBA CAN BE SET TO ANY POSITIVE REAL
!              VALUE--INTEGER OR NON-INTEGER.
!            --NOTE THAT EVEN THOUGH THE INPUT
!              TO THIS CUMULATIVE
!              DISTRIBUTION FUNCTION SUBROUTINE
!              FOR THIS DISCRETE DISTRIBUTION
!              SHOULD (UNDER NORMAL CIRCUMSTANCES) BE A
!              DISCRETE INTEGER VALUE,
!              THE INPUT VARIABLE X IS SINGLE
!              PRECISION IN MODE.
!              X HAS BEEN SPECIFIED AS SINGLE
!              PRECISION SO AS TO CONFORM WITH THE DATAPAC
!              CONVENTION THAT ALL INPUT ****DATA****
!              (AS OPPOSED TO SAMPLE SIZE, FOR EXAMPLE)
!              VARIABLES TO ALL
!              DATAPAC SUBROUTINES ARE SINGLE PRECISION.
!              THIS CONVENTION IS BASED ON THE BELIEF THAT
!              1) A MIXTURE OF MODES (FLOATING POINT
!              VERSUS INTEGER) IS INCONSISTENT AND
!              AN UNNECESSARY COMPLICATION
!              IN A DATA ANALYSIS; AND
!              2) FLOATING POINT MACHINE ARITHMETIC
!              (AS OPPOSED TO INTEGER ARITHMETIC)
!              IS THE MORE NATURAL MODE FOR DOING
!              DATA ANALYSIS.
!     REFERENCES--JOHNSON AND KOTZ, DISCRETE
!                 DISTRIBUTIONS, 1969, PAGES 87-121,
!                 ESPECIALLY PAGE 114, FORMULA 93.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGE 112.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 941, FORMULAE 26.4.4 AND 26.4.5,
!                 AND PAGE 929.
!               --FELLER, AN INTRODUCTION TO PROBABILITY
!                 THEORY AND ITS APPLICATIONS, VOLUME 1,
!                 EDITION 2, 1957, PAGES 146-154.
!               --COX AND MILLER, THE THEORY OF STOCHASTIC
!                 PROCESSES, 1965, PAGE 7.
!               --GENERAL ELECTRIC COMPANY, TABLES OF THE
!                 INDIVIDUAL AND CUMULATIVE TERMS OF POISSON
!                 DISTRIBUTION, 1962.
!               --OWEN, HANDBOOK OF STATISTICAL
!                 TABLES, 1962, PAGES 259-261.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DOUBLE PRECISION dx , pi , chi , sum , term , ai , dgcdf
      DOUBLE PRECISION DSQRT , DEXP
      DATA pi/3.14159265358979D0/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( Alamba<=0.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE POICDF SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99005) Alamba
         Cdf = 0.0
         RETURN
      ELSEIF ( X<0.0 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE POIC&
     &DF SUBROUTINE IS NEGATIVE *****')
         WRITE (ipr,99005) X
         Cdf = 0.0
         RETURN
      ELSE
         intx = X + 0.0001
         fintx = intx
         del = X - fintx
         IF ( del<0.0 ) del = -del
         IF ( del>0.001 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE POIC&
     &DF SUBROUTINE IS NON-INTEGRAL *****')
            WRITE (ipr,99005) X
99004       FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,       &
     &              ' *****')
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
!     EXPRESS THE POISSON CUMULATIVE DISTRIBUTION
!     FUNCTION IN TERMS OF THE EQUIVALENT CHI-SQUARED
!     CUMULATIVE DISTRIBUTION FUNCTION,
!     AND THEN EVALUATE THE LATTER.
!
         dx = Alamba
         dx = 2.0D0*dx
         nu = X + 0.0001
         nu = 2*(1+nu)
!
         chi = DSQRT(dx)
         ievodd = nu - 2*(nu/2)
         IF ( ievodd==0 ) THEN
!
            sum = 1.0D0
            term = 1.0D0
            imin = 2
            imax = nu - 2
         ELSE
!
            sum = 0.0D0
            term = 1.0/chi
            imin = 1
            imax = nu - 1
         ENDIF
!
         IF ( imin<=imax ) THEN
            DO i = imin , imax , 2
               ai = i
               term = term*(dx/ai)
               sum = sum + term
            ENDDO
         ENDIF
!
         sum = sum*DEXP(-dx/2.0D0)
         IF ( ievodd/=0 ) THEN
            sum = (DSQRT(2.0D0/pi))*sum
            spchi = chi
            CALL NORCDF(spchi,gcdf)
            dgcdf = gcdf
            sum = sum + 2.0D0*(1.0D0-dgcdf)
         ENDIF
         Cdf = sum
      ENDIF
99005 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
      END SUBROUTINE POICDF
!*==poiplt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE POIPLT(X,N,Alamba)
      IMPLICIT NONE
!*--POIPLT23082
!*** Start of declarations inserted by SPAG
      REAL Alamba , an , arg1 , cc , cdf , cutoff , hold , sqalam ,     &
     &     sum1 , sum2 , sum3 , W , wbar , WS , X , Y , ybar , yint ,   &
     &     yslope , Z
      INTEGER i , iarg2 , ilamba , imax , ipr , irev , iupper , j ,     &
     &        jm1 , k , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT POIPLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES A POISSON
!              PROBABILITY PLOT
!              (WITH SINGLE PRECISION
!              TAIL LENGTH PARAMETER = ALAMBA).
!              THE PROTOTYPE POISSON DISTRIBUTION USED
!              HEREIN HAS MEAN = ALAMBA
!              AND STANDARD DEVIATION = SQRT(ALAMBA).
!              THIS DISTRIBUTION IS DEFINED FOR
!              ALL DISCRETE NON-NEGATIVE INTEGER  X--X = 0, 1, 2, ... .
!              THIS DISTRIBUTION HAS THE PROBABILITY FUNCTION
!              F(X) = EXP(-ALAMBA) * ALAMBA**X / X!.
!              THE POISSON DISTRIBUTION IS THE
!              DISTRIBUTION OF THE NUMBER OF EVENTS
!              IN THE INTERVAL (0,ALAMBA) WHEN
!              THE WAITING TIME BETWEEN EVENTS
!              IS EXPONENTIALLY DISTRIBUTED
!              WITH MEAN = 1 AND STANDARD DEVIATION = 1.
!              THE PROTOTYPE DISTRIBUTION RESTRICTIONS OF
!              DISCRETENESS AND NON-NEGATIVENESS
!              MENTIONED ABOVE DO NOT CARRY OVER TO THE
!              INPUT VECTOR X OF OBSERVATIONS TO BE ANALYZED.
!              THE INPUT OBSERVATIONS IN X MAY BE DISCRETE, CONTINUOUS,
!              NON-NEGATIVE, OR NEGATIVE.
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE POISSON PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE POISSON DISTRIBUTION
!              WITH TAIL LENGTH PARAMETER VALUE = ALAMBA.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --ALAMBA = THE SINGLE PRECISION VALUE OF THE
!                                TAIL LENGTH PARAMETER.
!                                ALAMBA SHOULD BE POSITIVE.
!     OUTPUT--A ONE-PAGE POISSON PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 5000.
!                 --ALAMBA SHOULD BE POSITIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, PLOT,
!                                         CHSCDF, NORPPF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--FOR LARGE VALUES OF ALAMBA (IN EXCESS OF 500.)
!              THIS SUBROUTINE USES THE NORMAL APPROXIMATION TO
!              THE POISSON.  THIS IS DONE TO SAVE EXECUTION TIME
!              WHICH INCREASES AS A FUNCTION OF ALAMBA AND WOULD
!              BE EXCESSIVE FOR LARGE VALUES OF ALAMBA.
!     REFERENCES--FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --JOHNSON AND KOTZ, DISCRETE
!                 DISTRIBUTIONS, 1969, PAGES 87-121.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1974.
!     UPDATED         --AUGUST    1975.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(5000) , W(5000)
      DIMENSION Z(5000)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(5001))
      EQUIVALENCE (Z(1),WS(10001))
!
      ipr = 6
      iupper = 5000
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE POIPLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE POIP&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         IF ( Alamba<=0.0 ) THEN
            WRITE (ipr,99004)
99004       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE POIPLT SUBROU&
     &TINE IS NON-POSITIVE *****')
            WRITE (ipr,99005) Alamba
99005       FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,    &
     &              ' *****')
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99006) hold
99006       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE POIPLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
         cutoff = 500.0
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     COMPUTE POISSON ORDER STATISTIC MEDIANS.
!     IF THE INPUT ALAMBA VALUE IS LARGE (IN EXCESS OF
!     CUTOFF VALUE OF 500.0), THEN USE THE NORMAL APPROXIMATION
!     TO THE POISSON.
!
         IF ( Alamba<=cutoff ) THEN
!
!     DETERMINE WHICH UNIFORM ORDER STATISTIC MEDIAN IS ASSOCIATED WITH
!     THE CLOSEST INTEGER TO ALAMBA.
!
            DO i = 1 , N
               Z(i) = -1.0
            ENDDO
!
            ilamba = Alamba + 0.5
            arg1 = 2.0*Alamba
            iarg2 = 2*(ilamba+1)
            CALL CHSCDF(arg1,iarg2,cdf)
            cdf = 1.0 - cdf
            DO j = 1 , N
               IF ( W(j)>cdf ) EXIT
            ENDDO
            jm1 = j - 1
            Z(jm1) = ilamba
!
!     FILL IN THE POISSON ORDER STATISTIC MEDIANS BELOW ALAMBA
!
            imax = 6.0*SQRT(Alamba)
            DO i = 1 , imax
               k = ilamba - i
               IF ( k<0 ) EXIT
               iarg2 = 2*(k+1)
               CALL CHSCDF(arg1,iarg2,cdf)
               cdf = 1.0 - cdf
               DO j = 1 , N
                  IF ( W(j)>cdf ) EXIT
               ENDDO
               jm1 = j - 1
               IF ( jm1<=0 ) EXIT
               IF ( Z(jm1)<-0.5 ) Z(jm1) = k
            ENDDO
!
!     FILL IN THE POISSON ORDER STATISTIC MEDIANS ABOVE ALAMBA
!
            DO i = 1 , imax
               k = ilamba + i
               iarg2 = 2*(k+1)
               CALL CHSCDF(arg1,iarg2,cdf)
               cdf = 1.0 - cdf
               DO j = 1 , N
                  IF ( W(j)>cdf ) GOTO 60
               ENDDO
               Z(N) = k
               EXIT
 60            jm1 = j - 1
               IF ( Z(jm1)<-0.5 ) Z(jm1) = k
            ENDDO
!
!     FILL IN THE EMPTY HOLES IN THE POISSON ORDER STATISTIC MEDIAN
!     Z MATRIX WITH THE PROPER VALUES.
!     THEN FOR SAKE OF CONSISTENCY WITH OTHER DATAPAC
!     PROBABILITY PLOT SUBROUTINES, COPY THE Z VECTOR
!     INTO THE W VECTOR.
!
            hold = Z(N)
            DO irev = 1 , N
               i = N - irev + 1
               IF ( Z(i)>=-0.5 ) hold = Z(i)
               IF ( Z(i)<-0.5 ) Z(i) = hold
            ENDDO
            DO i = 1 , N
               W(i) = Z(i)
            ENDDO
         ELSE
            sqalam = SQRT(Alamba)
            DO i = 1 , N
               CALL NORPPF(W(i),W(i))
               W(i) = Alamba + W(i)*sqalam
            ENDDO
         ENDIF
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     WRITE OUT THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         WRITE (ipr,99007) Alamba , N
!
99007    FORMAT (' ','POISSON PROBABILITY PLOT WITH PARAMETER = ',9X,   &
     &           E17.10,1X,8X,11X,'THE SAMPLE SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         sum2 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
            sum2 = sum2 + W(i)
         ENDDO
         ybar = sum1/an
         wbar = sum2/an
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + (Y(i)-ybar)*(W(i)-wbar)
            sum3 = sum3 + (W(i)-wbar)*(W(i)-wbar)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99008) cc , yint , yslope
99008    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
!
      END SUBROUTINE POIPLT
!*==poippf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE POIPPF(P,Alamba,Ppf)
      IMPLICIT NONE
!*--POIPPF23360
!*** Start of declarations inserted by SPAG
      REAL Alamba , amean , P , p0 , p1 , p2 , pf0 , Ppf , sd , x0 ,    &
     &     x1 , x2 , zppf
      INTEGER i , ipr , isd , ix0 , ix0p1 , ix1 , ix2
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT POIPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE AT THE SINGLE PRECISION VALUE P
!              FOR THE POISSON DISTRIBUTION
!              WITH SINGLE PRECISION
!              TAIL LENGTH PARAMETER = ALAMBA.
!              THE POISSON DISTRIBUTION USED
!              HEREIN HAS MEAN = ALAMBA
!              AND STANDARD DEVIATION = SQRT(ALAMBA).
!              THIS DISTRIBUTION IS DEFINED FOR
!              ALL DISCRETE NON-NEGATIVE INTEGER  X--X = 0, 1, 2, ... .
!              THIS DISTRIBUTION HAS THE PROBABILITY FUNCTION
!              F(X) = EXP(-ALAMBA) * ALAMBA**X / X!.
!              THE POISSON DISTRIBUTION IS THE
!              DISTRIBUTION OF THE NUMBER OF EVENTS
!              IN THE INTERVAL (0,ALAMBA) WHEN
!              THE WAITING TIME BETWEEN EVENTS
!              IS EXPONENTIALLY DISTRIBUTED
!              WITH MEAN = 1 AND STANDARD DEVIATION = 1.
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 (INCLUSIVELY)
!                                AND 1.0 (EXCLUSIVELY))
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!                     --ALAMBA = THE SINGLE PRECISION VALUE
!                                OF THE TAIL LENGTH PARAMETER.
!                                ALAMBA SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT  .
!             FUNCTION VALUE PPF
!             FOR THE POISSON DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER = ALAMBA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--ALAMBA SHOULD BE POSITIVE.
!                 --P SHOULD BE BETWEEN 0.0 (INCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NORPPF, POICDF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, DEXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION AND DOUBLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--THE SINGLE PRECISION TAIL LENGTH
!              PARAMETER ALAMBA IS     NOT     RESTRICTED
!              TO ONLY INTEGER VALUES.
!              ALAMBA CAN BE SET TO ANY POSITIVE REAL
!              VALUE--INTEGER OR NON-INTEGER.
!            --NOTE THAT EVEN THOUGH THE OUTPUT
!              FROM THIS DISCRETE DISTRIBUTION
!              PERCENT POINT FUNCTION
!              SUBROUTINE MUST NECESSARILY BE A
!              DISCRETE INTEGER VALUE,
!              THE OUTPUT VARIABLE PPF IS SINGLE
!              PRECISION IN MODE.
!              PPF HAS BEEN SPECIFIED AS SINGLE
!              PRECISION SO AS TO CONFORM WITH THE DATAPAC
!              CONVENTION THAT ALL OUTPUT VARIABLES FROM ALL
!              DATAPAC SUBROUTINES ARE SINGLE PRECISION.
!              THIS CONVENTION IS BASED ON THE BELIEF THAT
!              1) A MIXTURE OF MODES (FLOATING POINT
!              VERSUS INTEGER) IS INCONSISTENT AND
!              AN UNNECESSARY COMPLICATION
!              IN A DATA ANALYSIS; AND
!              2) FLOATING POINT MACHINE ARITHMETIC
!              (AS OPPOSED TO INTEGER ARITHMETIC)
!              IS THE MORE NATURAL MODE FOR DOING
!              DATA ANALYSIS.
!     REFERENCES--JOHNSON AND KOTZ, DISCRETE
!                 DISTRIBUTIONS, 1969, PAGES 87-121,
!                 ESPECIALLY PAGE 102, FORMULA 36.1.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 108-113.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 929.
!               --FELLER, AN INTRODUCTION TO PROBABILITY
!                 THEORY AND ITS APPLICATIONS, VOLUME 1,
!                 EDITION 2, 1957, PAGES 146-154.
!               --COX AND MILLER, THE THEORY OF STOCHASTIC
!                 PROCESSES, 1965, PAGE 7.
!               --GENERAL ELECTRIC COMPANY, TABLES OF THE
!                 INDIVIDUAL AND CUMULATIVE TERMS OF POISSON
!                 DISTRIBUTION, 1962.
!               --OWEN, HANDBOOK OF STATISTICAL
!                 TABLES, 1962, PAGES 259-261.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DOUBLE PRECISION dlamba
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE POIPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99017) P
         Ppf = 0.0
         RETURN
      ELSE
         IF ( Alamba<=0.0 ) THEN
            WRITE (ipr,99002)
99002       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE POIPPF SUBROU&
     &TINE IS NON-POSITIVE *****')
            WRITE (ipr,99017) Alamba
            Ppf = 0.0
            RETURN
         ELSE
!
!-----START POINT-----------------------------------------------------
!
            dlamba = Alamba
            Ppf = 0.0
            ix0 = 0
            ix1 = 0
            ix2 = 0
            p0 = 0.0
            p1 = 0.0
            p2 = 0.0
!
!     TREAT CERTAIN SPECIAL CASES IMMEDIATELY--
!     1) P = 0.0
!     2) PPF = 0
!
            IF ( P/=0.0 ) THEN
               pf0 = DEXP(-dlamba)
               IF ( P>pf0 ) THEN
!
!     DETERMINE AN INITIAL APPROXIMATION TO THE POISSON
!     PERCENT POINT BY USE OF THE NORMAL APPROXIMATION
!     TO THE POISSON.
!     (SEE JOHNSON AND KOTZ, DISCRETE DISTRIBUTIONS,
!     PAGE 102, FORMULA 36.1).
!
                  amean = Alamba
                  sd = SQRT(Alamba)
                  CALL NORPPF(P,zppf)
                  x2 = amean - 1.0 + zppf*sd
                  ix2 = x2
!
!     CHECK AND MODIFY (IF NECESSARY) THIS INITIAL
!     ESTIMATE OF THE PERCENT POINT
!     TO ASSURE THAT IT BE NON-NEGATIVE.
!
                  IF ( ix2<0 ) ix2 = 0
!
!     DETERMINE UPPER AND LOWER BOUNDS ON THE DESIRED
!     PERCENT POINT BY ITERATING OUT (BOTH BELOW AND ABOVE)
!     FROM THE ORIGINAL APPROXIMATION AT STEPS
!     OF 1 STANDARD DEVIATION.
!     THE RESULTING BOUNDS WILL BE AT MOST
!     1 STANDARD DEVIATION APART.
!
                  ix0 = 0
                  ix1 = huge(0) ! = 10**10
                  isd = sd + 1.0
                  x2 = ix2
                  CALL POICDF(x2,Alamba,p2)
!
                  IF ( p2<P ) THEN
!
                     ix0 = ix2
                     DO i = 1 , 100000
                        ix2 = ix0 + isd
                        IF ( ix2>=ix1 ) GOTO 200
                        x2 = ix2
                        CALL POICDF(x2,Alamba,p2)
                        IF ( p2>=P ) GOTO 50
                        ix0 = ix2
                     ENDDO
                     WRITE (ipr,99018)
                     WRITE (ipr,99003)
!
99003                FORMAT (' ',                                       &
     &                     'NO UPPER BOUND FOUND AFTER 10**7 ITERATIONS'&
     &                     )
                  ELSE
!
                     ix1 = ix2
                     DO i = 1 , 100000
                        ix2 = ix1 - isd
                        IF ( ix2<=ix0 ) GOTO 200
                        x2 = ix2
                        CALL POICDF(x2,Alamba,p2)
                        IF ( p2<P ) GOTO 100
                        ix1 = ix2
                     ENDDO
                     WRITE (ipr,99018)
                     WRITE (ipr,99004)
99004                FORMAT (' ',                                       &
     &                     'NO LOWER BOUND FOUND AFTER 10**7 ITERATIONS'&
     &                     )
                  ENDIF
                  GOTO 400
               ENDIF
            ENDIF
            Ppf = 0.0
            RETURN
         ENDIF
 50      ix1 = ix2
         GOTO 200
      ENDIF
 100  ix0 = ix2
!
 200  IF ( ix0==ix1 ) THEN
         IF ( ix0==0 ) THEN
            ix1 = ix1 + 1
            GOTO 300
            ix0 = ix0 - 1
         ELSE
!CCCC IF(IX0.EQ.N)GOTO290
            WRITE (ipr,99018)
            WRITE (ipr,99005)
99005       FORMAT (' ','LOWER AND UPPER BOUND IDENTICAL')
            GOTO 400
         ENDIF
      ENDIF
!
!     COMPUTE POISSON PROBABILITIES FOR THE
!     DERIVED LOWER AND UPPER BOUNDS.
!
 300  x0 = ix0
      x1 = ix1
      CALL POICDF(x0,Alamba,p0)
      CALL POICDF(x1,Alamba,p1)
!
!     CHECK THE PROBABILITIES FOR PROPER ORDERING
!
      IF ( p0<P .AND. P<=p1 ) THEN
         DO
!
!     THE STOPPING CRITERION IS THAT THE LOWER BOUND
!     AND UPPER BOUND ARE EXACTLY 1 UNIT APART.
!     CHECK TO SEE IF IX1 = IX0 + 1;
!     IF SO, THE ITERATIONS ARE COMPLETE;
!     IF NOT, THEN BISECT, COMPUTE PROBABILIIES,
!     CHECK PROBABILITIES, AND CONTINUE ITERATING
!     UNTIL IX1 = IX0 + 1.
!
            ix0p1 = ix0 + 1
            IF ( ix1==ix0p1 ) THEN
               Ppf = ix1
               IF ( p0==P ) Ppf = ix0
               RETURN
            ELSE
               ix2 = (ix0+ix1)/2
               IF ( ix2/=ix0 ) THEN
                  IF ( ix2==ix1 ) THEN
                     WRITE (ipr,99018)
                     WRITE (ipr,99019)
                     EXIT
                  ELSE
                     x2 = ix2
                     CALL POICDF(x2,Alamba,p2)
                     IF ( p0<p2 .AND. p2<p1 ) THEN
                        IF ( p2<=P ) THEN
                           ix0 = ix2
                           p0 = p2
                        ELSE
                           ix1 = ix2
                           p1 = p2
                        ENDIF
                        CYCLE
                     ELSEIF ( p2<=p0 ) THEN
                        WRITE (ipr,99018)
                        WRITE (ipr,99006)
99006                   FORMAT (' ','BISECTION VALUE PROBABILITY (P2) ',&
     &                          'LESS THAN LOWER BOUND PROBABILITY (P0)'&
     &                          )
                        EXIT
                     ELSEIF ( p2>=p1 ) THEN
                        WRITE (ipr,99018)
                        WRITE (ipr,99007)
99007                   FORMAT (' ','BISECTION VALUE PROBABILITY (P2) ',&
     &                       'GREATER THAN UPPER BOUND PROBABILITY (P1)'&
     &                       )
                        EXIT
                     ENDIF
                  ENDIF
               ENDIF
               WRITE (ipr,99018)
               WRITE (ipr,99019)
               EXIT
            ENDIF
         ENDDO
      ELSEIF ( p0==P ) THEN
         Ppf = ix0
         RETURN
      ELSEIF ( p1==P ) THEN
         Ppf = ix1
         RETURN
      ELSEIF ( p0>p1 ) THEN
         WRITE (ipr,99018)
         WRITE (ipr,99008)
99008    FORMAT (' ','LOWER BOUND PROBABILITY (P0) GREATER THAN ',      &
     &           'UPPER BOUND PROBABILITY (P1)')
      ELSEIF ( p0>P ) THEN
         WRITE (ipr,99018)
         WRITE (ipr,99009)
99009    FORMAT (' ','LOWER BOUND PROBABILITY (P0) GREATER THAN ',      &
     &           'INPUT PROBABILITY (P)')
      ELSEIF ( p1<P ) THEN
         WRITE (ipr,99018)
         WRITE (ipr,99010)
99010    FORMAT (' ','UPPER BOUND PROBABILITY (P1) LESS    THAN ',      &
     &           'INPUT PROBABILITY (P)')
      ELSE
         WRITE (ipr,99018)
         WRITE (ipr,99011)
99011    FORMAT (' ','IMPOSSIBLE BRANCH CONDITION ENCOUNTERED')
      ENDIF
!
 400  WRITE (ipr,99012) ix0 , p0
99012 FORMAT (' ','IX0    = ',I8,10X,'P0 = ',F14.7)
      WRITE (ipr,99013) ix1 , p1
99013 FORMAT (' ','IX1    = ',I8,10X,'P1 = ',F14.7)
      WRITE (ipr,99014) ix2 , p2
99014 FORMAT (' ','IX2    = ',I8,10X,'P2 = ',F14.7)
      WRITE (ipr,99015) P
99015 FORMAT (' ','P      = ',F14.7)
      WRITE (ipr,99016) Alamba
99016 FORMAT (' ','ALAMBA = ',F14.7)
      RETURN
99017 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
99018 FORMAT (' ','***** INTERNAL ERROR IN POIPPF SUBROUTINE *****')
99019 FORMAT (' ','BISECTION VALUE (X2) = LOWER BOUND (X0)')
99020 FORMAT (' ','BISECTION VALUE (X2) = UPPER BOUND (X1)')
!
      END SUBROUTINE POIPPF
!*==poiran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE POIRAN(N,Alamba,Iseed,X)
      IMPLICIT NONE
!*--POIRAN23713
!*** Start of declarations inserted by SPAG
      REAL Alamba , e , sum , u(1) , X
      INTEGER i , ipr , Iseed , j , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT POIRAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE POISSON DISTRIBUTION
!              WITH SINGLE PRECISION
!              TAIL LENGTH PARAMETER = ALAMBA.
!              THE POISSON DISTRIBUTION USED
!              HEREIN HAS MEAN = ALAMBA
!              AND STANDARD DEVIATION = SQRT(ALAMBA).
!              THIS DISTRIBUTION IS DEFINED FOR
!              ALL DISCRETE NON-NEGATIVE INTEGER  X--X = 0, 1, 2, ... .
!              THIS DISTRIBUTION HAS THE PROBABILITY FUNCTION
!              F(X) = EXP(-ALAMBA) * ALAMBA**X / X!.
!              THE POISSON DISTRIBUTION IS THE
!              DISTRIBUTION OF THE NUMBER OF EVENTS
!              IN THE INTERVAL (0,ALAMBA) WHEN
!              THE WAITING TIME BETWEEN EVENTS
!              IS EXPONENTIALLY DISTRIBUTED
!              WITH MEAN = 1 AND STANDARD DEVIATION = 1.
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!                     --ALAMBA = THE SINGLE PRECISION VALUE
!                                OF THE TAIL LENGTH PARAMETER.
!                                ALAMBA SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE POISSON DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER = ALAMBA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!                 --ALAMBA SHOULD BE POSITIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     COMMENT--THE SINGLE PRECISION TAIL LENGTH
!              PARAMETER ALAMBA IS     NOT     RESTRICTED
!              TO ONLY INTEGER VALUES.
!              ALAMBA CAN BE SET TO ANY POSITIVE REAL
!              VALUE--INTEGER OR NON-INTEGER.
!     COMMENT--NOTE THAT EVEN THOUGH THE OUTPUT
!              FROM THIS DISCRETE RANDOM NUMBER
!              GENERATOR MUST NECESSARILY BE A
!              SEQUENCE OF ***INTEGER*** VALUES,
!              THE OUTPUT VECTOR X IS SINGLE
!              PRECISION IN MODE.
!              X HAS BEEN SPECIFIED AS SINGLE
!              PRECISION SO AS TO CONFORM WITH THE DATAPAC
!              CONVENTION THAT ALL OUTPUT VECTORS FROM ALL
!              DATAPAC SUBROUTINES ARE SINGLE PRECISION.
!              THIS CONVENTION IS BASED ON THE BELIEF THAT
!              1) A MIXTURE OF MODES (FLOATING POINT
!              VERSUS INTEGER) IS INCONSISTENT AND
!              AN UNNECESSARY COMPLICATION
!              IN A DATA ANALYSIS; AND
!              2) FLOATING POINT MACHINE ARITHMETIC
!              (AS OPPOSED TO INTEGER ARITHMETIC)
!              IS THE MORE NATURAL MODE FOR DOING
!              DATA ANALYSIS.
!     REFERENCES--COX AND MILLER, THE THEORY OF STOCHASTIC
!                 PROCESSES, 1965, PAGE 7.
!               --TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 36-37.
!               --JOHNSON AND KOTZ, DISCRETE
!                 DISTRIBUTIONS, 1969, PAGES 87-121.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 108-113.
!               --FELLER, AN INTRODUCTION TO PROBABILITY
!                 THEORY AND ITS APPLICATIONS, VOLUME 1,
!                 EDITION 2, 1957, PAGES 146-154.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 929.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82.6
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
      ipr = 6
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE POIRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( Alamba<=0.0 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE POIRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99004) Alamba
99004    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!     GENERATE N POISSON RANDOM NUMBERS
!     USING THE FACT THAT THE DISTRIBUTION
!     OF EXPONENTIAL WAITING TIMES IS POISSON.
!
         DO i = 1 , N
            sum = 0.0
            j = 1
            DO
               CALL UNIRAN(1,Iseed,u)
               e = -ALOG(1.0-u(1))
               sum = sum + e
               IF ( sum>Alamba ) THEN
                  X(i) = j - 1
                  EXIT
               ELSE
                  j = j + 1
               ENDIF
            ENDDO
         ENDDO
      ENDIF
!
      END SUBROUTINE POIRAN
!*==poly.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE POLY(Y,X,W,N,Ideg,Iwrite,B,Sdb,S,Df,Pred,Res)
      IMPLICIT NONE
!*--POLY23881
!*** Start of declarations inserted by SPAG
      REAL ak , amb , amdb1 , amdb2 , amdr1 , amdr2 , amr , an ,        &
     &     aneggi , aneggj , ani , B , b2 , cdf , cdf2 , D , Df , DUM1 ,&
     &     DUM2 , e
      REAL eta , eta2 , etap1 , f , fitdf , fitms , fitss , fstat , g , &
     &     h , Pred , Q , R , repdf , repsd , repss , repv , Res ,      &
     &     resdf , resms
      REAL resss , S , Sdb , sum , t , tol , value , W , whold , wres , &
     &     WS , X , Y , ymean
      INTEGER i , iconv , Ideg , ifitdf , insing , IPIvot , ipr ,       &
     &        iqarg , iqarg1 , iqarg2 , iramax , iramin , irank ,       &
     &        irarg , irarg1 , irarg2 , irarg3 , irepdf , iresdf , is
      INTEGER iset , ism1 , iwflag , Iwrite , j , jm1 , jp1 , js ,      &
     &        jsp1 , k , kk , kmax , kp1 , l , m , N , ni , nk , nkm5 , &
     &        nkmax
      INTEGER nm5 , nmax , numset
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT POLY
      EXTERNAL DOT
!
!     PURPOSE--THIS SUBROUTINE COMPUTES A LEAST SQUARES
!              POLYNOMIAL FIT (OF DEGREE = IDEG) OF THE
!              RESPONSE VARIABLE DATA IN THE SINGLE PRECISION
!              VECTOR Y AS A FUNCTION OF THE INDEPENDENT
!              VARIABLE DATA IN THE SINGLE PRECISION
!              VECTOR X.
!     INPUT  ARGUMENTS--Y      = SINGLE PRECISION VECTOR OF
!                                RESPONSE DATA (THAT IS, THE
!                                DEPENDENT VARIABLE).
!                     --X      = SINGLE PRECISION VECTOR OF
!                                THE INDEPENDENT VARIABLE.
!                     --W      = THE SINGLE PRECISION VECTOR
!                                OF WEIGHTS FOR THE RESPONSE
!                                VARIABLE.
!                     --N      = THE INTEGER VALUE OF THE SAMPLE SIZE.
!                     --IDEG   = THE INTEGER VALUE OF THE DESIRED
!                                DEGREE OF THE POLYNOMIAL
!                                TO BE FIT.
!                     --IWRITE = THE INTEGER VALUE WHICH IF ZERO WILL
!                                RESULT IN NO PRINTED OUTPUT, AND IF
!                                NON-ZERO (E.G., 1) WILL RESULT IN
!                                SOME LIMITED PRINTED OUTPUT
!                                (COEFFICIENTS, STANDARD DEVIATIONS OF
!                                COEFFICIENTS, RESIDUAL STANDARD DEVIATION).
!     OUTPUT ARGUMENTS--B      = THE SINGLE PRECISION VECTOR OF
!                                ESTIMATED REGRESSION COEFFICIENTS.
!                     --SDB    = THE SINGLE PRECISION VECTOR OF
!                                ESTIMATED STANDARD DEVIATIONS OF THE
!                                ESTIMATED REGRESSION COEFFICIENTS.
!                     --S      = THE ESTIMATED RESIDUAL STANDARD
!                                DEVIATION.
!                     --DF     = THE DEGREES OF FREEDOM
!                                ASSOCIATED WITH THE RESIDUAL
!                                STANDARD DEVIATION =
!                                NUMBER OF OBSERVATIONS MINUS
!                                NUMBER OF PARAMETERS =
!                                N - (IDEG + 1).
!                     --PRED   = THE SINGLE PRECISION VECTOR OF
!                                PREDICTED VALUES FROM THE
!                                LEAST SQUARES FIT.
!                     --RES    = THE SINGLE PRECISION VECTOR OF
!                                RESIDUALS FROM THE LEAST SQUARES FIT.
!     SUBROUTINES NEEDED--DECOMP, INVXWX, DOT, FCDF.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--MARCH     1974
!     UPDATED--OCTOBER   1974
!     UPDATED--MARCH     1975
!     UPDATED--MAY       1975
!     UPDATED--JULY      1975
!     UPDATED--SEPTEMBER 1975
!     UPDATED--NOVEMBER  1975.
!     UPDATED--FEBRUARY  1976.
!     UPDATED--JUNE      1976.
!     UPDATED--OCTOBER   1976.
!     UPDATED--MAY       1977.
!     UPDATED--JUNE      1977.
!
!---------------------------------------------------------------------
!
      DIMENSION Y(1) , X(1) , W(1) , B(1) , Sdb(1) , Pred(1) , Res(1)
      DIMENSION b2(50)
      DIMENSION f(3000) , wres(3000) , g(50) , h(50)
      DIMENSION Q(10000) , R(2500) , D(50) , IPIvot(50)
      COMMON /BLOCK2/ WS(15000)
      COMMON /BLOCK3/ DUM1(3000) , DUM2(3000)
      EQUIVALENCE (Q(1),WS(1))
      EQUIVALENCE (R(1),WS(10001))
      EQUIVALENCE (D(1),WS(12501))
      EQUIVALENCE (IPIvot(1),WS(12551))
!
      ipr = 6
      an = N
      k = Ideg + 1
      ak = k
      nk = N*k
      kk = k*k
      nmax = 3000
      kmax = 50
      nkmax = 10000
!
!-----START POINT-----------------------------------------------------
!
!     WRITE OUT THE TITLE
!
      IF ( Iwrite/=0 ) THEN
         WRITE (ipr,99037)
         WRITE (ipr,99037)
         WRITE (ipr,99001)
99001    FORMAT (' ','LEAST SQUARES POLYNOMIAL FIT')
         WRITE (ipr,99002) N
99002    FORMAT (' ',10X,'SAMPLE SIZE N = ',I8)
         WRITE (ipr,99003) Ideg
99003    FORMAT (' ',10X,'DEGREE = ',I8)
      ENDIF
!
!     PRE-SET THE OUTPUT VARIABLES AND VECTORS
!     TO A LARGE VALUE
!     IN CASE A PREMATURE EXIT OCCURS DUE TO NUMERICAL INSTABILITY.
!
      value = (10.0**10) + 1000.0
      S = value
      IF ( k>0 ) THEN
         DO i = 1 , k
            B(i) = value
            Sdb(i) = value
         ENDDO
      ENDIF
      IF ( N>0 ) THEN
         DO i = 1 , N
            Res(i) = value
         ENDDO
      ENDIF
!
!     CHECK THE INPUT ARGUMENTS N AND K
!
      IF ( N<=0 .OR. N>nmax ) WRITE (ipr,99004) N , nmax
99004 FORMAT (' ','*****ERROR--THE SAMPLE SIZE N (= ',I8,               &
     &        ') IS NON-POSITIVE OR LARGER THAN NMAX = ',I8,' *****')
      IF ( N<=0 .OR. N>nmax ) RETURN
      IF ( k<=0 .OR. k>kmax ) WRITE (ipr,99005) k , kmax
99005 FORMAT (' ','*****ERROR--THE DESIRED NUMBER OF COEFFICIENTS K (= '&
     &        ,I8,') IS NON-POSITIVE OR LARGER THAN KMAX = ',I8,        &
     &        ' *****')
      IF ( k<=0 .OR. k>kmax ) RETURN
      IF ( k>N ) WRITE (ipr,99006) k , N
99006 FORMAT (' ','*****ERROR--THE DESIRED NUMBER OF COEFFICIENTS K (= '&
     &        ,I8,') IS LARGER THAN THE SAMPLE SIZE N (= ',I8,') *****')
      IF ( k>N ) RETURN
!
!     INSPECT THE WEIGHT VECTOR W--IF ALL ELEMENTS ARE IDENTICAL,
!     THEN RESET ALL ELEMENTS TO 1.0.  THIS AVOIDS THE
!     PROBLEM OF AN UNDEFINED EMPTY WEIGHT VECTOR W WHEN
!     IN FACT AN EQUAL WEIGHTING SCHEME IS DESIRED.
!
      iwflag = 0
      whold = W(1)
      DO i = 1 , N
         IF ( W(i)/=whold ) GOTO 100
      ENDDO
      iwflag = 1
 100  IF ( iwflag==0 .AND. Iwrite/=0 ) WRITE (ipr,99007)
99007 FORMAT (' ',10X,'UNEQUAL WEIGHTS CASE')
      IF ( iwflag==1 .AND. Iwrite/=0 ) WRITE (ipr,99008)
99008 FORMAT (' ',10X,'EQUAL WEIGHTS CASE')
!
!     COMPUTE THE ORIGINAL FORM FOR THE Q MATRIX
!     WHICH WILL BE IDENTICAL TO THE DATA MATRIX X
!     OF INDEPENDENT VARIABLES IF THE WEIGHTS
!     SPECIFIED ARE ALL EQUAL.  NOTE THAT THE
!     DATA MATRIX X IS NEVER COMPUTED AS SUCH.
!     NOTE THAT THE DATA MATRIX X IS NOT TO BE
!     CONFUSED WITH THE SINGLE INDEPENDENT
!     VARIABLE VECTOR X.
!     THE Q MATRIX WILL BE CHANGED IN THE DECOMP SUBROUTINE.
!
      DO j = 1 , k
         IF ( j==1 ) THEN
            DO i = 1 , N
               iqarg = (i-1)*k + 1
               Q(iqarg) = 1.0
            ENDDO
         ELSEIF ( j==2 ) THEN
            DO i = 1 , N
               iqarg = (i-1)*k + 2
               Q(iqarg) = X(i)
            ENDDO
         ELSE
            jm1 = j - 1
            DO i = 1 , N
               iqarg1 = (i-1)*k + j
               iqarg2 = (i-1)*k + jm1
               Q(iqarg1) = Q(iqarg2)*X(i)
            ENDDO
         ENDIF
      ENDDO
      IF ( iwflag/=1 ) THEN
         DO i = 1 , N
            DO j = 1 , k
               iqarg = (i-1)*k + j
               Q(iqarg) = Q(iqarg)*SQRT(W(i))
            ENDDO
         ENDDO
      ENDIF
!
!     COMPUTE ETA AND TOL (FOR THE UNIVAC 1108, ETA = 2**-27)
!     WHICH WILL BE USED IN THE DECOMP SUBROUTINE
!
      eta = 1.0
      DO
         eta = 0.5*eta
         etap1 = eta + 1.0
         IF ( etap1<=1.0 ) THEN
            tol = eta*ak
            nm5 = N - 5
            nkm5 = nk - 5
!CCCC WRITE(IPR,1505)(Y(I),I=1,6)
!CCCC WRITE(IPR,1505)(Y(I),I=NM5,N)
!CCCC WRITE(IPR,1505)(X(I),I=1,6)
!CCCC WRITE(IPR,1505)(X(I),I=NM5,N)
!CCCC WRITE(IPR,1505)(W(I),I=1,6)
!CCCC WRITE(IPR,1505)(W(I),I=NM5,N)
!CCCC WRITE(IPR,1505)(Q(IQARG),IQARG=1,6)
!CCCC WRITE(IPR,1505)(Q(IQARG),IQARG=NKM5,NK)
!CCCC WRITE(IPR,1505)(Q(IQARG),IQARG=1,NK)
!
            CALL DECOMP(N,k,eta,tol,irank,insing)
!
!CCCC WRITE(IPR,1505)(Q(IQARG),IQARG=1,NK)
!CCCC WRITE(IPR,1505)(R(IRARG),IRARG=1,KK)
!CCCC WRITE(IPR,1505)(D(J),J=1,K)
            IF ( insing==1 ) THEN
               kp1 = k + 1
!
!     ***************************************************************
!
!     THE PURPOSE OF THIS NEXT SEGMENT (BETWEEN THE STARRED LINES)
!     IS TO SOLVE FOR THE DESIRED REGRESSION COEFFICIENTS.
!     ITERATIVE REFINEMENT IS USED.
!     A SECOND OUTPUT FROM THIS SEGMENT IS THE RESIDUALS FROM THE
!     FINAL FIT.
!     A THIRD OUTPUT FROM THIS SEGMENT IS AN INDICATION (IN THE
!     VARIABLE ICONV) AS TO WHETHER THE ITERATIVE REFINEMENT
!     CONVERGED OR NOT.
!     X--USED IN THIS SEGMENT
!     Q--USED IN THIS SEGMENT
!     R--USED IN THIS SEGMENT
!     D--USED IN THIS SEGMENT
!     IPIVOT--USED IN THIS SEGMENT
!
!
               eta2 = eta*eta
               b2(kp1) = -1.0
               DO i = 1 , N
                  f(i) = Y(i)
                  wres(i) = 0.0
                  Res(i) = 0.0
               ENDDO
               DO j = 1 , k
                  b2(j) = 0.0
                  g(j) = 0.0
                  h(j) = 0.0
               ENDDO
               m = 0
               amdb2 = 0.0
               amdr2 = 0.0
               EXIT
            ELSE
               WRITE (ipr,99009) irank , k
99009          FORMAT (' ',                                             &
     &             '*****ERROR--THE MATRIX IS SINGULAR--IT HAS IRANK = '&
     &             ,I8,                                                 &
     &             ' WHICH IS LESS THAN THE NUMBER OF COEFFICIENTS K = '&
     &             ,I8,' *****')
               RETURN
            ENDIF
         ENDIF
      ENDDO
!
!     BEGIN THE M-TH ITERATION STEP IN THE ITERATIVE REFINEMENT
!
 200  IF ( m>=2 ) THEN
         IF ( .NOT.(((64.*amdb2<amdb1) .AND. (amdb2>eta2*amb)) .OR.     &
     &        ((64.*amdr2<amdr1) .AND. (amdr2>eta2*amr))) ) THEN
            IF ( (amdr2>4.*eta2*amr) .AND. (amdb2>4.*eta2*amb) ) THEN
               iconv = 0
            ELSE
               iconv = 1
            ENDIF
!
!     ***************************************************************
!
            IF ( iconv==1 ) THEN
!
!     ADJUST THE R MATRIX
!     WHICH WILL BE USED IN THE INVERT (INVRR) SUBROUTINE.
!
               DO j = 1 , k
                  irarg = (j-1)*k + j
                  R(irarg) = SQRT(D(j))
                  IF ( j/=k ) THEN
                     jp1 = j + 1
                     DO l = jp1 , k
                        irarg1 = (j-1)*k + l
                        irarg2 = (j-1)*k + j
                        R(irarg1) = R(irarg1)*R(irarg2)
                     ENDDO
                  ENDIF
               ENDDO
!CCCC WRITE(IPR,1505)(R(IRARG),IRARG=1,KK)
!
               CALL INVXWX(N,k)
!
!CCCC WRITE(IPR,1505)(R(IRARG),IRARG=1,KK)
!
!     COMPUTE STATISTICAL CALCULATIONS AND THEN WRITE OUT COEFFICIENTS
!     AND STANDARD DEVIATIONS OF COEFFICIENTS ALONG WITH THE
!     RESIDUAL STANDARD DEVIATION.
!
               DO i = 1 , k
                  B(i) = b2(i)
               ENDDO
               DO i = 1 , N
                  IF ( Res(i)/=0.0 ) GOTO 210
               ENDDO
               WRITE (ipr,99010)
99010          FORMAT (' ',10X,                                         &
     &                 'NOTE THAT AN EXACT FIT HAS BEEN OBTAINED')
 210           sum = 0.0
               IF ( iwflag==0 ) THEN
                  DO i = 1 , N
                     sum = sum + Res(i)*Res(i)*W(i)
                  ENDDO
               ELSE
                  DO i = 1 , N
                     sum = sum + Res(i)*Res(i)
                  ENDDO
                  resss = sum
               ENDIF
               IF ( k==N .AND. Iwrite/=0 ) WRITE (ipr,99011) k
99011          FORMAT (' ',10X,                                         &
     &'NOTE THAT THE NUMBER OF COEFFICIENTS K            = THE SAMPLE SI&
     &ZE N = ',I8)
               IF ( k/=N ) THEN
                  resdf = an - ak
                  Df = resdf
                  iresdf = an - ak + 0.5
                  resms = resss/resdf
                  S = SQRT(resms)
               ENDIF
!CCCC WRITE(IPR,3205)
               DO i = 1 , N
                  Pred(i) = Y(i) - Res(i)
!CCCC WRITE(IPR,3305)Y(I),PRED(I),RES(I)
               ENDDO
               IF ( k==N ) THEN
                  IF ( Iwrite/=0 ) WRITE (ipr,99012)
99012             FORMAT (' ','        J        B(J)')
                  DO i = 1 , k
                     IF ( Iwrite/=0 ) WRITE (ipr,99038) j , B(j)
                  ENDDO
                  RETURN
               ELSE
                  IF ( Iwrite/=0 ) WRITE (ipr,99013) S
99013             FORMAT (' ',10X,'RESIDUAL STANDARD DEVIATION = ',     &
     &                    E15.8)
                  IF ( Iwrite/=0 ) WRITE (ipr,99014) iresdf
99014             FORMAT (' ',10X,'RESIDUAL DEGREES OF FREEDOM = ',I8)
                  IF ( Iwrite/=0 ) WRITE (ipr,99015)
99015             FORMAT (' ',10X,'COEFFICIENTS:')
                  IF ( Iwrite/=0 ) WRITE (ipr,99016)
99016             FORMAT (' ',                                          &
     &      '          J        B(J)      SD(B(J))        B(J)/SD(B(J))'&
     &      )
                  DO j = 1 , k
                     irarg = (j-1)*k + j
                     Sdb(j) = S*SQRT(R(irarg))
                     t = B(j)/Sdb(j)
                     IF ( Iwrite/=0 ) WRITE (ipr,99038) j , B(j) ,      &
     &                    Sdb(j) , t
                  ENDDO
!
!     COMPUTE THE COVARIANCE AND CORRELATION MATRIX OF THE COEFFICIENTS
!
                  DO i = 1 , k
                     DO j = 1 , k
                        irarg = (i-1)*k + j
                        R(irarg) = R(irarg)*S*S
                     ENDDO
                  ENDDO
                  DO i = 1 , k
                     DO j = 1 , k
                        IF ( i/=j ) THEN
                           irarg1 = (i-1)*k + j
                           irarg2 = (i-1)*k + i
                           irarg3 = (j-1)*k + j
                           R(irarg1) = R(irarg1)                        &
     &                                 /SQRT(R(irarg2)*R(irarg3))
                        ENDIF
                     ENDDO
                  ENDDO
                  DO j = 1 , k
                     irarg = (j-1)*k + j
                     R(irarg) = 1.0
                  ENDDO
!CCCC WRITE(IPR,2405)
                  DO i = 1 , k
                     iramin = (i-1)*k + 1
                     iramax = i*k
!CCCC WRITE(IPR,2505)(R(IRARG),IRARG=IRAMIN,IRAMAX)
                  ENDDO
!
!     CHECK FOR REPLICATION.
!     IF SO, COMPUTE A POOLED STANDARD DEVIATION.
!     THEN COMPUTE A LACK OF FIT F TEST.
!
!     DETERMINE THE NUMBER OF DISTINCT SUBSETS
!
                  numset = 0
                  DO i = 1 , N
                     IF ( numset/=0 ) THEN
                        DO j = 1 , numset
                           IF ( X(i)==DUM1(j) ) GOTO 215
                        ENDDO
                     ENDIF
                     numset = numset + 1
                     DUM1(numset) = X(i)
 215              ENDDO
                  IF ( numset==0 ) WRITE (ipr,99017)
99017             FORMAT (' ','ERROR IN POLY   SUBROUTINE--NUMSET = 0')
                  IF ( numset==0 ) RETURN
!
!     COPY OUT EACH SUBSET INTO THE DUM2 VECTOR
!     AND ANALYZE IT THEREIN
!
                  irepdf = 0
                  repss = 0.0
                  DO iset = 1 , numset
                     ni = 0
                     DO i = 1 , N
                        IF ( X(i)==DUM1(iset) ) ni = ni + 1
                        IF ( X(i)==DUM1(iset) ) DUM2(ni) = Y(i)
                     ENDDO
                     ani = ni
                     sum = 0.0
                     DO i = 1 , ni
                        sum = sum + DUM2(i)
                     ENDDO
                     ymean = sum/ani
                     sum = 0.0
                     DO i = 1 , ni
                        sum = sum + (DUM2(i)-ymean)**2
                     ENDDO
                     irepdf = irepdf + ni - 1
                     repss = repss + sum
                  ENDDO
                  IF ( irepdf<=0 ) RETURN
                  repdf = irepdf
                  repv = repss/repdf
                  repsd = SQRT(repv)
                  IF ( Iwrite/=0 ) WRITE (ipr,99037)
                  IF ( Iwrite/=0 ) WRITE (ipr,99018) repsd
99018             FORMAT (' ',                                          &
     &                    '          REPLICATION STANDARD DEVIATION  = '&
     &                    ,D15.7)
                  IF ( Iwrite/=0 ) WRITE (ipr,99019) irepdf
99019             FORMAT (' ',                                          &
     &                    '          REPLICATION DEGREES OF FREEDOM  = '&
     &                    ,I8)
                  IF ( Iwrite/=0 ) WRITE (ipr,99020) numset
99020             FORMAT (' ',                                          &
     &                    '          NUMBER OF DISTINCT SUBSETS      = '&
     &                    ,I8)
                  ifitdf = iresdf - irepdf
                  IF ( ifitdf<1 ) GOTO 300
                  fitdf = ifitdf
                  fitss = resss - repss
                  fitms = fitss/fitdf
                  fstat = fitms/resms
                  CALL FCDF(fstat,ifitdf,irepdf,cdf)
                  cdf2 = 100.0*cdf
                  IF ( Iwrite/=0 ) WRITE (ipr,99021) fstat , cdf2
99021             FORMAT (' ','          LACK OF FIT F RATIO = ',F10.4, &
     &                    ' = THE ',F8.4,'% POINT OF THE')
                  IF ( Iwrite/=0 ) WRITE (ipr,99022) ifitdf , irepdf
99022             FORMAT (' ','          F DISTRIBUTION WITH ',I6,      &
     &                    ' AND ',I6,' DEGREES OF FREEDOM')
99023             FORMAT (' ',6E15.8)
99024             FORMAT (' ',I8,5X,E15.8)
99025             FORMAT (' ',8E15.8)
99026             FORMAT (' ','CORRELATION MATRIX OF COEFFICIENTS')
99027             FORMAT (' ',8E15.8)
99028             FORMAT (' ',                                          &
     &                    '      OBSERVED      PREDICTED      RESIDUALS'&
     &                    )
99029             FORMAT (' ',8E15.8)
                  GOTO 99999
               ENDIF
            ELSE
               WRITE (ipr,99030)
99030          FORMAT (' ',                                             &
     &             '*****ERROR--THE ITERATIONS ARE NOT CONVERGING *****'&
     &             )
               RETURN
            ENDIF
         ENDIF
      ENDIF
      amdb1 = amdb2
      amdr1 = amdr2
      amdb2 = 0.0
      amdr2 = 0.0
      IF ( m/=0 ) THEN
!
!     BEGIN FORMING NEW RESIDUALS
!
         IF ( iwflag==0 ) THEN
            DO i = 1 , N
               wres(i) = wres(i) + f(i)*SQRT(W(i))
               Res(i) = Res(i) + f(i)/SQRT(W(i))
            ENDDO
         ELSE
            DO i = 1 , N
               wres(i) = wres(i) + f(i)
               Res(i) = Res(i) + f(i)
            ENDDO
         ENDIF
         DO is = 1 , irank
            j = IPIvot(is)
            b2(j) = b2(j) + g(is)
            DO l = 1 , N
               IF ( j>=2 ) THEN
                  DUM1(l) = X(l)**(j-1)
               ELSE
                  DUM1(l) = 1.0
               ENDIF
            ENDDO
!
            CALL DOT(DUM1,wres,1,N,0.0,g(is))
            g(is) = -g(is)
         ENDDO
!
         DO i = 1 , N
            e = Res(i)
            DO l = 1 , k
               IF ( l>=2 ) THEN
                  DUM1(l) = X(i)**(l-1)
               ELSE
                  DUM1(l) = 1.0
               ENDIF
            ENDDO
            DUM1(kp1) = Y(i)
!
            CALL DOT(DUM1,b2,1,kp1,e,f(i))
            IF ( iwflag==0 ) f(i) = -f(i)*SQRT(W(i))
            IF ( iwflag==1 ) f(i) = -f(i)
         ENDDO
      ENDIF
!
!     END FORMING NEW RESIDUALS
!
      DO is = 1 , irank
         j = IPIvot(is)
         IF ( is/=1 ) THEN
         ENDIF
         ism1 = is - 1
         DO l = 1 , ism1
            irarg = (l-1)*k + is
            DUM1(l) = R(irarg)
         ENDDO
         aneggi = -g(is)
!
         CALL DOT(DUM1,h,1,ism1,aneggi,h(is))
         h(is) = -h(is)
!
         e = -h(is)
         DO l = 1 , N
            iqarg = (l-1)*k + j
            DUM1(l) = Q(iqarg)
         ENDDO
!
         CALL DOT(DUM1,f,1,N,e,e)
         e = e/D(is)
!
         g(is) = e
         DO i = 1 , N
            iqarg = (i-1)*k + j
            f(i) = f(i) - e*Q(iqarg)
         ENDDO
      ENDDO
!
      DO is = 1 , irank
         js = irank + 1 - is
         jsp1 = js + 1
         DO l = jsp1 , irank
            irarg = (js-1)*k + l
            DUM1(l) = R(irarg)
         ENDDO
         aneggj = -g(js)
!
         CALL DOT(DUM1,g,jsp1,irank,aneggj,g(js))
         g(js) = -g(js)
      ENDDO
!
      DO is = 1 , irank
         amdb2 = amdb2 + g(is)*g(is)
      ENDDO
      DO i = 1 , N
         amdr2 = amdr2 + f(i)*f(i)
      ENDDO
      IF ( m==0 ) THEN
         amb = amdb2
         amr = amdr2
!CCCC WRITE(IPR,50505)M
!CCCC WRITE(IPR,50506)(B2(I),I=1,K)
!CCCC DO5555I=1,N
!CCCC WRITE(IPR,50506)Y(I),X(I),RES(I),WRES(I),F(I),G(I),H(I)
!5555 CONTINUE
99031    FORMAT (I8)
99032    FORMAT (' ',8F10.5)
      ENDIF
!
!     END THE M-TH ITERATION STEP IN THE ITERATIVE REFINEMENT
!
      m = m + 1
      GOTO 200
 300  IF ( Iwrite/=0 ) WRITE (ipr,99033)
99033 FORMAT (' ','          LACK OF FIT F TEST CANNOT BE DONE BECAUSE')
      IF ( Iwrite/=0 ) WRITE (ipr,99034)
99034 FORMAT (' ','          HAVE ONLY 0 DEGREES OF FREEDOM IN ',       &
     &        'NUMERATOR OF F RATIO.')
      IF ( Iwrite/=0 ) WRITE (ipr,99035)
99035 FORMAT (' ','          THIS HAPPENS WHEN NUMBER OF PARAMETERS ',  &
     &        'FITTED')
      IF ( Iwrite/=0 ) WRITE (ipr,99036)
99036 FORMAT (' ','          IS IDENTICAL TO NUMBER OF DISTINCT ',      &
     &        'SUBSETS.')
      RETURN
!
99037 FORMAT (' ')
99038 FORMAT (' ',3X,I8,8E15.8)
!
99999 END SUBROUTINE POLY
!*==propor.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE PROPOR(X,N,Xmin,Xmax,Iwrite,Xprop)
      IMPLICIT NONE
!*--PROPOR24531
!*** Start of declarations inserted by SPAG
      REAL an , hold , sum , X , Xmax , Xmin , Xprop
      INTEGER i , ipr , isum , Iwrite , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT PROPOR
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              THE SAMPLE PROPORTION WHICH IS THE
!              PROPORTION OF DATA BETWEEN XMIN AND XMAX (INCLUSIVELY)
!              IN THE INPUT VECTOR X.
!              THE SAMPLE PROPORTION = (THE NUMBER OF OBSERVATIONS
!              IN THE SAMPLE BETWEEN XMIN AND XMAX, INCLUSIVELY) / N.
!              THE SAMPLE PROPORTION WILL BE A SINGLE PRECISION
!              VALUE BETWEEN 0.0 AND 1.0 (INCLUSIVELY).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --XMIN   = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES THE LOWER LIMIT
!                                (INCLUSIVELY) OF THE REGION
!                                OF INTEREST.
!                     --XMAX   = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES THE UPPER LIMIT
!                                (INCLUSIVELY) OF THE REGION
!                                OF INTEREST.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE PROPORTION
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE PROPORTION
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XPROP  = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE PROPORTION.
!                                THIS WILL BE A VALUE BETWEEN
!                                0.0 AND 1.0 (INCLUSIVELY).
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE PROPORTION.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--SNEDECOR AND COCHRAN, STATISTICAL METHODS,
!                 EDITION 6, 1967, PAGES 207-213.
!               --DIXON AND MASSEY, INTRODUCTION TO STATISTICAL
!                 ANALYSIS, EDITION 2, 1957, PAGES 81-82, 228-231.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1974.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE PROPOR SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE PROP&
     &OR SUBROUTINE HAS THE VALUE 1 *****')
         Xprop = 0.0
         RETURN
      ELSE
         IF ( Xmin==Xmax ) THEN
            WRITE (ipr,99004)
99004       FORMAT (' ','***** FATAL ERROR--THE THIRD AND FOURTH INPUT '&
     &              ,'ARGUMENTS TO THE PROPOR SUBROUTINE ARE IDENTICAL')
            WRITE (ipr,99005) Xmin
99005       FORMAT (' ','***** THE VALUE OF THE ARGUMENTS ARE ',E15.7,  &
     &              ' *****')
            Xprop = 0.0
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99006) hold
99006       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE PROPOR SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
            Xprop = 0.0
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
         Xprop = 0.0
         isum = 0
         DO i = 1 , N
            IF ( X(i)>=Xmin .AND. Xmax>=X(i) ) isum = isum + 1
         ENDDO
         sum = isum
         Xprop = sum/an
!
         IF ( Iwrite==0 ) RETURN
         WRITE (ipr,99007)
99007    FORMAT (' ')
         WRITE (ipr,99008) N , Xmin , Xmax , Xprop
99008    FORMAT (' ','THE PROPORTION OF THE ',I6,                       &
     &           ' OBSERVATIONS IN THE INTERVAL ',E15.7,' TO ',E15.7,   &
     &           ' IS ',E15.7)
      ENDIF
      END SUBROUTINE PROPOR
!*==range.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE RANGE(X,N,Iwrite,Xrange)
      IMPLICIT NONE
!*--RANGE24667
!*** Start of declarations inserted by SPAG
      REAL hold , X , xmax , xmin , xramge , Xrange
      INTEGER i , ipr , Iwrite , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT RANGE
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE RANGE
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE SAMPLE RANGE = SAMPLE MAX - SAMPLE MIN.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE RANGE
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE RANGE
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XRANGE = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE RANGE.
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE RANGE.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGE 338.
!               --DAVID, ORDER STATISTICS, 1970, PAGE 10-11.
!               --SNEDECOR AND COCHRAN, STATISTICAL METHODS,
!                 EDITION 6, 1967, PAGE 39.
!               --DIXON AND MASSEY, INTRODUCTION TO STATISTICAL
!                 ANALYSIS, EDITION 2, 1957, PAGE 21.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --JUNE      1974.
!     UPDATED         --APRIL     1975.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE RANGE  SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
!
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE RANG&
     &E  SUBROUTINE HAS THE VALUE 1 *****')
            xramge = 0.0
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE RANGE  SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            Xrange = 0.0
         ENDIF
         GOTO 100
!
!-----START POINT-----------------------------------------------------
!
 50      xmin = X(1)
         xmax = X(1)
         DO i = 1 , N
            IF ( X(i)<xmin ) xmin = X(i)
            IF ( X(i)>xmax ) xmax = X(i)
         ENDDO
         Xrange = xmax - xmin
      ENDIF
!
 100  IF ( Iwrite==0 ) RETURN
      WRITE (ipr,99005)
99005 FORMAT (' ')
      WRITE (ipr,99006) N , Xrange
99006 FORMAT (' ','THE SAMPLE RANGE OF THE ',I6,' OBSERVATIONS IS ',    &
     &        E15.8)
      END SUBROUTINE RANGE
!*==rank.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE RANK(X,N,Xr)
      IMPLICIT NONE
!*--RANK24782
!*** Start of declarations inserted by SPAG
      REAL an , avrank , hold , rprev , X , xprev , Xr , XS
      INTEGER i , ibran , ipr , iupper , j , jmin , jp1 , k , N , nm1
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT RANK
!
!     PURPOSE--THIS SUBROUTINE RANKS (IN ASCENDING ORDER)
!              THE N ELEMENTS OF THE SINGLE PRECISION VECTOR X,
!              AND PUTS THE RESULTING N RANKS INTO THE
!              SINGLE PRECISION VECTOR XR.
!              THIS SUBROUTINE GIVES THE DATA ANALYST
!              THE ABILITY TO (FOR EXAMPLE) RANK THE DATA
!              PRELIMINARY TO CERTAIN DISTRIBUTION-FREE
!              ANALYSES.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                OBSERVATIONS TO BE RANKED.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!     OUTPUT ARGUMENTS--XR     = THE SINGLE PRECISION VECTOR
!                                INTO WHICH THE RANKS
!                                FROM X WILL BE PLACED.
!     OUTPUT--THE SINGLE PRECISION VECTOR XR
!             CONTAINING THE RANKS
!             (IN ASCENDING ORDER)
!             OF THE VALUES
!             IN THE SINGLE PRECISION VECTOR X.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--THE RANK OF THE FIRST ELEMENT
!              OF THE VECTOR X
!              WILL BE PLACED IN THE FIRST POSITION
!              OF THE VECTOR XR,
!              THE RANK OF THE SECOND ELEMENT
!              OF THE VECTOR X
!              WILL BE PLACED IN THE SECOND POSITION
!              OF THE VECTOR XR,
!              ETC.
!     COMMENT--THE SMALLEST ELEMENT IN THE VECTOR X
!              WILL HAVE A RANK OF 1 (UNLESS TIES EXIST).
!              THE LARGEST ELEMENT IN THE VECTOR X
!              WILL HAVE A RANK OF N (UNLESS TIES EXIST).
!     COMMENT--ALTHOUGH RANKS ARE USUALLY (UNLESS TIES EXIST)
!              INTEGRAL VALUES FROM 1 TO N, IT IS TO BE
!              NOTED THAT THEY ARE OUTPUTED AS SINGLE
!              PRECISION INTEGERS IN THE SINGLE PRECISION
!              VECTOR XR.
!              XR IS SINGLE PRECISION SO AS TO BE
!              CONSISTENT WITH THE FACT THAT ALL
!              VECTOR ARGUMENTS IN ALL OTHER
!              DATAPAC SUBROUTINES ARE SINGLE PRECISION;
!              BUT MORE IMPORTANTLY, BECAUSE TIES FREQUENTLY
!              DO EXIST IN DATA SETS AND SO SOME OF THE
!              RESULTING RANKS WILL BE NON-INTEGRAL
!              AND SO THE OUTPUT VECTOR OF RANKS MUST NECESSARILY
!              BE SINGLE PRECISION AND NOT INTEGER.
!     COMMENT--THE INPUT VECTOR X REMAINS UNALTERED.
!     COMMENT--DUE TO CONFLICTING USE OF LABELED
!              COMMON /BLOCK2/ BY THIS RANK
!              SUBROUTINE AND THE SPCORR (SPEARMAN RANK
!              CORRELATION COEFFICIENT) SUBROUTINE,
!              THE VECTOR XS OF THIS RANK
!              SUBROUTINE HAS BEEN PLACED IN
!              LABELED COMMON /BLOCK4/
!     COMMENT--THE FIRST AND THIRD ARGUMENTS IN THE
!              CALLING SEQUENCE MAY
!              BE IDENTICAL; THAT IS, AN 'IN PLACE'
!              RANKING IS PERMITTED.
!              THE CALLING SEQUENCE
!              CALL RANK(X,N,X) IS VALID, IF DESIRED.
!     COMMENT--THE SORTING ALGORTHM USED HEREIN
!              IS THE BINARY SORT.
!              THIS ALGORTHIM IS EXTREMELY FAST AS THE
!              FOLLOWING TIME TRIALS INDICATE.
!              THESE TIME TRIALS WERE CARRIED OUT ON THE
!              UNIVAC 1108 EXEC 8 SYSTEM AT NBS
!              IN AUGUST OF 1974.
!              BY WAY OF COMPARISON, THE TIME TRIAL VALUES
!              FOR THE EASY-TO-PROGRAM BUT EXTREMELY
!              INEFFICIENT BUBBLE SORT ALGORITHM HAVE
!              ALSO BEEN INCLUDED--
!              NUMBER OF RANDOM        BINARY SORT       BUBBLE SORT
!               NUMBERS SORTED
!                N = 10                 .002 SEC          .002 SEC
!                N = 100                .011 SEC          .045 SEC
!                N = 1000               .141 SEC         4.332 SEC
!                N = 3000               .476 SEC        37.683 SEC
!                N = 10000             1.887 SEC      NOT COMPUTED
!     REFERENCES--CACM MARCH 1969, PAGE 186 (BINARY SORT ALGORITHM
!                 BY RICHARD C. SINGLETON).
!               --CACM JANUARY 1970, PAGE 54.
!               --CACM OCTOBER 1970, PAGE 624.
!               --JACM JANUARY 1961, PAGE 41.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --JANUARY   1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --JANUARY   1977.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1) , Xr(1)
      COMMON /BLOCK4/ XS(7500)
!
      an = N
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE RANK   SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE RANK&
     &   SUBROUTINE HAS THE VALUE 1 *****')
            Xr(1) = 1.0
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE RANK   SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            avrank = (an+1.0)/2.0
            DO i = 1 , N
               Xr(i) = avrank
            ENDDO
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
!     FIRST SORT THE DATA FROM THE INPUT VECTOR X
!     INTO THE INTERMEDIATE STORAGE VECTOR XS.
!
 50      CALL SORT(X,N,XS)
!
!     NOW DETERMINE THE RANKS.
!     THE BASIC ALGORITHM IS TO TAKE A GIVEN ELEMENT
!     IN THE ORIGINAL INPUT VECTOR X,
!     AND SCAN THE SORTED VALUES IN THE XS VECTOR
!     UNTIL A MATCH IS FOUND;
!     WHEN A MATCH IS FOUND, THEN THE RANK FOR THAT
!     VALUE IN THE XS VECTOR IS DETERMINED.
!     THAT RANK IS THEN WRITTEN INTO THAT POSITION
!     IN THE OUTPUT Y VECTOR WHICH CORRESPONDS TO THE POSITION OF THE
!     GIVEN ELEMENT OF INTEREST IN THE ORIGINAL X VECTOR.
!     THE CODE IS LENGTHENED FROM THIS BASIC ALGORITHM
!     BY A SECTION WHICH CUTS DOWN THE SEARCH IN THE XS VECTOR,
!     AND BY A SECTION WHICH OBVIATES (UNDER CERTAIN CIRCUMSTANCES)
!     THE NEED FOR RECALCULATING THE RANK OF AN ELEMENT IN XS.
!
         nm1 = N - 1
         xprev = X(1)
         DO i = 1 , N
            jmin = 1
            IF ( X(i)>xprev ) THEN
               jmin = k
               IF ( jmin>=N ) THEN
                  IF ( jmin==N ) GOTO 60
                  ibran = 1
                  WRITE (ipr,99007) ibran
                  WRITE (ipr,99005) jmin
99005             FORMAT (' ','JMIN = ',I8)
                  STOP
               ENDIF
            ELSEIF ( i/=1 ) THEN
               IF ( X(i)==xprev ) THEN
                  Xr(i) = rprev
                  GOTO 80
               ENDIF
            ENDIF
            DO j = jmin , nm1
               IF ( X(i)==XS(j) ) THEN
                  jp1 = j + 1
                  DO k = jp1 , N
                     IF ( XS(k)/=XS(j) ) GOTO 55
                  ENDDO
                  k = N + 1
 55               avrank = j + k - 1
                  avrank = avrank/2.0
                  Xr(i) = avrank
                  GOTO 80
               ENDIF
            ENDDO
 60         j = N
            k = N + 1
            IF ( X(i)==XS(j) ) THEN
               Xr(i) = N
            ELSE
               ibran = 2
               WRITE (ipr,99007) ibran
               WRITE (ipr,99006) X(i) , XS(j)
99006          FORMAT (' ','X(I) = ',F15.7,'   XS(J) = ',F15.7)
               STOP
            ENDIF
 80         xprev = X(i)
            rprev = Xr(i)
         ENDDO
      ENDIF
99007 FORMAT (' ','*****INTERNAL ERROR IN RANK SUBROUTINE--',           &
     &        'IMPOSSIBLE BRANCH CONDITION AT BRANCH POINT = ',I8)
!
      END SUBROUTINE RANK
!*==ranper.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE RANPER(N,Istart,X)
      IMPLICIT NONE
!*--RANPER25011
!*** Start of declarations inserted by SPAG
      REAL add , an , hold , u , X
      INTEGER i , iadd , ipr , Istart , j , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT RANPER
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM PERMUTATION OF SIZE N
!              OF THE VALUES 1.0, 2.0, 3.0, ..., N-1, N.
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER SIZE
!                                OF THE RANDOM 1 TO N PERMUTATION.
!                     --ISTART = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL START THE
!                                GENERATOR OVER AND HENCE
!                                PRODUCE THE SAME RANDOM PERMUTATION
!                                OVER AND OVER AGAIN
!                                UPON SUCCESSIVE CALLS TO
!                                THIS SUBROUTINE WITHIN A RUN; OR
!                                (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0,
!                                LIKE, SAY, 1) WILL ALLOW
!                                THE GENERATOR TO CONTINUE
!                                FROM WHERE IT STOPPED
!                                AND HENCE PRODUCE DIFFERENT
!                                RANDOM PERMUTATIONS UPON
!                                SUCCESSIVE CALLS TO
!                                THIS SUBROUTINE WITHIN A RUN.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM PERMUTATION WILL BE PLACED.
!     OUTPUT--A RANDOM PERMUTATION OF SIZE N
!             OF THE VALUES 1.0, 2.0, 3.0, ..., N-1, N.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--ALGORITHM SUGGESTED BY DAN LOZIER,
!              NATIONAL BUREAU OF STANDARDS (205.01).
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --MAY       1974.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION u(1)
!
      an = N
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE RANPER SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE RANP&
     &ER SUBROUTINE HAS THE VALUE 1 *****')
         X(1) = 1
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         CALL UNIRAN(1,Istart,u)
!
         DO i = 1 , N
            X(i) = i
         ENDDO
!
         DO i = 1 , N
            CALL UNIRAN(1,1,u)
            add = an*u(1) + 1.0
            iadd = add
            IF ( iadd<1 ) iadd = 1
            IF ( iadd>N ) iadd = N
            j = i + iadd
            IF ( j>N ) j = j - N
            hold = X(j)
            X(j) = X(i)
            X(i) = hold
         ENDDO
      ENDIF
      END SUBROUTINE RANPER
!*==read.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE READ(Icol1,Icol2,X,N)
      IMPLICIT NONE
!*--READ25117
!*** Start of declarations inserted by SPAG
      INTEGER i , ibug , Icol1 , Icol2 , iend , ipower , ipr , ird ,    &
     &        istart , istop , j , jp1 , jp2 , jrev , k , l , locpt ,   &
     &        maxcol , mincol , N
      INTEGER nc , ncp1 , ndp , numcrd , numdec , numint
      REAL sum , X , y
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT READ
!
!     PURPOSE--THIS SUBROUTINE PERFORMS A FORMAT-FREE READ
!              OF DATA FROM PUNCHED CARDS.
!              ONLY THE CARD COLUMNS BETWEEN ICOL1 AND ICOL2
!              (INCLUSIVELY) ARE SCANNED FOR THE READ.
!              THIS SUBROUTINE GIVES THE DATA ANALYST THE ABILITY
!              TO GET DATA INTO THE MACHINE WITHOUT HAVING
!              TO WORRY ABOUT AND SPECIFY FORMATS.
!              THE DATA CARDS MAY BE PUNCHED UP
!              WITHOUT REGARD TO ANY PARTICULAR FORMAT
!              AND MAY BE ENTERED INTO THE MACHINE
!              WITHOUT DEFINING ANY FORMATS.
!     INPUT  ARGUMENTS--ICOL1  = THE INTEGER CARD COLUMN NUMBER
!                                WHICH DEFINES THE LOWER BOUND
!                                (INCLUSIVELY) OF THE INTERVAL
!                                ON EACH CARD TO BE SCANNED
!                                FOR THE READ.
!                     --ICOL2  = THE INTEGER CARD COLUMN NUMBER
!                                WHICH DEFINES THE UPPER BOUND
!                                (INCLUSIVELY) OF THE INTERVAL
!                                ON EACH CARD TO BE SCANNED
!                                FOR THE READ.
!     OUTPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR
!                                INTO WHICH THE READ DATA VALUES
!                                WILL BE SEQUENTIALLY PLACED.
!                     --N      = THE INTEGER VALUE
!                                WHICH WILL EQUAL THE NUMBER OF DATA
!                                VALUES WHICH WERE READ.
!     OUTPUT--THE SINGLE PRECISION VECTOR X WHICH
!             WILL CONTAIN THE READ
!             DATA VALUES, AND
!             THE INTEGER VALUE N WHICH WILL
!             EQUAL THE NUMBER OF DATA VALUES
!             READ INTO X.
!             ALSO, 7 LINES OF SUMMARY INFORMATION
!             WILL BE GENERATED--
!             REGARDING WHAT WAS IN FACT READ INTO THE MACHINE--
!             1) THE VALUES OF ICOL1 AND ICOL2;
!             2) THE (ENTIRE) FIRST DATA CARD READ;
!             3) THE (ENTIRE) LAST DATA CARD READ;
!             4) THE TOTAL NUMBER OF DATA CARDS READ;
!             5) THE TOTAL NUMBER OF DATA VALUES READ.
!     PRINTING--YES.
!     RESTRICTIONS--ICOL1 AND ICOL2 MUST BE BETWEEN 1 AND 80,
!                   INCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--ADJACENT DATA VALUES ON THE SAME CARD
!              MUST BE SEPARATED BY AT LEAST 1 BLANK
!              OR 1 ALPHABETIC CHARACTER, OR BY  ANY
!              COMBINATION OF BLANKS AND ALPHABETIC
!              CHARACTERS.  IN THIS CONTEXT, AN
!              ALPHABETIC CHARACTER IS ANY CHARACTER
!              OTHER THAN 0, 1, 2, ..., 9, +, -, OR ..
!              IN EFFECT, THEREFORE, ALL ALPHABETIC INFORMATION
!              IN THE INTERVAL DEFINED BY ICOL1 AND ICOL2
!              (INCLUSIVELY) IS IGNORED FOR READING PURPOSES.
!              ALL INFORMATION (BOTH NUMERIC AND ALPHABETIC)
!              OUTSIDE THE DEFINED INTERVAL IS ALSO IGNORED
!              FOR READING PURPOSES.
!     COMMENT--THE DATA VALUES ON THE CARDS ARE FREE-FORMAT.
!              THEY MAY BE EITHER INTEGER OR FLOATING POINT
!              (THAT IS, WITHOUT OR WITH THE DECIMAL POINTS).
!              EXPONENTIAL FLOATING POINT FORMAT (E FORMAT)
!              IS NOT PERMITTED.
!              ALL DATA, WHETHER WITHOUT OR WITH THE DECIMAL POINT
!              ON THE CARDS, WILL BE READ INTO THE MACHINE
!              INTO THE X VECTOR AND WILL RESIDE THERE AS FLOATING
!              POINT NUMBERS.
!     COMMENT--ANY PARTICULAR DATA VALUE MUST START AND END
!              ON THE SAME DATA CARD; DATA VALUES MAY NOT
!              START ON ONE CARD AND FINISH ON THE NEXT.
!              VARIOUS ILLEGAL COMBINATIONS (SUCH AS
!              MULTIPLE DECIMAL POINTS, MULTIPLE PLUSSES OR
!              MINUSES, INCOMPLETE VALUES CONSISTING ONLY
!              OF A DECIMAL POINT, OR ONLY OF A SIGN AND A DECIMAL
!              POINT, ETC. ARE NOT ACCEPTED AND THE
!              DATA ANALYST WILL BE INFORMED OF THE EXISTENCE OF
!              SUCH BY AN ERROR DIAGNOSTIC.
!              IN THE EVENT OF SUCH AN ILLEGAL COMBINATION,
!              THAT 'NUMBER' AND ALL REMAINING NUMBERS ON THAT CARD WILL
!              WILL BE IGNORED (NOT READ INTO THE MACHINE)
!              AND THE NEXT DATA CARD WILL THEN
!              BE READ.
!     COMMENT--THIS SUBROUTINE WILL CONTINUOUSLY AND
!              SEQUENTIALLY READ CARDS UNTIL A CARD WITH
!              THE WORD         END       (SOMEWHERE BETWEEN
!              COLUMNS ICOL1 AND ICOL2 (INCLUSIVELY)
!              IS ENCOUNTERED.
!              TO TERMINATE A DATA SET, THE ANALYST SHOULD
!              APPEND SUCH A CARD WHICH HAS THE WORD
!              END        SOMEWHERE IN THE INTERVAL
!              DEFINED BY ICOL1 AND ICOL2.
!              FOR EXAMPLE, IF ICOL1 = 1 AND ICOL2 = 20,
!              THEN A SEPARATE CARD WITH     END
!              IN COLUMNS 1, 2, AND 3, OR
!              IN COLUMNS 10, 11, AND 12, ETC.
!              WOULD TERMINATE THE READ.
!              IT IS IMPORTANT TO APPEND SUCH A CARD--
!              FAILURE TO DO SO WILL RESULT IN AN INCOMPLETE
!              DATA SET OR (ON SOME COMPUTERS) AN
!              UNPREDICTABLE RUN TERMINATION.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--DECEMBER  1972.
!     UPDATED         --AUGUST    1974.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --OCTOBER   1976.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 plus , minus , point , blank
      CHARACTER*4 alphae , alphan , alphad
      CHARACTER*4 ic
      CHARACTER*4 ia
      CHARACTER*4 ichar
      CHARACTER*4 istor1
      CHARACTER*4 istor2
!
      DIMENSION X(1)
      DIMENSION ia(80) , ichar(41) , ic(10)
      DIMENSION istor1(80) , istor2(80)
!
      DATA plus , minus , point , blank/'+' , '-' , '.' , ' '/
      DATA alphae , alphan , alphad/'E' , 'N' , 'D'/
      DATA ic(1) , ic(2) , ic(3) , ic(4) , ic(5) , ic(6) , ic(7) ,      &
     &     ic(8) , ic(9) , ic(10)/'0' , '1' , '2' , '3' , '4' , '5' ,   &
     &     '6' , '7' , '8' , '9'/
!
      N = 0
      ird = 5
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      mincol = Icol1
      maxcol = Icol2
      IF ( Icol2<Icol1 ) mincol = Icol2
      IF ( Icol2<Icol1 ) maxcol = Icol1
      IF ( mincol<1 .OR. maxcol>80 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST OR SECOND (OR BOTH) INPUT ARGUMENT T&
     &O THE READ   SUBROUTINE IS OUTSIDE THE')
         WRITE (ipr,99002)
99002    FORMAT (' ','      ALLOWABLE (1,80) INTERVAL *****')
         WRITE (ipr,99003) Icol1 , Icol2
99003    FORMAT (' ','***** THE VALUE OF THE FIRST ARGUMENT IS ',I7,    &
     &           '  AND THE VALUE OF THE SECOND ARGUMENT IS ',I7,       &
     &           ' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         ibug = 0
!
         numcrd = 0
      ENDIF
 100  READ (ird,99004,END=700) (ia(i),i=1,80)
99004 FORMAT (80A1)
      IF ( ibug==1 ) WRITE (6,99005) (ia(i),i=1,80)
99005 FORMAT (' ',80A1)
      DO j = 1 , 78
         jp1 = j + 1
         jp2 = j + 2
         IF ( ia(j)==alphae .AND. ia(jp1)==alphan .AND. ia(jp2)         &
     &        ==alphad ) GOTO 700
      ENDDO
      numcrd = numcrd + 1
      IF ( numcrd==1 ) THEN
         DO j = 1 , 80
            istor1(j) = ia(j)
            istor2(j) = ia(j)
         ENDDO
      ELSE
         DO j = 1 , 80
            istor2(j) = ia(j)
         ENDDO
      ENDIF
      i = mincol
!
 200  DO j = 1 , 41
         ichar(j) = blank
      ENDDO
      nc = 0
      ndp = 0
 300  DO
         DO j = 1 , 10
            IF ( ia(i)==ic(j) ) GOTO 400
         ENDDO
         IF ( ia(i)==plus ) THEN
!
            IF ( nc==0 ) THEN
               nc = 1
               ichar(nc) = ia(i)
               i = i + 1
               IF ( i>maxcol ) THEN
                  WRITE (ipr,99025)
                  WRITE (ipr,99006)
99006             FORMAT (' ',                                          &
     &'***** PUNCHED INPUT ERROR--THE LAST DATA VALUE ON THE CARD BELOW &
     &CONSISTS OF ONLY A PLUS *****')
                  WRITE (ipr,99026)
                  WRITE (ipr,99027) numcrd
                  WRITE (ipr,99028) (ia(j),j=1,80)
                  WRITE (ipr,99025)
                  GOTO 100
               ENDIF
            ELSE
               WRITE (ipr,99025)
               WRITE (ipr,99007)
99007          FORMAT (' ',                                             &
     &'***** PUNCHED INPUT ERROR--A PLUS HAS OCCURRED IN THE MIDDLE OF S&
     &OME DATA VALUE ON THE CARD BELOW *****')
               WRITE (ipr,99026)
               WRITE (ipr,99027) numcrd
               WRITE (ipr,99028) (ia(j),j=1,80)
               WRITE (ipr,99025)
               GOTO 100
            ENDIF
         ELSEIF ( ia(i)==minus ) THEN
!
            IF ( nc==0 ) THEN
               nc = 1
               ichar(nc) = ia(i)
               i = i + 1
               IF ( i>maxcol ) THEN
                  WRITE (ipr,99025)
                  WRITE (ipr,99008)
99008             FORMAT (' ',                                          &
     &'***** PUNCHED INPUT ERROR--THE LAST DATA VALUE ON THE CARD BELOW &
     &CONSISTS OF ONLY A MINUS *****')
                  WRITE (ipr,99026)
                  WRITE (ipr,99027) numcrd
                  WRITE (ipr,99028) (ia(j),j=1,80)
                  WRITE (ipr,99025)
                  GOTO 100
               ENDIF
            ELSE
               WRITE (ipr,99025)
               WRITE (ipr,99009)
99009          FORMAT (' ',                                             &
     &'***** PUNCHED INPUT ERROR--A MINUS HAS OCCURRED IN THE MIDDLE OF &
     &SOME DATA VALUE ON THE CARD BELOW *****')
               WRITE (ipr,99026)
               WRITE (ipr,99027) numcrd
               WRITE (ipr,99028) (ia(j),j=1,80)
               WRITE (ipr,99025)
               GOTO 100
            ENDIF
         ELSEIF ( ia(i)==point ) THEN
!
            IF ( nc==0 ) THEN
               nc = 1
               ichar(nc) = plus
               nc = 2
               ichar(nc) = ia(i)
               ndp = ndp + 1
               i = i + 1
               IF ( i>maxcol ) THEN
                  WRITE (ipr,99025)
                  WRITE (ipr,99010)
99010             FORMAT (' ',                                          &
     &'***** PUNCHED INPUT ERROR--THE LAST DATA VALUE ON THE CARD BELOW &
     &CONSISTS OF ONLY A DECIMAL POINT *****')
                  WRITE (ipr,99026)
                  WRITE (ipr,99027) numcrd
                  WRITE (ipr,99028) (ia(j),j=1,80)
                  WRITE (ipr,99025)
                  GOTO 100
               ENDIF
            ELSEIF ( nc==1 ) THEN
               nc = 2
               ichar(nc) = ia(i)
               ndp = ndp + 1
               i = i + 1
               IF ( i>maxcol ) THEN
                  WRITE (ipr,99025)
                  WRITE (ipr,99011)
99011             FORMAT (' ',                                          &
     &'***** PUNCHED INPUT ERROR--THE LAST DATA VALUE ON THE CARD BELOW &
     &CONSISTS OF ONLY A      +.     OR OF ONLY A      -.    *****')
                  WRITE (ipr,99026)
                  WRITE (ipr,99027) numcrd
                  WRITE (ipr,99028) (ia(j),j=1,80)
                  WRITE (ipr,99025)
                  GOTO 100
               ENDIF
            ELSEIF ( ndp==0 ) THEN
               nc = nc + 1
               ichar(nc) = ia(i)
               ndp = ndp + 1
               i = i + 1
               IF ( i>maxcol ) THEN
                  iend = 1
                  GOTO 500
               ENDIF
            ELSE
               WRITE (ipr,99025)
               WRITE (ipr,99012)
99012          FORMAT (' ',                                             &
     &'***** PUNCHED INPUT ERROR--SOME DATA VALUE ON THE CARD BELOW HAS &
     &MULTIPLE DECIMAL POINTS *****')
               WRITE (ipr,99026)
               WRITE (ipr,99027) numcrd
               WRITE (ipr,99028) (ia(j),j=1,80)
               WRITE (ipr,99025)
               GOTO 100
            ENDIF
         ELSEIF ( nc==0 ) THEN
!
            i = i + 1
            IF ( i>maxcol ) GOTO 100
         ELSEIF ( nc==1 ) THEN
!
            WRITE (ipr,99025)
            WRITE (ipr,99013)
99013       FORMAT (' ',                                                &
     &'***** PUNCHED INPUT ERROR--SOME DATA VALUE ON THE CARD BELOW CONS&
     &ISTS OF ONLY A PLUS OR OF ONLY A MINUS *****')
            WRITE (ipr,99026)
            WRITE (ipr,99027) numcrd
            WRITE (ipr,99028) (ia(j),j=1,80)
            WRITE (ipr,99025)
            GOTO 100
         ELSEIF ( nc==2 ) THEN
!
            IF ( ichar(1)==plus .AND. ichar(2)==point ) THEN
               WRITE (ipr,99025)
               WRITE (ipr,99014)
99014          FORMAT (' ',                                             &
     &'***** PUNCHED INPUT ERROR--SOME DATA VALUE ON THE CARD BELOW CONS&
     &ISTS OF ONLY A      +.     *****')
               WRITE (ipr,99026)
               WRITE (ipr,99027) numcrd
               WRITE (ipr,99028) (ia(j),j=1,80)
               WRITE (ipr,99025)
               GOTO 100
            ELSEIF ( ichar(1)==minus .AND. ichar(2)==point ) THEN
               WRITE (ipr,99025)
               WRITE (ipr,99015)
99015          FORMAT (' ',                                             &
     &'***** PUNCHED INPUT ERROR--SOME DATA VALUE ON THE CARD BELOW CONS&
     &ISTS OF ONLY A      -.     *****')
               WRITE (ipr,99026)
               WRITE (ipr,99027) numcrd
               WRITE (ipr,99028) (ia(j),j=1,80)
               WRITE (ipr,99025)
               GOTO 100
            ELSE
               iend = 0
               GOTO 500
            ENDIF
         ELSE
            iend = 0
            GOTO 500
         ENDIF
      ENDDO
!
 400  IF ( nc==0 ) THEN
         nc = 1
         ichar(nc) = plus
      ENDIF
      nc = nc + 1
      ichar(nc) = ia(i)
      i = i + 1
      IF ( i<=maxcol ) GOTO 300
      iend = 1
!
!
!
 500  DO j = 2 , nc
         IF ( ichar(j)==point ) GOTO 600
      ENDDO
      j = nc + 1
      ncp1 = nc + 1
      ichar(ncp1) = point
      nc = ncp1
!
 600  locpt = j
      numint = j - 2
      numdec = nc - j
      sum = 0.0
      IF ( numint/=0 ) THEN
         istart = 2
         istop = numint + 1
         ipower = -1
         DO j = istart , istop
            jrev = istop - j + 2
            DO k = 1 , 10
               IF ( ichar(jrev)==ic(k) ) GOTO 620
            ENDDO
            WRITE (ipr,99025)
            WRITE (ipr,99016)
99016       FORMAT (' ',                                                &
     &'***** PROGRAMMING ERROR IN THE READ   SUBROUTINE-- A NON-NUMERIC &
     &CHARACTER WAS ENCOUNTERED IN CONVERTING THE INTEGER PART')
            WRITE (ipr,99029) (ichar(l),l=1,41)
            WRITE (ipr,99028) (ia(l),l=1,80)
            WRITE (ipr,99027) numcrd
            WRITE (ipr,99025)
            RETURN
!
 620        y = k - 1
            ipower = ipower + 1
            sum = sum + y*(10.0**ipower)
         ENDDO
      ENDIF
!
      IF ( numdec/=0 ) THEN
         istart = locpt + 1
         istop = nc
         ipower = 0
         DO j = istart , istop
            DO k = 1 , 10
               IF ( ichar(j)==ic(k) ) GOTO 640
            ENDDO
            WRITE (ipr,99025)
            WRITE (ipr,99017)
99017       FORMAT (' ',                                                &
     &'***** PROGRAMMING ERROR IN THE READ   SUBROUTINE-- A NON-NUMERIC &
     &CHARACTER WAS ENCOUNTERED IN CONVERTING THE DECIMAL PART')
            WRITE (ipr,99029) (ichar(l),l=1,41)
            WRITE (ipr,99028) (ia(l),l=1,80)
            WRITE (ipr,99027) numcrd
            WRITE (ipr,99025)
            RETURN
!
 640        y = k - 1
            ipower = ipower + 1
            sum = sum + y/(10.0**ipower)
         ENDDO
      ENDIF
!
      IF ( ichar(1)==minus ) sum = -sum
      N = N + 1
      X(N) = sum
      IF ( iend==1 ) GOTO 100
      i = i + 1
      IF ( i>maxcol ) GOTO 100
      GOTO 200
 700  WRITE (ipr,99025)
      IF ( numcrd/=0 ) THEN
         WRITE (ipr,99018)
99018    FORMAT (' ','OUTPUT FROM THE READ   SUBROUTINE--')
         WRITE (ipr,99019) ird
99019    FORMAT (' ','THE INPUT UNIT DEVICE NUMBER = ',I7)
         WRITE (ipr,99020) mincol , maxcol
99020    FORMAT (' ',                                                   &
     &           'THE SCANNING INTERVAL FOR EACH DATA CARD WAS COLUMN  '&
     &           ,I3,' THROUGH COLUMN  ',I3,' (INCLUSIVE)')
         WRITE (ipr,99021) (istor1(j),j=1,80)
99021    FORMAT (' ','THE (ENTIRE) FIRST  DATA CARD READ WAS   ',80A1)
         WRITE (ipr,99022) (istor2(j),j=1,80)
99022    FORMAT (' ','THE (ENTIRE) LAST   DATA CARD READ WAS   ',80A1)
      ENDIF
      WRITE (ipr,99023) numcrd
99023 FORMAT (' ','THE TOTAL NUMBER OF DATA CARDS READ WAS        ',I7)
      WRITE (ipr,99024) N
99024 FORMAT (' ','THE TOTAL NUMBER (= N) OF DATA VALUES READ WAS ',I7)
      WRITE (ipr,99025)
      WRITE (ipr,99025)
      RETURN
!
99025 FORMAT (' ')
99026 FORMAT (' ',                                                      &
     &'      THIS ILLEGAL DATA VALUE AND ALL SUBSEQUENT DATA VALUES ON T&
     &HIS CARD (ONLY) HAVE BEEN DELETED')
99027 FORMAT (' ','      THIS CARD WAS THE ',I7,                        &
     &        '-TH DATA CARD THAT WAS READ')
99028 FORMAT (' ','      THE CARD IS AS FOLLOWS--   ',80A1)
99029 FORMAT (' ','      OF THE FOLLOWING DATA VALUE--   ',41A1)
      END SUBROUTINE READ
!*==readg.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE READG(Ird,Icol1,Icol2,X,N)
      IMPLICIT NONE
!*--READG25610
!*** Start of declarations inserted by SPAG
      INTEGER i , Icol1 , Icol2 , iend , ipower , ipr , Ird , istart ,  &
     &        istop , j , jp1 , jp2 , jrev , k , l , locpt , maxcol ,   &
     &        mincol , N , nc
      INTEGER ncp1 , ndp , numcrd , numdec , numint
      REAL sum , X , y
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT READG
!
!     PURPOSE--THIS SUBROUTINE PERFORMS A FORMAT-FREE READ
!              OF DATA FROM INPUT UNIT = IRD.
!              ONLY THE CARD COLUMNS BETWEEN ICOL1 AND ICOL2
!              (INCLUSIVELY) ARE SCANNED FOR THE READ.
!              THIS SUBROUTINE IS IDENTICAL TO THE READ SUBROUTINE
!              EXCEPT THAT THE READ SUBROUTINE ASSUMES INPUT UNIT 5,
!              WHEREAS THIS READG SUBROUTINE ALLOWS THE ANALYST
!              TO SPECIFY THE INPUT UNIT.
!              THIS SUBROUTINE GIVES THE DATA ANALYST THE ABILITY
!              TO GET DATA INTO THE MACHINE
!              FROM A VARIETY OF INPUT SOURCES
!              (CARD, TAPE, DISC, ETC.)
!              WITHOUT HAVING
!              TO WORRY ABOUT AND SPECIFY FORMATS.
!              THE DATA CARD IMAGES MAY BE MADE
!              WITHOUT REGARD TO ANY PARTICULAR FORMAT
!              AND MAY BE ENTERED INTO THE MACHINE
!              WITHOUT DEFINING ANY FORMATS.
!     INPUT  ARGUMENTS--IRD    = THE INTEGER VALUE SPECIFYING
!                                THE INPUT UNIT FROM WHICH
!                                THE CARD IMAGES WILL COME.
!                     --ICOL1  = THE INTEGER CARD COLUMN NUMBER
!                                WHICH DEFINES THE LOWER BOUND
!                                (INCLUSIVELY) OF THE INTERVAL
!                                ON EACH CARD IMAGE TO BE SCANNED
!                                FOR THE READ.
!                     --ICOL2  = THE INTEGER CARD COLUMN NUMBER
!                                WHICH DEFINES THE UPPER BOUND
!                                (INCLUSIVELY) OF THE INTERVAL
!                                ON EACH CARD IMAGE TO BE SCANNED
!                                FOR THE READ.
!     OUTPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR
!                                INTO WHICH THE READ DATA VALUES
!                                WILL BE SEQUENTIALLY PLACED.
!                     --N      = THE INTEGER VALUE
!                                WHICH WILL EQUAL THE NUMBER OF DATA
!                                VALUES WHICH WERE READ.
!     OUTPUT--THE SINGLE PRECISION VECTOR X WHICH
!             WILL CONTAIN THE READ
!             DATA VALUES, AND
!             THE INTEGER VALUE N WHICH WILL
!             EQUAL THE NUMBER OF DATA VALUES
!             READ INTO X.
!             ALSO, 7 LINES OF SUMMARY INFORMATION
!             WILL BE GENERATED--
!             REGARDING WHAT WAS IN FACT READ INTO THE MACHINE--
!             1) THE VALUES OF ICOL1 AND ICOL2;
!             2) THE (ENTIRE) FIRST DATA CARD READ;
!             3) THE (ENTIRE) LAST DATA CARD READ;
!             4) THE TOTAL NUMBER OF DATA CARDS READ;
!             5) THE TOTAL NUMBER OF DATA VALUES READ.
!     PRINTING--YES.
!     RESTRICTIONS--ICOL1 AND ICOL2 MUST BE BETWEEN 1 AND 80,
!                   INCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--ADJACENT DATA VALUES ON THE SAME CARD
!              MUST BE SEPARATED BY AT LEAST 1 BLANK
!              OR 1 ALPHABETIC CHARACTER, OR BY  ANY
!              COMBINATION OF BLANKS AND ALPHABETIC
!              CHARACTERS.  IN THIS CONTEXT, AN
!              ALPHABETIC CHARACTER IS ANY CHARACTER
!              OTHER THAN 0, 1, 2, ..., 9, +, -, OR ..
!              IN EFFECT, THEREFORE, ALL ALPHABETIC INFORMATION
!              IN THE INTERVAL DEFINED BY ICOL1 AND ICOL2
!              (INCLUSIVELY) IS IGNORED FOR READING PURPOSES.
!              ALL INFORMATION (BOTH NUMERIC AND ALPHABETIC)
!              OUTSIDE THE DEFINED INTERVAL IS ALSO IGNORED
!              FOR READING PURPOSES.
!     COMMENT--THE DATA VALUES ON THE CARDS ARE FREE-FORMAT.
!              THEY MAY BE EITHER INTEGER OR FLOATING POINT
!              (THAT IS, WITHOUT OR WITH THE DECIMAL POINTS).
!              EXPONENTIAL FLOATING POINT FORMAT (E FORMAT)
!              IS NOT PERMITTED.
!              ALL DATA, WHETHER WITHOUT OR WITH THE DECIMAL POINT
!              ON THE CARDS, WILL BE READ INTO THE MACHINE
!              INTO THE X VECTOR AND WILL RESIDE THERE AS FLOATING
!              POINT NUMBERS.
!     COMMENT--ANY PARTICULAR DATA VALUE MUST START AND END
!              ON THE SAME DATA CARD; DATA VALUES MAY NOT
!              START ON ONE CARD AND FINISH ON THE NEXT.
!              VARIOUS ILLEGAL COMBINATIONS (SUCH AS
!              MULTIPLE DECIMAL POINTS, MULTIPLE PLUSSES OR
!              MINUSES, INCOMPLETE VALUES CONSISTING ONLY
!              OF A DECIMAL POINT, OR ONLY OF A SIGN AND A DECIMAL
!              POINT, ETC. ARE NOT ACCEPTED AND THE
!              DATA ANALYST WILL BE INFORMED OF THE EXISTENCE OF
!              SUCH BY AN ERROR DIAGNOSTIC.
!              IN THE EVENT OF SUCH AN ILLEGAL COMBINATION,
!              THAT 'NUMBER' AND ALL REMAINING NUMBERS ON THAT CARD WILL
!              WILL BE IGNORED (NOT READ INTO THE MACHINE)
!              AND THE NEXT DATA CARD WILL THEN
!              BE READ.
!     COMMENT--THIS SUBROUTINE WILL CONTINUOUSLY AND
!              SEQUENTIALLY READ CARDS UNTIL A CARD WITH
!              THE WORD         END       (SOMEWHERE BETWEEN
!              COLUMNS ICOL1 AND ICOL2 (INCLUSIVELY)
!              IS ENCOUNTERED.
!              TO TERMINATE A DATA SET, THE ANALYST SHOULD
!              APPEND SUCH A CARD WHICH HAS THE WORD
!              END        SOMEWHERE IN THE INTERVAL
!              DEFINED BY ICOL1 AND ICOL2.
!              FOR EXAMPLE, IF ICOL1 = 1 AND ICOL2 = 20,
!              THEN A SEPARATE CARD WITH     END
!              IN COLUMNS 1, 2, AND 3, OR
!              IN COLUMNS 10, 11, AND 12, ETC.
!              WOULD TERMINATE THE READ.
!              IT IS IMPORTANT TO APPEND SUCH A CARD--
!              FAILURE TO DO SO WILL RESULT IN AN INCOMPLETE
!              DATA SET OR (ON SOME COMPUTERS) AN
!              UNPREDICTABLE RUN TERMINATION.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--DECEMBER  1972.
!     UPDATED         --AUGUST    1974.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --OCTOBER   1976.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 plus , minus , point , blank
      CHARACTER*4 alphae , alphan , alphad
      CHARACTER*4 ic
      CHARACTER*4 ia
      CHARACTER*4 ichar
      CHARACTER*4 istor1
      CHARACTER*4 istor2
!
      DIMENSION X(1)
      DIMENSION ia(80) , ichar(41) , ic(10)
      DIMENSION istor1(80) , istor2(80)
!
      DATA plus , minus , point , blank/'+' , '-' , '.' , ' '/
      DATA alphae , alphan , alphad/'E' , 'N' , 'D'/
      DATA ic(1) , ic(2) , ic(3) , ic(4) , ic(5) , ic(6) , ic(7) ,      &
     &     ic(8) , ic(9) , ic(10)/'0' , '1' , '2' , '3' , '4' , '5' ,   &
     &     '6' , '7' , '8' , '9'/
!
      N = 0
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      mincol = Icol1
      maxcol = Icol2
      IF ( Icol2<Icol1 ) mincol = Icol2
      IF ( Icol2<Icol1 ) maxcol = Icol1
      IF ( mincol<1 .OR. maxcol>80 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST OR SECOND (OR BOTH) INPUT ARGUMENT T&
     &O THE READG  SUBROUTINE IS OUTSIDE THE')
         WRITE (ipr,99002)
99002    FORMAT (' ','      ALLOWABLE (1,80) INTERVAL *****')
         WRITE (ipr,99003) Icol1 , Icol2
99003    FORMAT (' ','***** THE VALUE OF THE FIRST ARGUMENT IS ',I7,    &
     &           '  AND THE VALUE OF THE SECOND ARGUMENT IS ',I7,       &
     &           ' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
!
         numcrd = 0
      ENDIF
 100  READ (Ird,99004,END=700) (ia(i),i=1,80)
99004 FORMAT (80A1)
      DO j = 1 , 78
         IF ( ia(j)==alphae ) THEN
            jp1 = j + 1
            IF ( ia(jp1)==alphan ) THEN
               jp2 = j + 2
               IF ( ia(jp2)==alphad ) GOTO 700
            ENDIF
         ENDIF
      ENDDO
      numcrd = numcrd + 1
      IF ( numcrd==1 ) THEN
         DO j = 1 , 80
            istor1(j) = ia(j)
            istor2(j) = ia(j)
         ENDDO
      ELSE
         DO j = 1 , 80
            istor2(j) = ia(j)
         ENDDO
      ENDIF
      i = mincol
!
 200  DO j = 1 , 41
         ichar(j) = blank
      ENDDO
      nc = 0
      ndp = 0
 300  DO
         DO j = 1 , 10
            IF ( ia(i)==ic(j) ) GOTO 400
         ENDDO
         IF ( ia(i)==plus ) THEN
!
            IF ( nc==0 ) THEN
               nc = 1
               ichar(nc) = ia(i)
               i = i + 1
               IF ( i>maxcol ) THEN
                  WRITE (ipr,99024)
                  WRITE (ipr,99005)
99005             FORMAT (' ',                                          &
     &'***** INPUT    DATA ERROR--THE LAST DATA VALUE ON THE CARD BELOW &
     &CONSISTS OF ONLY A PLUS *****')
                  WRITE (ipr,99025)
                  WRITE (ipr,99026) numcrd
                  WRITE (ipr,99027) (ia(j),j=1,80)
                  WRITE (ipr,99024)
                  GOTO 100
               ENDIF
            ELSE
               WRITE (ipr,99024)
               WRITE (ipr,99006)
99006          FORMAT (' ',                                             &
     &'***** INPUT    DATA ERROR--A PLUS HAS OCCURRED IN THE MIDDLE OF S&
     &OME DATA VALUE ON THE CARD BELOW *****')
               WRITE (ipr,99025)
               WRITE (ipr,99026) numcrd
               WRITE (ipr,99027) (ia(j),j=1,80)
               WRITE (ipr,99024)
               GOTO 100
            ENDIF
         ELSEIF ( ia(i)==minus ) THEN
!
            IF ( nc==0 ) THEN
               nc = 1
               ichar(nc) = ia(i)
               i = i + 1
               IF ( i>maxcol ) THEN
                  WRITE (ipr,99024)
                  WRITE (ipr,99007)
99007             FORMAT (' ',                                          &
     &'***** INPUT     DATA ERROR--THE LAST DATA VALUE ON HE CARD BELOW &
     &CONSISTS OF ONLY A MINUS *****')
                  WRITE (ipr,99025)
                  WRITE (ipr,99026) numcrd
                  WRITE (ipr,99027) (ia(j),j=1,80)
                  WRITE (ipr,99024)
                  GOTO 100
               ENDIF
            ELSE
               WRITE (ipr,99024)
               WRITE (ipr,99008)
99008          FORMAT (' ',                                             &
     &'***** INPUT     DATA ERROR--A MINUS HAS OCCURRED INTHE MIDDLE OF &
     &SOME DATA VALUE ON THE CARD BELOW *****')
               WRITE (ipr,99025)
               WRITE (ipr,99026) numcrd
               WRITE (ipr,99027) (ia(j),j=1,80)
               WRITE (ipr,99024)
               GOTO 100
            ENDIF
         ELSEIF ( ia(i)==point ) THEN
!
            IF ( nc==0 ) THEN
               nc = 1
               ichar(nc) = plus
               nc = 2
               ichar(nc) = ia(i)
               ndp = ndp + 1
               i = i + 1
               IF ( i>maxcol ) THEN
                  WRITE (ipr,99024)
                  WRITE (ipr,99009)
99009             FORMAT (' ',                                          &
     &'***** INPUT     DATA ERROR--THE LAST DATA VALUE ON HE CARD BELOW &
     &CONSISTS OF ONLY A DECIMAL POINT *****')
                  WRITE (ipr,99025)
                  WRITE (ipr,99026) numcrd
                  WRITE (ipr,99027) (ia(j),j=1,80)
                  WRITE (ipr,99024)
                  GOTO 100
               ENDIF
            ELSEIF ( nc==1 ) THEN
               nc = 2
               ichar(nc) = ia(i)
               ndp = ndp + 1
               i = i + 1
               IF ( i>maxcol ) THEN
                  WRITE (ipr,99024)
                  WRITE (ipr,99010)
99010             FORMAT (' ',                                          &
     &'***** INPUT     DATA ERROR--THE LAST DATA VALUE ON HE CARD BELOW &
     &CONSISTS OF ONLY A      +.     OR OF ONLY A      -.    *****')
                  WRITE (ipr,99025)
                  WRITE (ipr,99026) numcrd
                  WRITE (ipr,99027) (ia(j),j=1,80)
                  WRITE (ipr,99024)
                  GOTO 100
               ENDIF
            ELSEIF ( ndp==0 ) THEN
               nc = nc + 1
               ichar(nc) = ia(i)
               ndp = ndp + 1
               i = i + 1
               IF ( i>maxcol ) THEN
                  iend = 1
                  GOTO 500
               ENDIF
            ELSE
               WRITE (ipr,99024)
               WRITE (ipr,99011)
99011          FORMAT (' ',                                             &
     &'***** INPUT     DATA ERROR--SOME DATA VALUE ON THE ARD BELOW HAS &
     &MULTIPLE DECIMAL POINTS *****')
               WRITE (ipr,99025)
               WRITE (ipr,99026) numcrd
               WRITE (ipr,99027) (ia(j),j=1,80)
               WRITE (ipr,99024)
               GOTO 100
            ENDIF
         ELSEIF ( nc==0 ) THEN
!
            i = i + 1
            IF ( i>maxcol ) GOTO 100
         ELSEIF ( nc==1 ) THEN
!
            WRITE (ipr,99024)
            WRITE (ipr,99012)
99012       FORMAT (' ',                                                &
     &'***** INPUT     DATA ERROR--SOME DATA VALUE ON THE ARD BELOW CONS&
     &ISTS OF ONLY A PLUS OR OF ONLY A MINUS *****')
            WRITE (ipr,99025)
            WRITE (ipr,99026) numcrd
            WRITE (ipr,99027) (ia(j),j=1,80)
            WRITE (ipr,99024)
            GOTO 100
         ELSEIF ( nc==2 ) THEN
!
            IF ( ichar(1)==plus .AND. ichar(2)==point ) THEN
               WRITE (ipr,99024)
               WRITE (ipr,99013)
99013          FORMAT (' ',                                             &
     &'***** INPUT     DATA ERROR--SOME DATA VALUE ON THE ARD BELOW CONS&
     &ISTS OF ONLY A      +.     *****')
               WRITE (ipr,99025)
               WRITE (ipr,99026) numcrd
               WRITE (ipr,99027) (ia(j),j=1,80)
               WRITE (ipr,99024)
               GOTO 100
            ELSEIF ( ichar(1)==minus .AND. ichar(2)==point ) THEN
               WRITE (ipr,99024)
               WRITE (ipr,99014)
99014          FORMAT (' ',                                             &
     &'***** INPUT     DATA ERROR--SOME DATA VALUE ON THE ARD BELOW CONS&
     &ISTS OF ONLY A      -.     *****')
               WRITE (ipr,99025)
               WRITE (ipr,99026) numcrd
               WRITE (ipr,99027) (ia(j),j=1,80)
               WRITE (ipr,99024)
               GOTO 100
            ELSE
               iend = 0
               GOTO 500
            ENDIF
         ELSE
            iend = 0
            GOTO 500
         ENDIF
      ENDDO
!
 400  IF ( nc==0 ) THEN
         nc = 1
         ichar(nc) = plus
      ENDIF
      nc = nc + 1
      ichar(nc) = ia(i)
      i = i + 1
      IF ( i<=maxcol ) GOTO 300
      iend = 1
!
!
!
 500  DO j = 2 , nc
         IF ( ichar(j)==point ) GOTO 600
      ENDDO
      j = nc + 1
      ncp1 = nc + 1
      ichar(ncp1) = point
      nc = ncp1
!
 600  locpt = j
      numint = j - 2
      numdec = nc - j
      sum = 0.0
      IF ( numint/=0 ) THEN
         istart = 2
         istop = numint + 1
         ipower = -1
         DO j = istart , istop
            jrev = istop - j + 2
            DO k = 1 , 10
               IF ( ichar(jrev)==ic(k) ) GOTO 620
            ENDDO
            WRITE (ipr,99024)
            WRITE (ipr,99015)
99015       FORMAT (' ',                                                &
     &'***** PROGRAMMING ERROR IN THE READG  SUBROUTINE-- A NON-NUMERIC &
     &CHARACTER WAS ENCOUNTERED IN CONVERTING THE INTEGER PART')
            WRITE (ipr,99028) (ichar(l),l=1,41)
            WRITE (ipr,99027) (ia(l),l=1,80)
            WRITE (ipr,99026) numcrd
            WRITE (ipr,99024)
            RETURN
!
 620        y = k - 1
            ipower = ipower + 1
            sum = sum + y*(10.0**ipower)
         ENDDO
      ENDIF
!
      IF ( numdec/=0 ) THEN
         istart = locpt + 1
         istop = nc
         ipower = 0
         DO j = istart , istop
            DO k = 1 , 10
               IF ( ichar(j)==ic(k) ) GOTO 640
            ENDDO
            WRITE (ipr,99024)
            WRITE (ipr,99016)
99016       FORMAT (' ',                                                &
     &'***** PROGRAMMING ERROR IN THE READG  SUBROUTINE-- A NON-NUMERIC &
     &CHARACTER WAS ENCOUNTERED IN CONVERTING THE DECIMAL PART')
            WRITE (ipr,99028) (ichar(l),l=1,41)
            WRITE (ipr,99027) (ia(l),l=1,80)
            WRITE (ipr,99026) numcrd
            WRITE (ipr,99024)
            RETURN
!
 640        y = k - 1
            ipower = ipower + 1
            sum = sum + y/(10.0**ipower)
         ENDDO
      ENDIF
!
      IF ( ichar(1)==minus ) sum = -sum
      N = N + 1
      X(N) = sum
      IF ( iend==1 ) GOTO 100
      i = i + 1
      IF ( i>maxcol ) GOTO 100
      GOTO 200
 700  WRITE (ipr,99024)
      IF ( numcrd/=0 ) THEN
         WRITE (ipr,99017)
99017    FORMAT (' ','OUTPUT FROM THE READG  SUBROUTINE--')
         WRITE (ipr,99018) Ird
99018    FORMAT (' ','THE INPUT UNIT DEVICE NUMBER = ',I7)
         WRITE (ipr,99019) mincol , maxcol
99019    FORMAT (' ',                                                   &
     &     'THE SCANNING INTERVAL FOR EACH DATA CARD IMAGE WAS COLUMN  '&
     &     ,I3,' THROUGH COLUMN  ',I3,' (INCLUSIVE)')
         WRITE (ipr,99020) (istor1(j),j=1,80)
99020    FORMAT (' ','THE (ENTIRE) FIRST  DATA CARD IMAGE   READ WAS ', &
     &           80A1)
         WRITE (ipr,99021) (istor2(j),j=1,80)
99021    FORMAT (' ','THE (ENTIRE) LAST   DATA CARD IMAGE   READ WAS ', &
     &           80A1)
      ENDIF
      WRITE (ipr,99022) numcrd
99022 FORMAT (' ','THE TOTAL NUMBER OF DATA CARD IMAGES  READ WAS ',I7)
      WRITE (ipr,99023) N
99023 FORMAT (' ','THE TOTAL NUMBER (= N) OF DATA VALUES READ WAS ',I7)
      WRITE (ipr,99024)
      WRITE (ipr,99024)
      RETURN
!
99024 FORMAT (' ')
99025 FORMAT (' ',                                                      &
     &'      THIS ILLEGAL DATA VALUE AND ALL SUBSEQUENT DATA VALUES ON T&
     &HIS CARD IMAGE (ONLY) HAVE BEEN DELETED')
99026 FORMAT (' ','      THIS CARD IMAGE WAS THE ',I7,                  &
     &        '-TH DATA CARD IMAGE THAT WAS READ')
99027 FORMAT (' ','      THE CARD IMAGE IS AS FOLLOWS--   ',80A1)
99028 FORMAT (' ','      OF THE FOLLOWING DATA VALUE--   ',41A1)
!
      END SUBROUTINE READG
!*==relsd.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE RELSD(X,N,Iwrite,Xrelsd)
      IMPLICIT NONE
!*--RELSD26115
!*** Start of declarations inserted by SPAG
      REAL an , hold , sd , sum , var , X , xmean , Xrelsd
      INTEGER i , ipr , Iwrite , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT RELSD
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE RELATIVE STANDARD DEVIATION
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE SAMPLE RELATIVE STANDARD DEVIATION = (THE SAMPLE
!              STANDARD DEVIATION)/(THE SAMPLE MEAN).
!              THE DENOMINATOR N-1 IS USED IN COMPUTING THE
!              SAMPLE STANDARD DEVIATION.
!              THE SAMPLE RELATIVE STANDARD DEVIATION IS ALTERNATIVELY
!              REFERRED TO AS THE SAMPLE COEFFICIENT OF VARIATION.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE RELATIVE STANDARD DEVIATION
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE RELATIVE STANDARD DEVIATION
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XRELSD = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE RELATIVE
!                                STANDARD DEVIATION.
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE RELATIVE STANDARD DEVIATION.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGES 47, 233.
!               --SNEDECOR AND COCHRAN, STATISTICAL METHODS,
!                 EDITION 6, 1967, PAGES 62-65.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --MARCH     1975.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      an = N
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE RELSD  SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE RELS&
     &D  SUBROUTINE HAS THE VALUE 1 *****')
            Xrelsd = 0.0
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE RELSD  SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            Xrelsd = 0.0
         ENDIF
         GOTO 100
!
!-----START POINT-----------------------------------------------------
!
 50      sum = 0.0
         DO i = 1 , N
            sum = sum + X(i)
         ENDDO
         xmean = sum/an
         sum = 0.0
         DO i = 1 , N
            sum = sum + (X(i)-xmean)**2
         ENDDO
         var = sum/(an-1.0)
         sd = SQRT(var)
         Xrelsd = 100.0*sd/xmean
      ENDIF
!
 100  IF ( Iwrite==0 ) RETURN
      WRITE (ipr,99005)
99005 FORMAT (' ')
      WRITE (ipr,99006) N , Xrelsd
99006 FORMAT (' THE RELATIVE STANDARD DEVIATION (= STANDARD ',          &
     &        'DEVIATION/MEAN) FOR THE ',I6,' OBSERVATIONS IS ',E12.8,  &
     &        ' PERCENT')
      END SUBROUTINE RELSD
!*==replac.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE REPLAC(X,N,Xmin,Xmax,Xnew)
      IMPLICIT NONE
!*--REPLAC26239
!*** Start of declarations inserted by SPAG
      REAL hold , pointl , pointu , X , Xmax , Xmin , Xnew
      INTEGER i , ipr , k , N , ndel
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT REPLAC
!
!     PURPOSE--THIS SUBROUTINE REPLACES (WITH THE VALUE XNEW)
!              ALL OBSERVATIONS IN THE
!              SINGLE PRECISION VECTOR X WHICH ARE INSIDE
!              THE CLOSED (INCLUSIVE) INTERVAL
!              DEFINED BY XMIN AND XMAX.
!              ALL OBSERVATIONS OUTSIDE OF
!              THIS INTERVAL ARE LEFT UNCHANGED.
!              THUS ALL OBSERVATIONS IN X WHICH ARE
!              EQUAL TO OR LARGER THAN XMIN AND
!              EQUAL TO OR SMALLER THAN XMAX,
!              WILL BE REPLACED BY XNEW.
!              THIS SUBROUTINE (AND THE
!              RETAIN AND DELETE SUBROUTINES)
!              GIVES THE DATA ANALYST THE ABILITY TO
!              EASILY 'CLEAN UP' A DATA SET WHICH HAS
!              MISSING AND/OR OUTLYING OBSERVATIONS
!              SO THAT A MORE APPROPRIATE SUBSEQUENT
!              DATA ANALYSIS MAY BE PERFORMED.
!              FOR EXAMPLE, REPLACEMENT OF AN OUTLIER WITH
!              A MORE APPROPRIATE VALUE CAN EASILY
!              BE DONE BY THIS SUBROUTINE.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --XMIN   = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES THE LOWER LIMIT
!                                (INCLUSIVELY) OF THE PARTICULAR
!                                INTERVAL OF INTEREST FOR REPLACEMENT.
!                     --XMAX   = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES THE UPPER LIMIT
!                                (INCLUSIVELY) OF THE PARTICULAR
!                                INTERVAL OF INTEREST FOR REPLACEMENT.
!                     --XNEW   = THE SINGLE PRECISION VALUE
!                                WITH WHICH ALL OF THE
!                                OBSERVATIONS IN THE INTERVAL
!                                OF INTEREST
!                                WILL BE REPLACED.
!     OUTPUT--THE SINGLE PRECISION VECTOR X
!             IN WHICH ONLY THOSE VALUES INSIDE
!             (INCLUSIVELY) THE INTERVAL OF INTEREST
!             HAVE BEEN REPLACED BY XNEW.
!             ALSO, 6 LINES OF SUMMARY INFORMATION
!             WILL BE GENERATED INDICATING
!             1) WHAT THE INTERVAL OF INTEREST WAS;
!             2) WHAT THE REPLACEMENT VALUE WAS;
!             3) HOW MANY OBSERVATIONS WERE REPLACED;
!             4) WHAT THE SAMPLE SIZE WAS (N);
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--THIS SUBROUTINE MAY BE USEFULLY EMPLOYED
!              IN CONJUNCTION WITH THE DATAPAC
!              PLOTTING SUBROUTINES INASMUCH
!              AS THE LATTER HAVE BEEN
!              SET UP WITH THE CONVENTION
!              THAT ALL VALUES IN THE VERTICAL AXIS
!              VECTOR OR HORIZONTAL AXIS VECTOR
!              WHICH ARE EQUAL TO OR IN EXCESS OF 10.0**10
!              WILL BE AUTOMATICALLY IGNORED
!              IN THE PLOT (THAT IS, NOT PLOTTED).
!              THIS CONVENTION GREATLY SIMPLIFIES THE PROBLEM
!              OF PLOTTING WHEN SOME ELEMENTS IN THE VERTICAL
!              OR HORIZONTAL AXIS VECTORS
!              ARE 'MISSING DATA', OR WHEN WE PURPOSELY
!              WANT TO IGNORE CERTAIN ELEMENTS IN THESE VECTORS
!              FOR PLOTTING PURPOSES (THAT IS, WE DO NOT
!              WANT CERTAIN ELEMENTS TO BE PLOTTED).
!              TO CAUSE SPECIFIC ELEMENTS IN THE VERTICAL
!              OR HORIZONTAL AXIS VECTORS TO BE
!              IGNORED, WE REPLACE THE ELEMENTS BEFOREHAND
!              (BY USE OF THE   REPLAC   SUBROUTINE)
!              BY SOME LARGE VALUE (LIKE, SAY, 10.0**10) AND
!              THEY WILL SUBSEQUENTLY BE IGNORED IN THE PLOTTING
!              SUBROUTINES.
!     COMMENT--THIS IS ONE OF THE FEW SUBRUTINES IN DATAPAC
!              IN WHICH THE INPUT VECTOR X IS ALTERED.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1972.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE REPLAC SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE REPL&
     &AC SUBROUTINE HAS THE VALUE 1 *****')
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE REPLAC SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      pointl = Xmin
         pointu = Xmax
         IF ( Xmin>Xmax ) pointl = Xmax
         IF ( Xmin>Xmax ) pointu = Xmin
!
         k = 0
         DO i = 1 , N
            IF ( X(i)>=pointl .AND. X(i)<=pointu ) THEN
               k = k + 1
               X(i) = Xnew
            ENDIF
         ENDDO
         ndel = N - k
!
!     WRITE OUT A BRIEF SUMMARY
!
         WRITE (ipr,99005)
99005    FORMAT (' ')
         WRITE (ipr,99006)
99006    FORMAT (' ','OUTPUT FROM THE REPLAC SUBROUTINE--')
         WRITE (ipr,99007) pointl , pointu
99007    FORMAT (' ',7X,'ONLY OBSERVATIONS BETWEEN ',E15.8,' AND ',     &
     &           E15.8)
         WRITE (ipr,99008)
99008    FORMAT (' ',7X,'(INCLUSIVE) HAVE BEEN REPLACED.')
         WRITE (ipr,99009)
99009    FORMAT (' ',7X,'ALL OBSERVATIONS OUTSIDE OF THIS INTERVAL')
         WRITE (ipr,99010)
99010    FORMAT (' ',7X,'HAVE BEEN LEFT UNCHANGED.')
         WRITE (ipr,99011) Xnew
99011    FORMAT (' ',7X,'THE REPLACEMENT VALUE IS ',E15.8)
         WRITE (ipr,99012) N
99012    FORMAT (' ',7X,'THE INPUT  NUMBER OF OBSERVATIONS    IS ',I6)
         WRITE (ipr,99013) k
99013    FORMAT (' ',7X,'THE NUMBER OF OBSERVATIONS REPLACED  IS ',I6)
         WRITE (ipr,99014) ndel
99014    FORMAT (' ',7X,'THE NUMBER OF OBSERVATIONS UNCHANGED IS ',I6)
      ENDIF
!
      END SUBROUTINE REPLAC
!*==retain.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE RETAIN(X,N,Xmin,Xmax,Newn)
      IMPLICIT NONE
!*--RETAIN26415
!*** Start of declarations inserted by SPAG
      REAL hold , pointl , pointu , X , Xmax , Xmin
      INTEGER i , ipr , k , N , ndel , Newn , newnp1 , nold
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT RETAIN
!
!     PURPOSE--THIS SUBROUTINE RETAINS ALL OBSERVATIONS IN THE
!              SINGLE PRECISION VECTOR X WHICH ARE INSIDE
!              THE CLOSED (INCLUSIVE) INTERVAL
!              DEFINED BY XMIN AND XMAX,
!              WHILE DELETING ALL OBSERVATIONS OUTSIDE OF
!              THIS INTERVAL.
!              THUS ALL OBSERVATIONS IN X WHICH ARE SMALLER
!              THAN XMIN OR LARGER THAN XMAX ARE DELETED FROM X.
!              THIS SUBROUTINE (AND THE
!              REPLAC AND DELETE SUBROUTINES)
!              GIVES THE DATA ANALYST THE ABILITY TO
!              EASILY 'CLEAN UP' A DATA SET WHICH HAS
!              MISSING AND/OR OUTLYING OBSERVATIONS
!              SO THAT A MORE APPROPRIATE SUBSEQUENT
!              DATA ANALYSIS MAY BE PERFORMED.
!              FOR EXAMPLE, A TRIMMED SAMPLE CAN EASILY
!              BE CONSTRUCTED BY USE OF THIS SUBROUTINE.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --XMIN   = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES THE LOWER LIMIT
!                                (INCLUSIVELY) OF THE PARTICULAR
!                                INTERVAL OF INTEREST TO BE RETAINED.
!                     --XMAX   = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES THE UPPER LIMIT
!                                (INCLUSIVELY) OF THE PARTICULAR
!                                INTERVAL OF INTEREST TO BE RETAINED.
!     OUTPUT ARGUMENTS--NEWN   = THE INTEGER NUMBER OF OBSERVATIONS
!                                REMAINING (RETAINED) IN X AFTER ALL
!                                OF THE OBSERVATIONS OUTSIDE THE
!                                INTERVAL OF INTEREST HAVE BEEN
!                                DELETED.
!     OUTPUT--THE SINGLE PRECISION VECTOR X
!             IN WHICH ONLY THOSE VALUES INSIDE
!             (INCLUSIVELY) THE INTERVAL OF INTEREST
!             HAVE BEEN RETAINED, AND
!             THE INTEGER VALUE NEWN
!             WHICH GIVES THE NUMBER OF
!             OBSERVATIONS RETAINED IN X.
!             ALSO, 6 LINES OF SUMMARY INFORMATION
!             WILL BE GENERATED INDICATING
!             1) WHAT THE INTERVAL OF INTEREST WAS;
!             2) HOW MANY OBSERVATIONS WERE DELETED;
!             3) WHAT THE OLD (ORIGINAL) SAMPLE SIZE WAS (N);
!             4) WHAT THE NEW SAMPLE SIZE IS (NEWN).
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--IN THE END, AFTER THIS SUBROUTINE HAS
!              MADE WHATEVER DELETIONS ARE APPROPRIATE,
!              THE OUTPUT VECTOR X WILL BE 'PACKED';
!              THAT IS, NO 'HOLES' WILL EXIST IN THE
!              VECTOR X--ALL OF THE RETAINED ELEMENTS
!              OF X WILL BE PACKED INTO THE FIRST AVAILABLE
!              LOCATIONS IN X, WHILE THE REMAINDER
!              OF THE N LOCATIONS IN X WILL BE ZERO-FILLED.
!     COMMENT--IN THE MAIN (CALLING) ROUTINE, IT IS
!              PERMISSABLE (IF THE ANALYST SO DESIRES)
!              TO USE THE SAME VARIABLE NAME
!              IN THE FIFTH ARGUMENT AS USED IN THE SECOND
!              ARGUMENT IN THE CALLING SEQUENCE TO THIS
!              RETAIN SUBROUTINE--NO CONFLICT WILL RESULT
!              IN THE INTERNAL OPERATION OF THE     RETAIN
!              SUBROUTINE.  FOR EXAMPLE, IT IS PERMISSIBLE
!              TO HAVE     CALL RETAIN(X,N,-10.0,10.0,N)
!              IN WHICH THE VARIABLE NAME      N    IS USED
!              AS BOTH THE SECOND AND FIFTH ARGUMENTS.
!     COMMENT--THIS IS ONE OF THE FEW SUBROUTINES IN DATAPAC
!              IN WHICH THE INPUT VECTOR X IS ALTERED.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1972.
!     UPDATED         --JULY      1974.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE RETAIN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE RETA&
     &IN SUBROUTINE HAS THE VALUE 1 *****')
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE RETAIN SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      pointl = Xmin
         pointu = Xmax
         IF ( Xmin>Xmax ) pointl = Xmax
         IF ( Xmin>Xmax ) pointu = Xmin
!
         nold = N
         k = 0
         DO i = 1 , nold
            IF ( X(i)>=pointl .AND. X(i)<=pointu ) THEN
               k = k + 1
               X(k) = X(i)
            ENDIF
         ENDDO
         Newn = k
         ndel = nold - Newn
!
         newnp1 = Newn + 1
         IF ( newnp1<=nold ) THEN
            DO i = newnp1 , nold
               X(i) = 0.0
            ENDDO
         ENDIF
!
!     WRITE OUT A BRIEF SUMMARY
!
         WRITE (ipr,99005)
99005    FORMAT (' ')
         WRITE (ipr,99006)
99006    FORMAT (' ','OUTPUT FROM THE RETAIN SUBROUTINE--')
         WRITE (ipr,99007) pointl , pointu
99007    FORMAT (' ',7X,'ONLY OBSERVATIONS BETWEEN ',E15.8,' AND ',     &
     &           E15.8)
         WRITE (ipr,99008)
99008    FORMAT (' ',7X,'(INCLUSIVE) HAVE BEEN RETAINED.')
         WRITE (ipr,99009)
99009    FORMAT (' ',7X,'ALL OBSERVATIONS OUTSIDE OF THIS INTERVAL')
         WRITE (ipr,99010)
99010    FORMAT (' ',7X,'HAVE BEEN DELETED.')
         WRITE (ipr,99011) nold
99011    FORMAT (' ',7X,'THE INPUT  NUMBER OF OBSERVATIONS (IN X) IS ', &
     &           I6)
         WRITE (ipr,99012) Newn
99012    FORMAT (' ',7X,'THE OUTPUT NUMBER OF OBSERVATIONS (IN X) IS ', &
     &           I6)
         WRITE (ipr,99013) ndel
99013    FORMAT (' ',7X,'THE NUMBER OF OBSERVATIONS DELETED       IS ', &
     &           I6)
      ENDIF
!
      END SUBROUTINE RETAIN
!*==runs.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE RUNS(X,N)
      IMPLICIT NONE
!*--RUNS26596
!*** Start of declarations inserted by SPAG
      REAL ai , an , anrdl , anrdlg , anrtl , anrtlg , anrul , anrulg , &
     &     c1 , c2 , c3 , c4 , den , enrtl , enrtlg , enrul , enrulg ,  &
     &     hold , snrtl , snrtlg
      REAL snrul , snrulg , stat , WS , X , Y , znrdl , znrdlg , znrtl ,&
     &     znrtlg , znrul , znrulg
      INTEGER i , imax , ip1 , ipr , iupper , j , jp1 , lendn , lenup , &
     &        maxlnd , maxlnt , maxlnu , N , nm1 , nneg , npos , nrdl , &
     &        nrdlg , nrtl , nrtlg
      INTEGER nrul , nrulg , nzer
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT RUNS
!
!     PURPOSE--THIS SUBROUTINE PERFORMS A RUNS ANALYSIS
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE ANALYSIS CONSISTS OF FIRST DETERMINING
!              THE OBSERVED NUMBER OF RUNS FROM THE DATA,
!              AND THEN COMPUTING
!              THE EXPECTED NUMBER OF RUNS,
!              THE STANDARD DEVIATION OF THE NUMBER OF RUNS,
!              AND THE RESULTING STANDARDIZED STATISTIC
!              FOR THE NUMBER OF RUNS FOR RUNS OF VARIOUS
!              LENGTHS.
!              THIS IS DONE FOR RUNS UP, RUNS DOWN, AND
!              RUNS UP AND DOWN.
!              THIS RUNS ANSLYSIS IS A USEFUL DISTRIBUTION-FREE
!              TEST OF THE RANDOMNESS OF A DATA SET.
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS.
!                      N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--4 PAGES OF AUTOMATIC PRINTOUT
!             CONSISTING OF THE OBSERVED NUMBER,
!             EXPECTED NUMBER, STANDARD DEVIATION
!             AND RESULTING STANDARDIZED STATISTIC
!             FOR RUNS OF VARIOUS LENGTHS.
!             AND THE CUMULATIVE FREQUENCY.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 15000.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--LEVENE AND WOLFOWITZ, ANNALS OF MATHEMATICAL
!                 STATISTICS, 1944, PAGES 58-69;
!                 ESPECIALLY PAGES 60, 63, AND 64.
!     REFERENCES--BRADLEY, DISTRIBUTION-FREE STATISTICAL TESTS,
!                 1968, CHAPTER 12, PAGES 271-282.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(15000)
      DIMENSION nrul(16) , nrdl(16) , nrtl(16) , nrulg(16) , nrdlg(16)
      DIMENSION nrtlg(16)
      DIMENSION enrul(16) , enrtl(16) , enrulg(16) , enrtlg(16)
      DIMENSION snrul(16) , snrtl(16) , snrulg(16) , snrtlg(16)
      DIMENSION znrul(16) , znrdl(16) , znrtl(16) , znrulg(16) ,        &
     &          znrdlg(16)
      DIMENSION znrtlg(16)
      DIMENSION c1(15) , c2(15) , c3(15) , c4(15)
      DIMENSION anrul(16) , anrdl(16) , anrtl(16)
      DIMENSION anrulg(16) , anrdlg(16) , anrtlg(16)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
!
      DATA c1(1) , c1(2) , c1(3) , c1(4) , c1(5) , c1(6) , c1(7) ,      &
     &     c1(8) , c1(9) , c1(10) , c1(11) , c1(12) , c1(13) , c1(14) , &
     &     c1(15)/.4236111111E+00 , .1126675485E+00 , .4191688713E-01 , &
     &     .1076912487E-01 , .2003959238E-02 , .3023235799E-03 ,        &
     &     .3911555473E-04 , .4459038843E-05 , .4551105210E-06 ,        &
     &     .4207466837E-07 , .3555930927E-08 , .2768273257E-09 ,        &
     &     .1997821524E-10 , .1343876568E-11 , .8465610177E-13/
      DATA c2(1) , c2(2) , c2(3) , c2(4) , c2(5) , c2(6) , c2(7) ,      &
     &     c2(8) , c2(9) , c2(10) , c2(11) , c2(12) , c2(13) , c2(14) , &
     &     c2(15)/ - .4819444444E+00 , -.1628284832E+00 ,               &
     &     -.9690696649E-01 , -.3778106786E-01 , -.9289228716E-02 ,     &
     &     -.1724429252E-02 , -.2638557888E-03 , -.3466965096E-04 ,     &
     &     -.4004129153E-05 , -.4130382587E-06 , -.3851876069E-07 ,     &
     &     -.3279103786E-08 , -.2568491117E-09 , -.1863433868E-10 ,     &
     &     -.1259220466E-11/
      DATA c3(1) , c3(2) , c3(3) , c3(4) , c3(5) , c3(6) , c3(7) ,      &
     &     c3(8) , c3(9) , c3(10) , c3(11) , c3(12) , c3(13) , c3(14) , &
     &     c3(15)/.1777777778E+00 , .7916666667E-01 , .4738977072E-01 , &
     &     .1274801587E-01 , .2338606059E-02 , .3461358734E-03 ,        &
     &     .4407121770E-04 , .4960020603E-05 , .5010387575E-06 ,        &
     &     .4592883352E-07 , .3854170274E-08 , .2982393839E-09 ,        &
     &     .2141205844E-10 , .1433843200E-11 , .8996663214E-13/
      DATA c4(1) , c4(2) , c4(3) , c4(4) , c4(5) , c4(6) , c4(7) ,      &
     &     c4(8) , c4(9) , c4(10) , c4(11) , c4(12) , c4(13) , c4(14) , &
     &     c4(15)/ - .3222222222E+00 , -.5972222222E-01 ,               &
     &     -.1130268959E+00 , -.4696428571E-01 , -.1123273065E-01 ,     &
     &     -.2025170849E-02 , -.3029410411E-03 , -.3912824548E-04 ,     &
     &     -.4459234519E-05 , -.4551128785E-06 , -.4207469124E-07 ,     &
     &     -.3555931110E-08 , -.2768273269E-09 , -.1997821525E-10 ,     &
     &     -.1343876568E-11/
!
      ipr = 6
      iupper = 15000
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE RUNS   SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--         THE SECOND INPUT ARGUMENT TO THE RUNS&
     &   SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE RUNS   SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     FORM THE SEQUENTIAL DIFFERENCE TABLE
!
         nm1 = N - 1
         DO i = 1 , nm1
            ip1 = i + 1
            Y(i) = X(ip1) - X(i)
         ENDDO
!
!     ZERO-OUT THE 6 'NUMBER OF RUNS' VECTORS
!
         DO i = 1 , 16
            nrul(i) = 0
            nrdl(i) = 0
            nrtl(i) = 0
            nrulg(i) = 0
            nrdlg(i) = 0
            nrtlg(i) = 0
         ENDDO
!
!     DETERMINE THE NUMBER OF RUNS UP OF LENGTH EXACTLY I
!     AND THE NUMBER OF RUNS DOWN OF LENGTH EXACTLY I
!     DETERMINE THE LENGTH OF THE LONGEST RUN UP
!     AND THE LENGTH OF THE LONGEST RUN DOWN
!
         lenup = 0
         lendn = 0
         maxlnu = 0
         maxlnd = 0
         DO i = 1 , nm1
            IF ( Y(i)==0.0 .AND. lenup>=1 ) lenup = lenup + 1
            IF ( Y(i)==0.0 .AND. lendn>=1 ) lendn = lendn + 1
            IF ( Y(i)==0.0 .AND. lenup==0 .AND. lendn==0 )              &
     &           lenup = lenup + 1
            IF ( Y(i)>0.0 .AND. lendn>=1 .AND. lendn<=15 ) nrdl(lendn)  &
     &           = nrdl(lendn) + 1
            IF ( Y(i)>0.0 .AND. lendn>=1 .AND. lendn>=16 ) nrdl(16)     &
     &           = nrdl(16) + 1
            IF ( Y(i)>0.0 ) lendn = 0
            IF ( Y(i)>0.0 ) lenup = lenup + 1
            IF ( Y(i)<0.0 .AND. lenup>=1 .AND. lenup<=15 ) nrul(lenup)  &
     &           = nrul(lenup) + 1
            IF ( Y(i)<0.0 .AND. lenup>=1 .AND. lenup>=16 ) nrul(16)     &
     &           = nrul(16) + 1
            IF ( Y(i)<0.0 ) lenup = 0
            IF ( Y(i)<0.0 ) lendn = lendn + 1
            IF ( i==nm1 .AND. lendn>=1 .AND. lendn<=15 ) nrdl(lendn)    &
     &           = nrdl(lendn) + 1
            IF ( i==nm1 .AND. lendn>=1 .AND. lendn>=16 ) nrdl(16)       &
     &           = nrdl(16) + 1
            IF ( i==nm1 .AND. lenup>=1 .AND. lenup<=15 ) nrul(lenup)    &
     &           = nrul(lenup) + 1
            IF ( i==nm1 .AND. lenup>=1 .AND. lenup>=16 ) nrul(16)       &
     &           = nrul(16) + 1
            IF ( lenup>maxlnu ) maxlnu = lenup
            IF ( lendn>maxlnd ) maxlnd = lendn
         ENDDO
!
!     DETERMINE THE NUMBER OF RUNS TOTAL OF LENGTH EXACTLY I
!     AND THE LENGTH OF THE LONGEST RUN UP OR DOWN
!
         DO i = 1 , 16
            nrtl(i) = nrul(i) + nrdl(i)
         ENDDO
         maxlnt = maxlnu
         IF ( maxlnd>maxlnu ) maxlnt = maxlnd
!
!     DETERMINE THE NUMBER OF RUNS UP OF LENGTH I OR MORE
!     AND THE NUMBER OF RUNS DOWN OF LENGTH I OR MORE
!     AND THE NUMBER OF RUNS TOTAL OF LENGTH I OR MORE
!
         nrulg(16) = nrul(16)
         nrdlg(16) = nrdl(16)
         nrtlg(16) = nrtl(16)
         DO i = 1 , 15
            j = 16 - i
            jp1 = j + 1
            nrulg(j) = nrulg(jp1) + nrul(j)
            nrdlg(j) = nrdlg(jp1) + nrdl(j)
            nrtlg(j) = nrtlg(jp1) + nrtl(j)
         ENDDO
!
!     DETERMINE THE NUMBER OF POSITIVE, ZERO, AND NEGATIVE ENTRIES
!     IN THE DIFFERENCE TABLE.  IF RANDOM, THE NUMBER OF POSITIVE SHOULD BE
!     APPROXIMATELY EQUAL TO THE NUMBER OF NEGATIVE
!
         nneg = 0
         nzer = 0
         npos = 0
         DO i = 1 , nm1
            IF ( Y(i)<0.0 ) nneg = nneg + 1
            IF ( Y(i)==0.0 ) nzer = nzer + 1
            IF ( Y(i)>0.0 ) npos = npos + 1
         ENDDO
!
!     COMPUTE THE EXPECTED NUMBER OF RUNS UP OF LENGTH EXACTLY I =
!     THE EXPECTED NUMBER OF RUNS DOWN OF LENGTH EXACTLY I =
!     ONE HALF THE EXPECTED NUMBER OF RUNS TOTAL OF LENGTH EXACTLY I
!
         den = 6.0
         DO i = 1 , 15
            ai = i
            enrul(i) = an*(ai*ai+3.0*ai+1.0)                            &
     &                 - (ai*ai*ai+3.0*ai*ai-ai-4.0)
            den = den*(ai+3.0)
            enrul(i) = enrul(i)/den
            enrtl(i) = 2.0*enrul(i)
         ENDDO
!
!     COMPUTE THE EXPECTED NUMBER OF RUNS UP OF LENGTH I OR MORE =
!     THE EXPECTED NUMBER OF RUNS DOWN OF LENGTH I OR MORE =
!     ONE HALF THE EXPECTED NUMBER OF RUNS TOTAL OF LENGTH I OR MORE
!
         den = 2.0
         DO i = 1 , 15
            ai = i
            enrulg(i) = an*(ai+1.0) - (ai*ai+ai-1.0)
            den = den*(ai+2.0)
            enrulg(i) = enrulg(i)/den
            enrtlg(i) = 2.0*enrulg(i)
         ENDDO
!
!     COMPUTE THE STANDARD DEV. OF THE NUMBER OF RUNS UP OF LENGTH EXACTLY I =
!     THE STANDARD DEV. OF THE NUMBER OF RUNS DOWN OF LENGTH EXACTLY I =
!     SQRT(0.5)* THE STAND. DEV. OF THE NUMBER OF RUNS TOTAL OF LENGTH EXACTLY I
!
         DO i = 1 , 15
            snrtl(i) = SQRT(c1(i)*an+c2(i))
            snrul(i) = SQRT(0.5)*snrtl(i)
         ENDDO
!
!     COMPUTE THE STAND. DEV. OF THE NUMBER OF RUNS UP OF LENGTH I OR MORE =
!     THE STAND. DEV. OF THE NUMBER OF RUNS DOWN OF LENGTH I OR MORE =
!     SQRT(0.5)* THE STAND. DEV. OF THE NUMBER OF RUNS TOTAL OF LENGTH I OR MORE
!
         DO i = 1 , 15
            snrtlg(i) = SQRT(c3(i)*an+c4(i))
            snrulg(i) = SQRT(0.5)*snrtlg(i)
         ENDDO
!
!     FORM Z STATISTICS
!
         DO i = 1 , 15
            stat = nrul(i)
            znrul(i) = (stat-enrul(i))/snrul(i)
            stat = nrdl(i)
            znrdl(i) = (stat-enrul(i))/snrul(i)
            stat = nrtl(i)
            znrtl(i) = (stat-enrtl(i))/snrtl(i)
            stat = nrulg(i)
            znrulg(i) = (stat-enrulg(i))/snrulg(i)
            stat = nrdlg(i)
            znrdlg(i) = (stat-enrulg(i))/snrulg(i)
            stat = nrtlg(i)
            znrtlg(i) = (stat-enrtlg(i))/snrtlg(i)
         ENDDO
!
         DO i = 1 , 15
            anrul(i) = nrul(i)
            anrdl(i) = nrdl(i)
            anrtl(i) = nrtl(i)
            anrulg(i) = nrulg(i)
            anrdlg(i) = nrdlg(i)
            anrtlg(i) = nrtlg(i)
         ENDDO
!
!     WRITE EVERYTHING OUT
!
         imax = 15
         WRITE (ipr,99024)
         WRITE (ipr,99005)
99005    FORMAT (' ',48X,'RUNS UP')
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (ipr,99006)
99006    FORMAT (' ',27X,                                               &
     &           'STATISTIC = NUMBER OF RUNS UP    OF LENGTH EXACTLY I')
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (ipr,99022)
         WRITE (ipr,99025)
         DO i = 1 , imax
            WRITE (ipr,99023) i , anrul(i) , enrul(i) , snrul(i) ,      &
     &                        znrul(i)
         ENDDO
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (ipr,99007)
99007    FORMAT (' ',27X,                                               &
     &           'STATISTIC = NUMBER OF RUNS UP    OF LENGTH I OR MORE')
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (ipr,99022)
         WRITE (ipr,99025)
         DO i = 1 , imax
            WRITE (ipr,99023) i , anrulg(i) , enrulg(i) , snrulg(i) ,   &
     &                        znrulg(i)
         ENDDO
         WRITE (ipr,99024)
         WRITE (ipr,99008)
99008    FORMAT (' ',48X,'RUNS DOWN')
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (ipr,99009)
99009    FORMAT (' ',27X,                                               &
     &           'STATISTIC = NUMBER OF RUNS DOWN  OF LENGTH EXACTLY I')
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (ipr,99022)
         WRITE (ipr,99025)
         DO i = 1 , imax
            WRITE (ipr,99023) i , anrdl(i) , enrul(i) , snrul(i) ,      &
     &                        znrdl(i)
         ENDDO
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (ipr,99010)
99010    FORMAT (' ',27X,                                               &
     &           'STATISTIC = NUMBER OF RUNS DOWN  OF LENGTH I OR MORE')
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (ipr,99022)
         WRITE (ipr,99025)
         DO i = 1 , imax
            WRITE (ipr,99023) i , anrdlg(i) , enrulg(i) , snrulg(i) ,   &
     &                        znrdlg(i)
         ENDDO
         WRITE (ipr,99024)
         WRITE (ipr,99011)
99011    FORMAT (' ',40X,'RUNS TOTAL = RUNS UP + RUNS DOWN')
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (ipr,99012)
99012    FORMAT (' ',27X,                                               &
     &           'STATISTIC = NUMBER OF RUNS TOTAL OF LENGTH EXACTLY I')
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (ipr,99022)
         WRITE (ipr,99025)
         DO i = 1 , imax
            WRITE (ipr,99023) i , anrtl(i) , enrtl(i) , snrtl(i) ,      &
     &                        znrtl(i)
         ENDDO
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (ipr,99013)
99013    FORMAT (' ',27X,                                               &
     &           'STATISTIC = NUMBER OF RUNS TOTAL OF LENGTH I OR MORE')
         WRITE (6,99025)
         WRITE (6,99025)
         WRITE (ipr,99022)
         WRITE (ipr,99025)
         DO i = 1 , imax
            WRITE (ipr,99023) i , anrtlg(i) , enrtlg(i) , snrtlg(i) ,   &
     &                        znrtlg(i)
         ENDDO
         WRITE (ipr,99024)
         WRITE (ipr,99014) maxlnu
99014    FORMAT (' ','LENGTH OF THE LONGEST RUN UP         = ',I5)
         WRITE (ipr,99015) maxlnd
99015    FORMAT (' ','LENGTH OF THE LONGEST RUN DOWN       = ',I5)
         WRITE (ipr,99016) maxlnt
99016    FORMAT (' ','LENGTH OF THE LONGEST RUN UP OR DOWN = ',I5)
         WRITE (ipr,99025)
         WRITE (ipr,99017) npos
99017    FORMAT (' ','NUMBER OF POSITIVE DIFFERENCES = ',I5)
         WRITE (ipr,99018) nneg
99018    FORMAT (' ','NUMBER OF NEGATIVE DIFFERENCES = ',I5)
         WRITE (ipr,99019) nzer
99019    FORMAT (' ','NUMBER OF ZERO     DIFFERENCES = ',I5)
99020    FORMAT (' ',2(I4,2X,F7.1,2X,F8.4,2X,F8.4,2X,F8.2,8X))
99021    FORMAT (' ',I6,2X,I6,2X,I6)
      ENDIF
99022 FORMAT (' ',                                                      &
     &'I = LENGTH OF RUN         VALUE OF STAT        EXP(STAT)         &
     &   SD(STAT)    (STAT-EXP(STAT))/SD(STAT)')
99023 FORMAT (' ',4X,I4,13X,6X,F7.1,13X,F8.4,12X,F8.4,11X,F8.2)
99024 FORMAT ('1')
99025 FORMAT (' ')
      END SUBROUTINE RUNS
!*==sampp.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE SAMPP(X,N,P,Iwrite,Pp)
      IMPLICIT NONE
!*--SAMPP27037
!*** Start of declarations inserted by SPAG
      REAL aj , ajint , an , anp1 , hold , hunp , P , Pp , w , WS , X , &
     &     Y
      INTEGER i , ipr , iupper , Iwrite , j , jp1 , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT SAMPP
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE 100P PERCENT POINT
!              (WHERE P IS BETWEEN 0.0 AND 1.0, EXCLUSIVELY)
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE SAMPLE 100P PERCENT POINT =  IS THAT POINT IN WHICH
!              100P PERCENT OF THE DATA IN THE SAMPLE IS BELOW.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --P      = THE SINGLE PRECISION FRACTION VALUE
!                                (BETWEEN 0.0 AND 1.0, EXCLUSIVELY)
!                                WHICH DEFINES THE DESIRED PERCENT
!                                POINT TO BE COMPUTED.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE 100P PERCENT POINT
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE 100P PERCENT POINT
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--PP     = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE 100P PERCENT POINT.
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE 100P PERCENT POINT.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 15000.
!                 --THE INPUT ARGUMENTS N AND P SHOULD BE SUCH THAT
!                   THE PRODUCT OF N+1 AND P IS NOT SMALLER THAN 1 NOR
!                   LARGER THAN N.  THIS RESTRICTION IS DUE TO THE
!                   INTRINSIC DIFFICULTY OF ESTIMATING
!                   SAMPLE PERCENT POINTS SMALLER THAN THE OBSERVED
!                   SAMPLE MINIMUM OR LARGER THAN THE OBSERVED
!                   SAMPLE MAXIMUM.
!                   IF (N+1)P IS SMALLER THAN 1, AN ERROR MESSAGE WILL
!                   BE PRINTED OUT AND PP WILL BE SET TO -999999999.0
!                   IF(N+1)P IS LARGER THAN N, AN ERROR MESSAGE WILL
!                   BE PRINTED OUT AND PP WILL BE SET TO 999999999.0.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGES 236-239,
!                 243.
!               --MOOD AND GRABLE, 'INTRODUCTION TO THE THEORY
!                 OF STATISTICS, EDITION 2, 1963, PAGES 406-407.
!               --SNEDECOR AND COCHRAN, STATISTICAL METHODS,
!                 EDITION 6, 1967, PAGE 125.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--DECEMBER  1974.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(15000)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
!
      ipr = 6
      iupper = 15000
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      an = N
      anp1 = N + 1
      aj = P*anp1
      j = aj
      jp1 = j + 1
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE SAMPP  SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE SAMP&
     &P  SUBROUTINE HAS THE VALUE 1 *****')
         Pp = X(1)
         RETURN
      ELSEIF ( j<1 ) THEN
         WRITE (ipr,99004)
99004    FORMAT (' ','THE THIRD INPUT ARGUMENT IS SMALLER THAN 1/(N+1)',&
     &           ' = 1/(SECOND INPUT ARGUMENT + 1)')
         WRITE (ipr,99008) N , P
         Pp = -999999999.0
         RETURN
      ELSEIF ( jp1>N ) THEN
         WRITE (ipr,99005)
99005    FORMAT (' ','THE THIRD INPUT ARGUMENT IS LARGER THAN N/(N+1)', &
     &          ' = (SECOND INPUT ARGUMENT)/(SECOND INPUT ARGUMENT + 1)'&
     &          )
         WRITE (ipr,99008) N , P
         Pp = 999999999.0
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99006) hold
99006    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE SAMPP  SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
 50      CALL SORT(X,N,Y)
!
         ajint = j
         w = 1.0 - (aj-ajint)
         Pp = w*Y(j) + (1.0-w)*Y(jp1)
!
         hunp = 100.0*P
         IF ( Iwrite==0 ) RETURN
         WRITE (ipr,99007) hunp , N , Pp
99007    FORMAT (' ','THE EMPIRICAL ',F9.5,' PERCENT POINT OF THE ',I6, &
     &           ' OBSERVATIONS IS ',F16.7)
      ENDIF
99008 FORMAT (' ','*****THE VALUE OF THE SECOND INPUT ARGUMENT = ',I8,  &
     &        '  THE VALUE OF THE THIRD INPUT ARGUMENT = ',E20.10,      &
     &        '*****')
!
      END SUBROUTINE SAMPP
!*==scale.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE SCALE(X,N)
      IMPLICIT NONE
!*--SCALE27191
!*** Start of declarations inserted by SPAG
      REAL an , hold , sum , X , xmax , xmean , xmin , xrange , xrelsd ,&
     &     xsd , xvar
      INTEGER i , ipr , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT SCALE
!
!     PURPOSE--THIS SUBROUTINE COMPUTES 4 ESTIMATES OF THE
!              SCALE (VARIATION, SCATTER, DISPERSION)
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE 4 ESTIMATORS EMPLOYED ARE--
!              1) THE SAMPLE RANGE;
!              2) THE SAMPLE STANDARD DEVIATION;
!              3) THE SAMPLE RELATIVE STANDARD DEVIATION; AND
!              4) THE SAMPLE VARIANCE.
!              NOTE THAT N-1 (RATHER THAN N)
!              IS USED IN THE DIVISOR IN THE
!              COMPUTATION OF THE SAMPLE STANDARD
!              DEVIATION, THE SAMPLE RELATIVE
!              STANDARD DEVIATION, AND THE
!              SAMPLE VARIANCE.
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS.
!                      N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--1/4 PAGE OF AUTOMATIC OUTPUT
!             CONSISTING OF THE FOLLOWING 4
!             ESTIMATES OF SCALE
!             FOR THE DATA IN THE INPUT VECTOR X--
!             1) THE SAMPLE RANGE;
!             2) THE SAMPLE STANDARD DEVIATION;
!             3) THE SAMPLE RELATIVE STANDARD DEVIATION; AND
!             4) THE SAMPLE VARIANCE.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--THE SAMPLE RELATIVE STANDARD DEVIATION
!              IS THE SAMPLE STANDARD DEVIATION RELATIVE
!              TO THE MAGNITUDE OF THE SAMPLE MEAN.
!              THE RELATIVE SAMPLE STANDARD DEVIATION
!              IS EXPRESSED AS A PERCENT.
!              THE RELATIVE SAMPLE STANDARD DEVIATION
!              IS EQUIVALENTLY CALLED THE
!              SAMPLE COEFFICIENT OF VARIATION.
!     REFERENCES--DIXON AND MASSEY, PAGES 19 AND 21
!               --SNEDECOR AND COCHRAN, PAGE 62
!               --DIXON AND MASSEY, PAGES 14, 70, AND 71
!               --CROW, JOURNAL OF THE AMERICAN STATISTICAL ASSOCIATION,
!                 PAGES 357 AND 387
!               --KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGE 8.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      xrange = 0.0
      xsd = 0.0
      xrelsd = 0.0
      xvar = 0.0
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE SCALE  SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE SCAL&
     &E  SUBROUTINE HAS THE VALUE 1 *****')
            xrange = 0.0
            xsd = 0.0
            xrelsd = 0.0
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 20
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE SCALE  SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
 20         an = N
!
!     DETERMINE THE SAMPLE MINIMUM AND THE SAMPLE MAXIMUM,
!     THEN COMPUTE THE SAMPLE RANGE.
!
            xmin = X(1)
            xmax = X(1)
            DO i = 1 , N
               IF ( X(i)<xmin ) xmin = X(i)
               IF ( X(i)>xmax ) xmax = X(i)
            ENDDO
            xrange = xmax - xmin
!
!     COMPUTE THE SAMPLE VARIANCE,
!     AND THEN THE SAMPLE STANDARDD DEVIATION.
!
            sum = 0.0
            DO i = 1 , N
               sum = sum + X(i)
            ENDDO
            xmean = sum/an
            sum = 0.0
            DO i = 1 , N
               sum = sum + (X(i)-xmean)**2
            ENDDO
            xvar = sum/(an-1.0)
            xsd = SQRT(xvar)
!
!     COMPUTE THE SAMPLE RELATIVE STANDARD DEVIATION;
!     THAT IS, THE SAMPLE STANDARD DEVIATION RELATIVE
!     TO THE MAGNITUDE OF THE SAMPLE MEAN.
!     THE RESULTING SAMPLE STANDARD DEVIATION IS EXPRESSED
!     AS A PERCENT.
!
            xrelsd = 100.0*xsd/xmean
            IF ( xrelsd<0.0 ) xrelsd = -xrelsd
         ENDIF
!
!     WRITE EVERYTHING OUT
!
         DO i = 1 , 5
            WRITE (ipr,99011)
         ENDDO
         WRITE (ipr,99005)
!
99005    FORMAT (' ',30X,'ESTIMATES OF THE SCALE PARAMETER')
         WRITE (ipr,99011)
         WRITE (ipr,99006) N
99006    FORMAT (' ',34X,'(THE SAMPLE SIZE N = ',I5,')')
         WRITE (ipr,99011)
         WRITE (ipr,99011)
         WRITE (ipr,99007) xrange
99007    FORMAT (' ','THE SAMPLE RANGE IS                       ',E15.8)
         WRITE (ipr,99008) xsd
99008    FORMAT (' ','THE SAMPLE STANDARD DEVIATION IS          ',E15.8)
         WRITE (ipr,99009) xvar
99009    FORMAT (' ','THE SAMPLE VARIANCE IS                    ',E15.8)
         WRITE (ipr,99010) xrelsd
99010    FORMAT (' ','THE SAMPLE RELATIVE STANDARD DEVIATION IS ',E15.8,&
     &           ' PERCENT')
      ENDIF
99011 FORMAT (' ')
!
      END SUBROUTINE SCALE
!*==sd.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE SD(X,N,Iwrite,Xsd)
      IMPLICIT NONE
!*--SD27364
!*** Start of declarations inserted by SPAG
      REAL an , hold , sum , var , X , xmean , Xsd
      INTEGER i , ipr , Iwrite , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT SD
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE STANDARD DEVIATION (WITH DENOMINATOR N-1)
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE SAMPLE STANDARD DEVIATION = SQRT((THE SUM OF THE
!              SQUARED DEVIATIONS ABOUT THE SAMPLE MEAN)/(N-1)).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE STANDARD DEVIATION
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE STANDARD DEVIATION
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XSD    = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE STANDARD DEVIATION.
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE STANDARD DEVIATION (WITH DENOMINATOR N-1).
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--SNEDECOR AND COCHRAN, STATISTICAL METHODS,
!                 EDITION 6, 1967, PAGE 44.
!               --DIXON AND MASSEY, INTRODUCTION TO STATISTICAL
!                 ANALYSIS, EDITION 2, 1957, PAGES 19, 76.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      an = N
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE SD     SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE SD  &
     &   SUBROUTINE HAS THE VALUE 1 *****')
            Xsd = 0.0
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE SD     SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            Xsd = 0.0
         ENDIF
         GOTO 100
!
!-----START POINT-----------------------------------------------------
!
 50      sum = 0.0
         DO i = 1 , N
            sum = sum + X(i)
         ENDDO
         xmean = sum/an
         sum = 0.0
         DO i = 1 , N
            sum = sum + (X(i)-xmean)**2
         ENDDO
         var = sum/(an-1.0)
         Xsd = SQRT(var)
      ENDIF
!
 100  IF ( Iwrite==0 ) RETURN
      WRITE (ipr,99005)
99005 FORMAT (' ')
      WRITE (ipr,99006) N , Xsd
99006 FORMAT (' ','THE SAMPLE STANDARD DEVIATION OF THE ',I6,           &
     &        ' OBSERVATIONS IS ',E15.8)
      END SUBROUTINE SD
!*==skipr.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE SKIPR(Nlhead)
      IMPLICIT NONE
!*--SKIPR27480
!*** Start of declarations inserted by SPAG
      INTEGER i , ia , ipr , ird , Nlhead
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT SKIPR
!
!     PURPOSE--THIS SUBROUTINE READS THROUGH (SKIPS OVER)
!              NLHEAD LINES FROM INPUT UNIT = 5.
!              IF HEADER INFORMATION EXISTS AT THE
!              BEGINNING OF A DATA FILE, THIS SUBROUTINE
!              IS CONVENIENT FOR READING THROUGH
!              (SKIPPING OVER) THAT HEADER INFORMATION.
!     INPUT  ARGUMENTS--NLHEAD = THE INTEGER NUMBER OF CARD
!                                IMAGES TO BE READ THROUGH
!                                (SKIPPED OVER).
!     OUTPUT--NONE.
!     PRINTING--NO.
!     RESTRICTIONS--NLHEAD IS A NON-NEGATIVE INTEGER VARIABLE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--INTEGER.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --MAY       1976.
!     UPDATED         --OCTOBER   1976.
!
!---------------------------------------------------------------------
!
      ird = 5
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( Nlhead<0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE SKIPR  SUBROU&
     &TINE IS NEGATIVE *****')
         WRITE (ipr,99002) Nlhead
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
!     SKIP OVER THE HEADER LABEL
!
         IF ( Nlhead==0 ) RETURN
         DO i = 1 , Nlhead
            READ (ird,99003) ia
99003       FORMAT (A1)
         ENDDO
      ENDIF
!
      END SUBROUTINE SKIPR
!*==sortc.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE SORTC(X,Y,N,Xs,Yc)
      IMPLICIT NONE
!*--SORTC27777
!*** Start of declarations inserted by SPAG
      REAL amed , bmed , hold , tx , ty , X , Xs , Y , Yc
      INTEGER i , il , ip1 , ipr , iu , j , jmi , jmk , k , l , lmi ,   &
     &        m , mid , N , nm1
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT SORTC
!
!     PURPOSE--THIS SUBROUTINE SORTS (IN ASCENDING ORDER)
!              THE N ELEMENTS OF THE SINGLE PRECISION VECTOR X,
!              PUTS THE RESULTING N SORTED VALUES INTO THE
!              SINGLE PRECISION VECTOR XS,
!              REARRANGES THE ELEMENTS OF THE VECTOR Y
!              (ACCORDING TO THE SORT ON X),
!              AND PUTS THE REARRANGED Y VALUES
!              INTO THE SINGLE PRECISION VECTOR YC.
!              THIS SUBROUTINE GIVES THE DATA ANALYST
!              THE ABILITY TO SORT ONE DATA VECTOR
!              WHILE 'CARRYING ALONG' THE ELEMENTS
!              OF A SECOND DATA VECTOR.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                OBSERVATIONS TO BE SORTED.
!                     --Y      = THE SINGLE PRECISION VECTOR OF
!                                OBSERVATIONS TO BE 'CARRIED ALONG',
!                                THAT IS, TO BE REARRANGED ACCORDING
!                                TO THE SORT ON X.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!     OUTPUT ARGUMENTS--XS     = THE SINGLE PRECISION VECTOR
!                                INTO WHICH THE SORTED DATA VALUES
!                                FROM X WILL BE PLACED.
!                     --YC     = THE SINGLE PRECISION VECTOR
!                                INTO WHICH THE REARRANGED
!                                (ACCORDING TO THE SORT OF THE
!                                VECTOR X) VALUES OF THE VECTOR Y
!                                WILL BE PLACED.
!     OUTPUT--THE SINGLE PRECISION VECTOR XS
!             CONTAINING THE SORTED
!             (IN ASCENDING ORDER) VALUES
!             OF THE SINGLE PRECISION VECTOR X, AND
!             THE SINGLE PRECISION VECTOR YC
!             CONTAINING THE REARRANGED
!             (ACCORDING TO THE SORT ON X)
!             VALUES OF THE VECTOR Y.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THE DIMENSIONS OF THE VECTORS IL AND IU
!                   (DEFINED AND USED INTERNALLY WITHIN
!                   THIS SUBROUTINE) DICTATE THE MAXIMUM
!                   ALLOWABLE VALUE OF N FOR THIS SUBROUTINE.
!                   IF IL AND IU EACH HAVE DIMENSION K,
!                   THEN N MAY NOT EXCEED 2**(K+1) - 1.
!                   FOR THIS SUBROUTINE AS WRITTEN, THE DIMENSIONS
!                   OF IL AND IU HAVE BEEN SET TO 36,
!                   THUS THE MAXIMUM ALLOWABLE VALUE OF N IS
!                   APPROXIMATELY 137 BILLION.
!                   SINCE THIS EXCEEDS THE MAXIMUM ALLOWABLE
!                   VALUE FOR AN INTEGER VARIABLE IN MANY COMPUTERS,
!                   AND SINCE A SORT OF 137 BILLION ELEMENTS
!                   IS PRESENTLY IMPRACTICAL AND UNLIKELY,
!                   THEN THERE IS NO PRACTICAL RESTRICTION
!                   ON THE MAXIMUM VALUE OF N FOR THIS SUBROUTINE.
!                   (IN LIGHT OF THE ABOVE, NO CHECK OF THE
!                   UPPER LIMIT OF N HAS BEEN INCORPORATED
!                   INTO THIS SUBROUTINE.)
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--THE SMALLEST ELEMENT OF THE VECTOR X
!              WILL BE PLACED IN THE FIRST POSITION
!              OF THE VECTOR XS,
!              THE SECOND SMALLEST ELEMENT IN THE VECTOR X
!              WILL BE PLACED IN THE SECOND POSITION
!              OF THE VECTOR XS,
!              ETC.
!     COMMENT--THE ELEMENT IN THE VECTOR Y CORRESPONDING
!              TO THE SMALLEST ELEMENT IN X
!              WILL BE PLACED IN THE FIRST POSITION
!              OF THE VECTOR YC,
!              THE ELEMENT IN THE VECTOR Y CORRESPONDING
!              TO THE SECOND SMALLEST ELEMENT IN X
!              WILL BE PLACED IN THE SECOND POSITION
!              OF THE VECTOR YC,
!              ETC.
!     COMMENT--THE INPUT VECTOR X REMAINS UNALTERED.
!     COMMENT--IF THE ANALYST DESIRES A SORT 'IN PLACE',
!              THIS IS DONE BY HAVING THE SAME
!              OUTPUT VECTOR AS INPUT VECTOR IN THE CALLING SEQUENCE.
!              THUS, FOR EXAMPLE, THE CALLING SEQUENCE
!              CALL SORTC(X,Y,N,X,YC)
!              IS ALLOWABLE AND WILL RESULT IN
!              THE DESIRED 'IN-PLACE' SORT.
!     COMMENT--THE SORTING ALGORTHM USED HEREIN
!              IS THE BINARY SORT.
!              THIS ALGORTHIM IS EXTREMELY FAST AS THE
!              FOLLOWING TIME TRIALS INDICATE.
!              THESE TIME TRIALS WERE CARRIED OUT ON THE
!              UNIVAC 1108 EXEC 8 SYSTEM AT NBS
!              IN AUGUST OF 1974.
!              BY WAY OF COMPARISON, THE TIME TRIAL VALUES
!              FOR THE EASY-TO-PROGRAM BUT EXTREMELY
!              INEFFICIENT BUBBLE SORT ALGORITHM HAVE
!              ALSO BEEN INCLUDED--
!              NUMBER OF RANDOM        BINARY SORT       BUBBLE SORT
!               NUMBERS SORTED
!                N = 10                 .002 SEC          .002 SEC
!                N = 100                .011 SEC          .045 SEC
!                N = 1000               .141 SEC         4.332 SEC
!                N = 3000               .476 SEC        37.683 SEC
!                N = 10000             1.887 SEC      NOT COMPUTED
!     REFERENCES--CACM MARCH 1969, PAGE 186 (BINARY SORT ALGORITHM
!                 BY RICHARD C. SINGLETON).
!               --CACM JANUARY 1970, PAGE 54.
!               --CACM OCTOBER 1970, PAGE 624.
!               --JACM JANUARY 1961, PAGE 41.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1) , Y(1) , Xs(1) , Yc(1)
      DIMENSION iu(36) , il(36)
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      ipr = 6
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE SORTC  SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE SORT&
     &C  SUBROUTINE HAS THE VALUE 1 *****')
            Xs(1) = X(1)
            Yc(1) = Y(1)
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE SORTC  SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
            DO i = 1 , N
               Xs(i) = X(i)
               Yc(i) = Y(i)
            ENDDO
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
!     COPY THE VECTOR X INTO THE VECTOR XS
 50      DO i = 1 , N
            Xs(i) = X(i)
         ENDDO
!
!     COPY THE VECTOR Y INTO THE VECTOR YS
!
         DO i = 1 , N
            Yc(i) = Y(i)
         ENDDO
!
!     CHECK TO SEE IF THE INPUT VECTOR IS ALREADY SORTED
!
         nm1 = N - 1
         DO i = 1 , nm1
            ip1 = i + 1
            IF ( Xs(i)>Xs(ip1) ) GOTO 100
         ENDDO
         RETURN
      ENDIF
 100  m = 1
      i = 1
      j = N
 200  IF ( i>=j ) GOTO 400
 300  k = i
      mid = (i+j)/2
      amed = Xs(mid)
      bmed = Yc(mid)
      IF ( Xs(i)>amed ) THEN
         Xs(mid) = Xs(i)
         Yc(mid) = Yc(i)
         Xs(i) = amed
         Yc(i) = bmed
         amed = Xs(mid)
         bmed = Yc(mid)
      ENDIF
      l = j
      IF ( Xs(j)<amed ) THEN
         Xs(mid) = Xs(j)
         Yc(mid) = Yc(j)
         Xs(j) = amed
         Yc(j) = bmed
         amed = Xs(mid)
         bmed = Yc(mid)
         IF ( Xs(i)>amed ) THEN
            Xs(mid) = Xs(i)
            Yc(mid) = Yc(i)
            Xs(i) = amed
            Yc(i) = bmed
            amed = Xs(mid)
            bmed = Yc(mid)
         ENDIF
      ENDIF
      DO
         l = l - 1
         IF ( Xs(l)<=amed ) THEN
            tx = Xs(l)
            ty = Yc(l)
            DO
               k = k + 1
               IF ( Xs(k)>=amed ) THEN
                  IF ( k<=l ) THEN
                     Xs(l) = Xs(k)
                     Yc(l) = Yc(k)
                     Xs(k) = tx
                     Yc(k) = ty
                     EXIT
                  ELSE
                     lmi = l - i
                     jmk = j - k
                     IF ( lmi<=jmk ) THEN
                        il(m) = k
                        iu(m) = j
                        j = l
                        m = m + 1
                     ELSE
                        il(m) = i
                        iu(m) = l
                        i = k
                        m = m + 1
                     ENDIF
                     GOTO 500
                  ENDIF
               ENDIF
            ENDDO
         ENDIF
      ENDDO
 400  m = m - 1
      IF ( m==0 ) RETURN
      i = il(m)
      j = iu(m)
 500  jmi = j - i
      IF ( jmi>=11 ) GOTO 300
      IF ( i==1 ) GOTO 200
      i = i - 1
      DO
         i = i + 1
         IF ( i==j ) GOTO 400
         amed = Xs(i+1)
         bmed = Yc(i+1)
         IF ( Xs(i)>amed ) THEN
            k = i
            DO
               Xs(k+1) = Xs(k)
               Yc(k+1) = Yc(k)
               k = k - 1
               IF ( amed>=Xs(k) ) THEN
                  Xs(k+1) = amed
                  Yc(k+1) = bmed
                  EXIT
               ENDIF
            ENDDO
         ENDIF
      ENDDO
      END SUBROUTINE SORTC
!*==sort.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE SORT(X,N,Y)
      IMPLICIT NONE
!*--SORT27546
!*** Start of declarations inserted by SPAG
      REAL amed , hold , tt , X , Y
      INTEGER i , il , ip1 , ipr , iu , j , jmi , jmk , k , l , lmi ,   &
     &        m , mid , N , nm1
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT SORT
!
!     PURPOSE--THIS SUBROUTINE SORTS (IN ASCENDING ORDER)
!              THE N ELEMENTS OF THE SINGLE PRECISION VECTOR X
!              AND PUTS THE RESULTING N SORTED VALUES INTO THE
!              SINGLE PRECISION VECTOR Y.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                OBSERVATIONS TO BE SORTED.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!     OUTPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR
!                                INTO WHICH THE SORTED DATA VALUES
!                                FROM X WILL BE PLACED.
!     OUTPUT--THE SINGLE PRECISION VECTOR Y
!             CONTAINING THE SORTED
!             (IN ASCENDING ORDER) VALUES
!             OF THE SINGLE PRECISION VECTOR X.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THE DIMENSIONS OF THE VECTORS IL AND IU
!                   (DEFINED AND USED INTERNALLY WITHIN
!                   THIS SUBROUTINE) DICTATE THE MAXIMUM
!                   ALLOWABLE VALUE OF N FOR THIS SUBROUTINE.
!                   IF IL AND IU EACH HAVE DIMENSION K,
!                   THEN N MAY NOT EXCEED 2**(K+1) - 1.
!                   FOR THIS SUBROUTINE AS WRITTEN, THE DIMENSIONS
!                   OF IL AND IU HAVE BEEN SET TO 36,
!                   THUS THE MAXIMUM ALLOWABLE VALUE OF N IS
!                   APPROXIMATELY 137 BILLION.
!                   SINCE THIS EXCEEDS THE MAXIMUM ALLOWABLE
!                   VALUE FOR AN INTEGER VARIABLE IN MANY COMPUTERS,
!                   AND SINCE A SORT OF 137 BILLION ELEMENTS
!                   IS PRESENTLY IMPRACTICAL AND UNLIKELY,
!                   THEN THERE IS NO PRACTICAL RESTRICTION
!                   ON THE MAXIMUM VALUE OF N FOR THIS SUBROUTINE.
!                   (IN LIGHT OF THE ABOVE, NO CHECK OF THE
!                   UPPER LIMIT OF N HAS BEEN INCORPORATED
!                   INTO THIS SUBROUTINE.)
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--THE SMALLEST ELEMENT OF THE VECTOR X
!              WILL BE PLACED IN THE FIRST POSITION
!              OF THE VECTOR Y,
!              THE SECOND SMALLEST ELEMENT IN THE VECTOR X
!              WILL BE PLACED IN THE SECOND POSITION
!              OF THE VECTOR Y, ETC.
!     COMMENT--THE INPUT VECTOR X REMAINS UNALTERED.
!     COMMENT--IF THE ANALYST DESIRES A SORT 'IN PLACE',
!              THIS IS DONE BY HAVING THE SAME
!              OUTPUT VECTOR AS INPUT VECTOR IN THE CALLING SEQUENCE.
!              THUS, FOR EXAMPLE, THE CALLING SEQUENCE
!              CALL SORT(X,N,X)
!              IS ALLOWABLE AND WILL RESULT IN
!              THE DESIRED 'IN-PLACE' SORT.
!     COMMENT--THE SORTING ALGORTHM USED HEREIN
!              IS THE BINARY SORT.
!              THIS ALGORTHIM IS EXTREMELY FAST AS THE
!              FOLLOWING TIME TRIALS INDICATE.
!              THESE TIME TRIALS WERE CARRIED OUT ON THE
!              UNIVAC 1108 EXEC 8 SYSTEM AT NBS
!              IN AUGUST OF 1974.
!              BY WAY OF COMPARISON, THE TIME TRIAL VALUES
!              FOR THE EASY-TO-PROGRAM BUT EXTREMELY
!              INEFFICIENT BUBBLE SORT ALGORITHM HAVE
!              ALSO BEEN INCLUDED--
!              NUMBER OF RANDOM        BINARY SORT       BUBBLE SORT
!               NUMBERS SORTED
!                N = 10                 .002 SEC          .002 SEC
!                N = 100                .011 SEC          .045 SEC
!                N = 1000               .141 SEC         4.332 SEC
!                N = 3000               .476 SEC        37.683 SEC
!                N = 10000             1.887 SEC      NOT COMPUTED
!     REFERENCES--CACM MARCH 1969, PAGE 186 (BINARY SORT ALGORITHM
!                 BY RICHARD C. SINGLETON).
!               --CACM JANUARY 1970, PAGE 54.
!               --CACM OCTOBER 1970, PAGE 624.
!               --JACM JANUARY 1961, PAGE 41.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1) , Y(1)
      DIMENSION iu(36) , il(36)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE SORT   SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE SORT&
     &   SUBROUTINE HAS THE VALUE 1 *****')
            Y(1) = X(1)
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE SORT   SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
            DO i = 1 , N
               Y(i) = X(i)
            ENDDO
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
!     COPY THE VECTOR X INTO THE VECTOR Y
 50      DO i = 1 , N
            Y(i) = X(i)
         ENDDO
!
!     CHECK TO SEE IF THE INPUT VECTOR IS ALREADY SORTED
!
         nm1 = N - 1
         DO i = 1 , nm1
            ip1 = i + 1
            IF ( Y(i)>Y(ip1) ) GOTO 100
         ENDDO
         RETURN
      ENDIF
 100  m = 1
      i = 1
      j = N
 200  IF ( i>=j ) GOTO 400
 300  k = i
      mid = (i+j)/2
      amed = Y(mid)
      IF ( Y(i)>amed ) THEN
         Y(mid) = Y(i)
         Y(i) = amed
         amed = Y(mid)
      ENDIF
      l = j
      IF ( Y(j)<amed ) THEN
         Y(mid) = Y(j)
         Y(j) = amed
         amed = Y(mid)
         IF ( Y(i)>amed ) THEN
            Y(mid) = Y(i)
            Y(i) = amed
            amed = Y(mid)
         ENDIF
      ENDIF
      DO
         l = l - 1
         IF ( Y(l)<=amed ) THEN
            tt = Y(l)
            DO
               k = k + 1
               IF ( Y(k)>=amed ) THEN
                  IF ( k<=l ) THEN
                     Y(l) = Y(k)
                     Y(k) = tt
                     EXIT
                  ELSE
                     lmi = l - i
                     jmk = j - k
                     IF ( lmi<=jmk ) THEN
                        il(m) = k
                        iu(m) = j
                        j = l
                        m = m + 1
                     ELSE
                        il(m) = i
                        iu(m) = l
                        i = k
                        m = m + 1
                     ENDIF
                     GOTO 500
                  ENDIF
               ENDIF
            ENDDO
         ENDIF
      ENDDO
 400  m = m - 1
      IF ( m==0 ) RETURN
      i = il(m)
      j = iu(m)
 500  jmi = j - i
      IF ( jmi>=11 ) GOTO 300
      IF ( i==1 ) GOTO 200
      i = i - 1
      DO
         i = i + 1
         IF ( i==j ) GOTO 400
         amed = Y(i+1)
         IF ( Y(i)>amed ) THEN
            k = i
            DO
               Y(k+1) = Y(k)
               k = k - 1
               IF ( amed>=Y(k) ) THEN
                  Y(k+1) = amed
                  EXIT
               ENDIF
            ENDDO
         ENDIF
      ENDDO
      END SUBROUTINE SORT
!*==sortp.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE SORTP(X,N,Y,Xpos)
      IMPLICIT NONE
!*--SORTP28062
!*** Start of declarations inserted by SPAG
      REAL amed , bmed , hold , tt , X , Xpos , Y
      INTEGER i , il , ip1 , ipr , itt , iu , j , jmi , jmk , k , l ,   &
     &        lmi , m , mid , N , nm1
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT SORTP
!
!     PURPOSE--THIS SUBROUTINE SORTS (IN ASCENDING ORDER)
!              THE N ELEMENTS OF THE SINGLE PRECISION VECTOR X,
!              PUTS THE RESULTING N SORTED VALUES INTO THE
!              SINGLE PRECISION VECTOR Y,
!              AND PUTS THE POSITION (IN THE ORIGINAL VECTOR X)
!              OF EACH OF THE SORTED VALUES.
!              INTO THE SINGLE PRECISION VECTOR XPOS.
!              THIS SUBROUTINE GIVES THE DATA ANALYST
!              NOT ONLY THE ABILITY TO DETERMINE
!              WHAT THE MIN AND MAX (FOR EXAMPLE)
!              OF THE DATA SET ARE, BUT ALSO
!              WHERE IN THE ORIGINAL DATA SET
!              THE MIN AND MAX OCCUR.
!              THIS IS ESPECIALLY USEFUL FOR
!              LARGE DATA SETS.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                OBSERVATIONS TO BE SORTED.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!     OUTPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR
!                                INTO WHICH THE SORTED DATA VALUES
!                                FROM X WILL BE PLACED.
!                     --XPOS   = THE SINGLE PRECISION VECTOR
!                                INTO WHICH THE POSITIONS
!                                (IN THE ORIGINAL VECTOR X)
!                                OF THE SORTED VALUES
!                                WILL BE PLACED.
!     OUTPUT--THE SINGLE PRECISION VECTOR XS
!             CONTAINING THE SORTED
!             (IN ASCENDING ORDER) VALUES
!             OF THE SINGLE PRECISION VECTOR X, AND
!             THE SINGLE PRECISION VECTOR XPOS
!             CONTAINING THE POSITIONS
!             (IN THE ORIGINAL VECTOR X)
!             OF THE SORTED VALUES.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THE DIMENSIONS OF THE VECTORS IL AND IU
!                   (DEFINED AND USED INTERNALLY WITHIN
!                   THIS SUBROUTINE) DICTATE THE MAXIMUM
!                   ALLOWABLE VALUE OF N FOR THIS SUBROUTINE.
!                   IF IL AND IU EACH HAVE DIMENSION K,
!                   THEN N MAY NOT EXCEED 2**(K+1) - 1.
!                   FOR THIS SUBROUTINE AS WRITTEN, THE DIMENSIONS
!                   OF IL AND IU HAVE BEEN SET TO 36,
!                   THUS THE MAXIMUM ALLOWABLE VALUE OF N IS
!                   APPROXIMATELY 137 BILLION.
!                   SINCE THIS EXCEEDS THE MAXIMUM ALLOWABLE
!                   VALUE FOR AN INTEGER VARIABLE IN MANY COMPUTERS,
!                   AND SINCE A SORT OF 137 BILLION ELEMENTS
!                   IS PRESENTLY IMPRACTICAL AND UNLIKELY,
!                   THEN THERE IS NO PRACTICAL RESTRICTION
!                   ON THE MAXIMUM VALUE OF N FOR THIS SUBROUTINE.
!                   (IN LIGHT OF THE ABOVE, NO CHECK OF THE
!                   UPPER LIMIT OF N HAS BEEN INCORPORATED
!                   INTO THIS SUBROUTINE.)
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--THE SMALLEST ELEMENT OF THE VECTOR X
!              WILL BE PLACED IN THE FIRST POSITION
!              OF THE VECTOR Y,
!              THE SECOND SMALLEST ELEMENT IN THE VECTOR X
!              WILL BE PLACED IN THE SECOND POSITION
!              OF THE VECTOR Y,
!              ETC.
!     COMMENT--THE POSITION (1 THROUGH N) IN X
!              OF THE SMALLEST ELEMENT IN X
!              WILL BE PLACED IN THE FIRST POSITION
!              OF THE VECTOR XPOS,
!              THE POSITION (1 THROUGH N) IN X
!              OF THE SECOND SMALLEST ELEMENT IN X
!              WILL BE PLACED IN THE SECOND POSITION
!              OF THE VECTOR XPOS,
!              ETC.
!              ALTHOUGH THESE POSITIONS ARE NECESSARILY
!              INTEGRAL VALUES FROM 1 TO N, IT IS TO BE
!              NOTED THAT THEY ARE OUTPUTED AS SINGLE
!              PRECISION INTEGERS IN THE SINGLE PRECISION
!              VECTOR XPOS.
!              XPOS IS SINGLE PRECISION SO AS TO BE
!              CONSISTENT WITH THE FACT THAT ALL
!              VECTOR ARGUMENTS IN ALL OTHER
!              DATAPAC SUBROUTINES ARE SINGLE PRECISION.
!     COMMENT--THE INPUT VECTOR X REMAINS UNALTERED.
!     COMMENT--IF THE ANALYST DESIRES A SORT 'IN PLACE',
!              THIS IS DONE BY HAVING THE SAME
!              OUTPUT VECTOR AS INPUT VECTOR IN THE CALLING SEQUENCE.
!              THUS, FOR EXAMPLE, THE CALLING SEQUENCE
!              CALL SORTP(X,N,X,XPOS)
!              IS ALLOWABLE AND WILL RESULT IN
!              THE DESIRED 'IN-PLACE' SORT.
!     COMMENT--THE SORTING ALGORTHM USED HEREIN
!              IS THE BINARY SORT.
!              THIS ALGORTHIM IS EXTREMELY FAST AS THE
!              FOLLOWING TIME TRIALS INDICATE.
!              THESE TIME TRIALS WERE CARRIED OUT ON THE
!              UNIVAC 1108 EXEC 8 SYSTEM AT NBS
!              IN AUGUST OF 1974.
!              BY WAY OF COMPARISON, THE TIME TRIAL VALUES
!              FOR THE EASY-TO-PROGRAM BUT EXTREMELY
!              INEFFICIENT BUBBLE SORT ALGORITHM HAVE
!              ALSO BEEN INCLUDED--
!              NUMBER OF RANDOM        BINARY SORT       BUBBLE SORT
!               NUMBERS SORTED
!                N = 10                 .002 SEC          .002 SEC
!                N = 100                .011 SEC          .045 SEC
!                N = 1000               .141 SEC         4.332 SEC
!                N = 3000               .476 SEC        37.683 SEC
!                N = 10000             1.887 SEC      NOT COMPUTED
!     REFERENCES--CACM MARCH 1969, PAGE 186 (BINARY SORT ALGORITHM
!                 BY RICHARD C. SINGLETON).
!               --CACM JANUARY 1970, PAGE 54.
!               --CACM OCTOBER 1970, PAGE 624.
!               --JACM JANUARY 1961, PAGE 41.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1) , Y(1) , Xpos(1)
      DIMENSION iu(36) , il(36)
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      ipr = 6
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE SORTP  SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE SORT&
     &P  SUBROUTINE HAS THE VALUE 1 *****')
            Y(1) = X(1)
            Xpos(1) = 1.0
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE SORTP  SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
            DO i = 1 , N
               Y(i) = X(i)
               Xpos(i) = i
            ENDDO
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
!     COPY THE VECTOR X INTO THE VECTOR Y
 50      DO i = 1 , N
            Y(i) = X(i)
         ENDDO
!
!     DEFINE THE XPOS (POSITION) VECTOR.  BEFORE SORTING, THIS WILL
!     BE A VECTOR WHOSE I-TH ELEMENT IS EQUAL TO I.
!
         DO i = 1 , N
            Xpos(i) = i
         ENDDO
!
!     CHECK TO SEE IF THE INPUT VECTOR IS ALREADY SORTED
!
         nm1 = N - 1
         DO i = 1 , nm1
            ip1 = i + 1
            IF ( Y(i)>Y(ip1) ) GOTO 100
         ENDDO
         RETURN
      ENDIF
 100  m = 1
      i = 1
      j = N
 200  IF ( i>=j ) GOTO 400
 300  k = i
      mid = (i+j)/2
      amed = Y(mid)
      bmed = Xpos(mid)
      IF ( Y(i)>amed ) THEN
         Y(mid) = Y(i)
         Xpos(mid) = Xpos(i)
         Y(i) = amed
         Xpos(i) = bmed
         amed = Y(mid)
         bmed = Xpos(mid)
      ENDIF
      l = j
      IF ( Y(j)<amed ) THEN
         Y(mid) = Y(j)
         Xpos(mid) = Xpos(j)
         Y(j) = amed
         Xpos(j) = bmed
         amed = Y(mid)
         bmed = Xpos(mid)
         IF ( Y(i)>amed ) THEN
            Y(mid) = Y(i)
            Xpos(mid) = Xpos(i)
            Y(i) = amed
            Xpos(i) = bmed
            amed = Y(mid)
            bmed = Xpos(mid)
         ENDIF
      ENDIF
      DO
         l = l - 1
         IF ( Y(l)<=amed ) THEN
            tt = Y(l)
            itt = Xpos(l)
            DO
               k = k + 1
               IF ( Y(k)>=amed ) THEN
                  IF ( k<=l ) THEN
                     Y(l) = Y(k)
                     Xpos(l) = Xpos(k)
                     Y(k) = tt
                     Xpos(k) = itt
                     EXIT
                  ELSE
                     lmi = l - i
                     jmk = j - k
                     IF ( lmi<=jmk ) THEN
                        il(m) = k
                        iu(m) = j
                        j = l
                        m = m + 1
                     ELSE
                        il(m) = i
                        iu(m) = l
                        i = k
                        m = m + 1
                     ENDIF
                     GOTO 500
                  ENDIF
               ENDIF
            ENDDO
         ENDIF
      ENDDO
 400  m = m - 1
      IF ( m==0 ) RETURN
      i = il(m)
      j = iu(m)
 500  jmi = j - i
      IF ( jmi>=11 ) GOTO 300
      IF ( i==1 ) GOTO 200
      i = i - 1
      DO
         i = i + 1
         IF ( i==j ) GOTO 400
         amed = Y(i+1)
         bmed = Xpos(i+1)
         IF ( Y(i)>amed ) THEN
            k = i
            DO
               Y(k+1) = Y(k)
               Xpos(k+1) = Xpos(k)
               k = k - 1
               IF ( amed>=Y(k) ) THEN
                  Y(k+1) = amed
                  Xpos(k+1) = bmed
                  EXIT
               ENDIF
            ENDDO
         ENDIF
      ENDDO
      END SUBROUTINE SORTP
!*==spcorr.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE SPCORR(X,Y,N,Iwrite,Spc)
      IMPLICIT NONE
!*--SPCORR28356
!*** Start of declarations inserted by SPAG
      REAL an , hold , Spc , sum , WS , X , XR , Y , YR
      INTEGER i , iflag , ipr , iupper , Iwrite , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT SPCORR
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SPEARMAN RANK CORRELATION COEFFICIENT
!              BETWEEN THE 2 SETS OF DATA IN THE INPUT VECTORS X AND Y.
!              THE SPEARMAN RANK CORRELATION COEFFICIENT WILL BE A
!              SINGLE PRECISION VALUE BETWEEN -1.0 AND 1.0
!              (INCLUSIVELY).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS
!                                WHICH CONSTITUTE THE FIRST SET
!                                OF DATA.
!                     --Y      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS
!                                WHICH CONSTITUTE THE SECOND SET
!                                OF DATA.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X, OR EQUIVALENTLY,
!                                THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR Y.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SPEARMAN RANK CORRELATION COEFFICIENT
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SPEARMAN CORRELATION COEFFICIENT
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--SPC    = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SPEARMAN RANK CORRELATION
!                                COEFFICIENT BETWEEN THE 2 SETS OF DATA
!                                IN THE INPUT VECTORS X AND Y.
!                                THIS SINGLE PRECISION VALUE
!                                WILL BE BETWEEN -1.0 AND 1.0
!                                (INCLUSIVELY).
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SPEARMAN RANK CORRELATION COEFFICIENT BETWEEN THE 2 SETS
!             OF DATA IN THE INPUT VECTORS X AND Y.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--RANK AND SORT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 2, EDITION 1, 1961, PAGES 476-477.
!               --SNEDECOR AND COCHRAN, STATISTICAL METHODS,
!                 EDITION 6, 1967, PAGES 193-195.
!               --DIXON AND MASSEY, INTRODUCTION TO STATISTICAL
!                 ANALYSIS, EDITION 2, 1957, PAGES 294-295.
!               --MOOD AND GRABLE, 'INTRODUCTION TO THE THEORY
!                 OF STATISTICS, EDITION 2, 1963, PAGE 424.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --OCTOBER   1974.
!     UPDATED         --JANUARY   1975.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1) , Y(1)
      DIMENSION XR(7500) , YR(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (XR(1),WS(1))
      EQUIVALENCE (YR(1),WS(7501))
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      an = N
      Spc = 0.0
      iflag = 0
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (                                                       &
     &         ' ***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE SP'&
     &         ,                                                        &
     & 'CORR SUBROUTINE IS OUTSIDE THE ALLOWABLE (1,,I6,16H) INTERVAL *'&
     & ,'****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE THIRD  INPUT ARGUMENT TO THE SPCO&
     &RR SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE SPCORR SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
         iflag = 1
 50      hold = Y(1)
         DO i = 2 , N
            IF ( Y(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99005) hold
99005    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT (A VECTOR) &
     &TO THE SPCORR SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
         iflag = 1
 100     IF ( iflag==1 ) RETURN
!
!-----START POINT-----------------------------------------------------
!
         CALL RANK(X,N,XR)
         CALL RANK(Y,N,YR)
         sum = 0.0
         DO i = 1 , N
            sum = sum + (XR(i)-YR(i))**2
         ENDDO
         Spc = 1.0 - (6.0*sum/((an-1.0)*an*(an+1.0)))
!
         IF ( Iwrite/=0 ) WRITE (ipr,99006) N , Spc
99006    FORMAT (' ',                                                   &
     &     'THE SPEARMAN RANK CORRELATION COEFFICIENT OF THE 2 SETS OF '&
     &     ,I6,' OBSERVATIONS IS ',F14.5)
      ENDIF
      END SUBROUTINE SPCORR
!*==stmom3.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE STMOM3(X,N,Iwrite,Xsmom3)
      IMPLICIT NONE
!*--STMOM328504
!*** Start of declarations inserted by SPAG
      REAL an , hold , sum , sum2 , sum3 , vb , X , xmean , Xsmom3
      INTEGER i , ipr , Iwrite , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT STMOM3
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE STANDARDIZED THIRD CENTRAL MOMENT
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE SAMPLE STANDARDIZED THIRD CENTRAL MOMENT =
!              (THE SAMPLE THIRD CENTRAL MOMENT)/((THE SAMPLE
!              STANDARD DEVIATION)**3).
!              N (RATHER THAN N-1) HAS BEEN USED IN THE DENOMINATOR
!              IN THE CALCULATION OF BOTH THE SAMPLE THIRD CENTRAL
!              MOMENT AND THE SAMPLE STANDARD DEVIATION.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE STANDARDIZED THIRD CENTRAL
!                                MOMENT AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE STANDARDIZED THIRD CENTRAL
!                                MOMENT AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XSMOM3 = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE STANDARDIZED THIRD
!                                CENTRAL MOMENT.
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE STANDARDIZED THIRD CENTRAL MOMENT.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGES 85,
!                 234, 243, 297-298, 305.
!               --SNEDECOR AND COCHRAN, STATISTICAL METHODS,
!                 EDITION 6, 1967, PAGES 86-90.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      an = N
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE STMOM3 SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE STMO&
     &M3 SUBROUTINE HAS THE VALUE 1 *****')
            Xsmom3 = 0.0
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE STMOM3 SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            Xsmom3 = 0.0
         ENDIF
         GOTO 100
!
!-----START POINT-----------------------------------------------------
!
 50      sum = 0.0
         DO i = 1 , N
            sum = sum + X(i)
         ENDDO
         xmean = sum/an
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum2 = sum2 + (X(i)-xmean)**2
            sum3 = sum3 + (X(i)-xmean)**3
         ENDDO
         sum3 = sum3/an
         vb = sum2/an
         Xsmom3 = sum3/(vb**1.5)
      ENDIF
!
 100  IF ( Iwrite==0 ) RETURN
      WRITE (ipr,99005)
99005 FORMAT (' ')
      WRITE (ipr,99006) N , Xsmom3
99006 FORMAT (' ',                                                      &
     &        'THE SAMPLE STANDARDIZED THIRD  CENTRAL MOMENT FOR THE ', &
     &        I6,' OBSERVATIONS IS ',E15.8)
      END SUBROUTINE STMOM3
!*==stmom4.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE STMOM4(X,N,Iwrite,Xsmom4)
      IMPLICIT NONE
!*--STMOM428629
!*** Start of declarations inserted by SPAG
      REAL an , hold , sum , sum2 , sum4 , vb , X , xmean , Xsmom4
      INTEGER i , ipr , Iwrite , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT STMOM4
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE STANDARDIZED FOURTH CENTRAL MOMENT
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE SAMPLE STANDARDIZED FOURTH CENTRAL MOMENT =
!              (THE SAMPLE FOURTH CENTRAL MOMENT)/((THE SAMPLE
!              STANDARD DEVIATION)**4).
!              N (RATHER THAN N-1) HAS BEEN USED IN THE DENOMINATOR
!              IN THE CALCULATION OF BOTH THE SAMPLE FOURTH CENTRAL
!              MOMENT AND THE SAMPLE STANDARD DEVIATION.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE STANDARDIZED FOURTH CENTRAL
!                                MOMENT AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE STANDARDIZED FOURTH CENTRAL
!                                MOMENT AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XSMOM4 = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE STANDARDIZED FOURTH
!                                CENTRAL MOMENT.
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE STANDARDIZED FOURTH CENTRAL MOMENT.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--KENDALL AND STUART, THE ADVANCED THEORY OF
!                 STATISTICS, VOLUME 1, EDITION 2, 1963, PAGES 85, 243.
!               --SNEDECOR AND COCHRAN, STATISTICAL METHODS,
!                 EDITION 6, 1967, PAGES 86-90.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      an = N
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE STMOM4 SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE STMO&
     &M4 SUBROUTINE HAS THE VALUE 1 *****')
            Xsmom4 = 0.0
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE STMOM4 SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            Xsmom4 = 0.0
         ENDIF
         GOTO 100
!
!-----START POINT-----------------------------------------------------
!
 50      sum = 0.0
         DO i = 1 , N
            sum = sum + X(i)
         ENDDO
         xmean = sum/an
         sum2 = 0.0
         sum4 = 0.0
         DO i = 1 , N
            sum2 = sum2 + (X(i)-xmean)**2
            sum4 = sum4 + (X(i)-xmean)**4
         ENDDO
         vb = sum2/an
         sum4 = sum4/an
         Xsmom4 = sum4/(vb*vb)
      ENDIF
!
 100  IF ( Iwrite==0 ) RETURN
      WRITE (ipr,99005)
99005 FORMAT (' ')
      WRITE (ipr,99006) N , Xsmom4
99006 FORMAT (' ',                                                      &
     &        'THE SAMPLE STANDARDIZED FOURTH CENTRAL MOMENT FOR THE ', &
     &        I6,' OBSERVATIONS IS ',E15.8)
      END SUBROUTINE STMOM4
!*==subse1.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE SUBSE1(X,N,D,Dmin,Dmax,Y,Ny)
      IMPLICIT NONE
!*--SUBSE128754
!*** Start of declarations inserted by SPAG
      REAL D , Dmax , Dmin , hold , pointl , pointu , X , Y
      INTEGER i , ipr , k , N , ndel , Ny
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT SUBSE1
!
!     PURPOSE--THIS SUBROUTINE CARRIES OVER INTO Y ALL OBSERVATIONS
!              OF THE SINGLE PRECISION VECTOR X FOR WHICH THE
!              CORRESPONDING ELEMENTS IN THE
!              SINGLE PRECISION VECTOR D ARE INSIDE
!              THE CLOSED (INCLUSIVE) INTERVAL
!              DEFINED BY DMIN AND DMAX,
!              WHILE NOT CARRYING OVER ANY OBSERVATIONS OF X
!              CORRESPONDING TO ELEMENTS OF D
!              OUTSIDE OF THIS INTERVAL.
!              THE INPUT VECTOR X IS ITSELF UNALTERED;
!              THOSE ELEMENTS OF X TO BE RETAINED ARE
!              COPIED OVER INTO THE SINGLE PRECISION
!              OUTPUT VECTOR Y.
!              THUS ALL OBSERVATIONS OF X WHICH
!              CORRESPOND TO ELEMENTS IN D WHICH ARE SMALLER
!              THAN DMIN OR LARGER THAN DMAX ARE
!              NOT COPIED OVER INTO Y.
!              THE USE OF THIS SUBROUTINE
!              GIVES THE DATA ANALYST THE CAPABILITY TO
!              EASILY EXTRACT SUBSETS OF THE DATA
!              PRIOR TO DATA ANALYSIS ON EACH SUBSET.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --D      = THE SINGLE PRECISION VECTOR
!                                WHICH 'DEFINES' THE VARIOUS
!                                POSSIBLE SUBSETS OF X.
!                     --DMIN   = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES THE LOWER LIMIT
!                                (INCLUSIVELY) OF THE PARTICULAR
!                                SUBSET OF INTEREST TO BE RETAINED.
!                     --DMAX   = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES THE UPPER LIMIT
!                                (INCLUSIVELY) OF THE PARTICULAR
!                                SUBSET OF INTEREST TO BE RETAINED.
!     OUTPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR
!                                CONTAINING ONLY THOSE ELEMENTS
!                                OF X CORRESPONDING TO
!                                VALUES OF THE D VECTOR
!                                IN THE INTERVAL DMIN TO DMAX
!                                (INCLUSIVE).
!                     --NY     = THE INTEGER NUMBER OF RETAINED
!                                OBSERVATIONS COPIED INTO
!                                THE VECTOR Y.
!     OUTPUT--THE SINGLE PRECISION VECTOR Y
!             INTO WHICH HAVE BEEN COPIED
!             ONLY THOSE VALUES OF X WHICH
!             CORRESPOND TO VALUES
!             IN THE D VECTOR INSIDE
!             (INCLUSIVELY) THE INTERVAL OF
!             INTEREST, AND
!             THE INTEGER VALUE NY
!             WHICH GIVES THE NUMBER OF
!             OBSERVATIONS COPIED INTO Y.
!             ALSO, 12 LINES OF SUMMARY INFORMATION
!             WILL BE GENERATED INDICATING
!             1) WHAT THE INTERVAL OF INTEREST WAS
!                IN THE D VECTOR;
!             2) HOW MANY OBSERVATIONS WERE DELETED;
!             3) WHAT THE SAMPLE SIZE OF X WAS (N);
!             4) WHAT THE SAMPLE SIZE OF Y WAS (NY);
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--THE INPUT VECTOR X IS NOT ALTERED
!              BY APPLICATION OF THIS SUBROUTINE.
!              THIS IS THE MAJOR DISTINCTION
!              BETWEEN THIS SUBROUTINE AND, SAY,
!              THE SUBSET SUBROUTINE.
!              IT IS THUS SEEN THAT THIS (SUBSE1)
!              SUBROUTINE IS THE PREFERABLE OF THE 2
!              (SUBSET VERSUS SUBSE1)
!              FOR HANDLING THE PROBLEM OF
!              SEQUENTIALLY EXTRACTING EACH POSSIBLE
!              SUBSET OF X (FOR THE PURPOSE OF
!              ANALYZING EACH INDIVIDUAL SUBSET).
!              INASMUCH AS THE ORIGINAL X VECTOR
!              REMAINS UNCHANGED, THE ANALYST
!              CAN ALWAYS OPERATE ON IT WITH
!              SUBSE1 IN SEQUENTIALLY EXTRACTING
!              SUBSETS OF INTEREST.
!     COMMENT--IN THE END, AFTER THIS SUBROUTINE HAS
!              MADE WHATEVER DELETIONS ARE APPROPRIATE,
!              THE OUTPUT VECTOR Y WILL BE 'PACKED';
!              THAT IS, NO 'HOLES' WILL EXIST IN THE
!              VECTOR Y--ALL OF THE RETAINED ELEMENTS
!              OF Y WILL BE PACKED INTO THE FIRST AVAILABLE
!              LOCATIONS IN Y, WHILE THE REMAINDER
!              OF THE N LOCATIONS IN Y WILL BE ZERO-FILLED.
!     COMMENT--ALTHOUGH THERE
!              MAY BE A CORRESPONDANCE BETWEEN THE
!              ELEMENTS OF THE X AND D VECTORS
!              BEFORE APPLICATION OF
!              THIS SUBROUTINE, THERE WILL
!              BE NO CORRESPONDANCE BETWEEN
!              Y AND D (DUE TO THE PACKING OF
!              THE RETAINED ELEMENTS IN Y)
!              AFTER APPLICATION OF THIS SUBROUTINE.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--APRIL     1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(1)
      DIMENSION D(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE SUBSE1 SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE SUBS&
     &E1 SUBROUTINE HAS THE VALUE 1 *****')
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE SUBSE1 SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      pointl = Dmin
         pointu = Dmax
         IF ( Dmin>Dmax ) pointl = Dmax
         IF ( Dmin>Dmax ) pointu = Dmin
!
         k = 0
         DO i = 1 , N
            IF ( D(i)>=pointl .AND. D(i)<=pointu ) THEN
               k = k + 1
               Y(k) = X(i)
            ENDIF
         ENDDO
         Ny = k
         ndel = N - Ny
!
!     WRITE OUT A BRIEF SUMMARY
!
         WRITE (ipr,99005)
99005    FORMAT (' ')
         WRITE (ipr,99006)
99006    FORMAT (' ','OUTPUT FROM THE SUBSE1 SUBROUTINE--')
         WRITE (ipr,99007) pointl , pointu
99007    FORMAT (' ',7X,'D1 LIMITS (INCLUSIVE)--   ',E15.8,' AND ',     &
     &           E15.8)
         WRITE (ipr,99008)
99008    FORMAT (' ',7X,'ONLY THOSE OBSERVATIONS IN X')
         WRITE (ipr,99009)
99009    FORMAT (' ',7X,'WILL BE CARRIED OVER INTO Y')
         WRITE (ipr,99010)
99010    FORMAT (' ',7X,'FOR WHICH THE CORRESPONDING ELEMENTS OF ','D1')
         WRITE (ipr,99011)
99011    FORMAT (' ',7X,'ARE SIMULTANEOUSLY WITHIN (INCLUSIVE)')
         WRITE (ipr,99012)
99012    FORMAT (' ',7X,'EACH SPECIFIED LIMIT.')
         WRITE (ipr,99013)
99013    FORMAT (' ',7X,'NO OBSERVATIONS OUTSIDE OF THIS INTERVAL')
         WRITE (ipr,99014)
99014    FORMAT (' ',7X,'HAVE BEEN CARRIED OVER INTO Y.')
         WRITE (ipr,99015) N
99015    FORMAT (' ',7X,'THE INPUT  NUMBER OF OBSERVATIONS (IN X) IS ', &
     &           I6)
         WRITE (ipr,99016) Ny
99016    FORMAT (' ',7X,'THE OUTPUT NUMBER OF OBSERVATIONS (IN Y) IS ', &
     &           I6)
         WRITE (ipr,99017) ndel
99017    FORMAT (' ',7X,'THE NUMBER OF OBSERVATIONS DELETED       IS ', &
     &           I6)
      ENDIF
!
      END SUBROUTINE SUBSE1
!*==subse2.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE SUBSE2(X,N,D1,D1min,D1max,D2,D2min,D2max,Y,Ny)
      IMPLICIT NONE
!*--SUBSE228964
!*** Start of declarations inserted by SPAG
      REAL D1 , D1max , D1min , D2 , D2max , D2min , hold , poin1l ,    &
     &     poin1u , poin2l , poin2u , X , Y
      INTEGER i , ipr , k , N , ndel , Ny
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT SUBSE2
!
!     PURPOSE--THIS SUBROUTINE CARRIES OVER INTO Y ALL OBSERVATIONS
!              OF THE SINGLE PRECISION VECTOR X FOR WHICH THE
!              CORRESPONDING ELEMENTS IN THE
!              SINGLE PRECISION VECTOR D1 ARE INSIDE
!              THE CLOSED (INCLUSIVE) INTERVAL
!              DEFINED BY D1MIN AND D1MAX,
!              AND ALSO FOR WHICH THE
!              CORRESPONDING ELEMENTS IN THE
!              SINGLE PRECISION VECTOR D2 ARE INSIDE
!              THE CLOSED (INCLUSIVE) INTERVAL
!              DEFINED BY D2MIN AND D2MAX.
!              NO OBSERVATIONS IN X
!              CORRESPONDING TO ELEMENTS OF D1 OR D2
!              OUTSIDE OF THEIR RESPECTIVE INTERVALS
!              ARE CARRIED OVER INTO Y.
!              THE INPUT VECTOR X IS ITSELF UNALTERED;
!              THOSE ELEMENTS OF X TO BE RETAINED ARE
!              COPIED OVER INTO THE SINGLE PRECISION
!              OUTPUT VECTOR Y.
!              THUS ALL OBSERVATIONS OF X WHICH
!              CORRESPOND TO ELEMENTS IN D1 WHICH ARE SMALLER
!              THAN D1MIN OR LARGER THAN D1MAX, OR WHICH
!              CORRESPOND TO ELEMENTS IN D2 WHICH ARE SMALLER
!              THAN D2MIN OR LARGER THAN D2MAX,
!              ARE NOT COPIED OVER INTO Y.
!              THE USE OF THIS SUBROUTINE
!              GIVES THE DATA ANALYST THE CAPABILITY TO
!              EASILY EXTRACT SUBSETS OF THE DATA
!              PRIOR TO DATA ANALYSIS ON EACH SUBSET.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --D1     = A SINGLE PRECISION VECTOR
!                                WHICH (IN CONJUNCTION WITH D2)
!                                'DEFINES' THE VARIOUS
!                                POSSIBLE SUBSETS OF X.
!                     --D1MIN  = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES IN D1 THE LOWER LIMIT
!                                (INCLUSIVELY) OF THE PARTICULAR
!                                SUBSET OF INTEREST TO BE RETAINED.
!                     --D1MAX  = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES IN D1 THE UPPER LIMIT
!                                (INCLUSIVELY) OF THE PARTICULAR
!                                SUBSET OF INTEREST TO BE RETAINED.
!                     --D2     = A SINGLE PRECISION VECTOR
!                                WHICH (IN CONJUNCTION WITH D2)
!                                'DEFINES' THE VARIOUS
!                                POSSIBLE SUBSETS OF X.
!                     --D2MIN  = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES IN D2 THE LOWER LIMIT
!                                (INCLUSIVELY) OF THE PARTICULAR
!                                SUBSET OF INTEREST TO BE RETAINED.
!                     --D2MAX  = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES IN D2 THE UPPER LIMIT
!                                (INCLUSIVELY) OF THE PARTICULAR
!                                SUBSET OF INTEREST TO BE RETAINED.
!     OUTPUT ARGUMENTS--Y      = THE SINGLE PRECISION VECTOR
!                                CONTAINING ONLY THOSE ELEMENTS
!                                OF X SIMULTANEOUSLY CORRESPONDING TO
!                                VALUES OF THE D1 VECTOR
!                                IN THE INTERVAL D1MIN TO D1MAX
!                                (INCLUSIVE), AND
!                                VALUES OF THE D2 VECTOR
!                                IN THE INTERVAL D2MIN TO D2MAX
!                                (INCLUSIVE).
!                     --NY     = THE INTEGER NUMBER OF RETAINED
!                                OBSERVATIONS COPIED INTO
!                                THE VECTOR Y.
!     OUTPUT--THE SINGLE PRECISION VECTOR Y
!             INTO WHICH HAVE BEEN COPIED
!             ONLY THOSE VALUES OF X WHICH
!             SIMULTANEOUSLY CORRESPOND TO VALUES
!             IN THE D1 AND D2 VECTORS INSIDE
!             (INCLUSIVELY) THE RESPECTIVE
!             INTERVALS OF INTEREST, AND
!             THE INTEGER VALUE NY
!             WHICH GIVES THE NUMBER OF
!             OBSERVATIONS COPIED INTO Y.
!             ALSO, 13 LINES OF SUMMARY INFORMATION
!             WILL BE GENERATED INDICATING
!             1) WHAT THE INTERVAL OF INTEREST WAS
!                IN THE D1 VECTOR;
!             2) WHAT THE INTERVAL OF INTEREST WAS
!                IN THE D2 VECTOR;
!             3) HOW MANY OBSERVATIONS WERE DELETED;
!             4) WHAT THE SAMPLE SIZE OF X WAS (N);
!             5) WHAT THE SAMPLE SIZE OF Y WAS (NY);
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--THE INPUT VECTOR X IS NOT ALTERED
!              BY APPLICATION OF THIS SUBROUTINE.
!              THIS IS A MAJOR DISTINCTION
!              BETWEEN THIS SUBROUTINE AND, SAY,
!              THE SUBSET SUBROUTINE.
!     COMMENT--IN THE END, AFTER THIS SUBROUTINE HAS
!              MADE WHATEVER DELETIONS ARE APPROPRIATE,
!              THE OUTPUT VECTOR Y WILL BE 'PACKED';
!              THAT IS, NO 'HOLES' WILL EXIST IN THE
!              VECTOR Y--ALL OF THE RETAINED ELEMENTS
!              OF Y WILL BE PACKED INTO THE FIRST AVAILABLE
!              LOCATIONS IN Y, WHILE THE REMAINDER
!              OF THE N LOCATIONS IN Y WILL BE ZERO-FILLED.
!     COMMENT--ALTHOUGH THERE
!              MAY BE A CORRESPONDANCE BETWEEN
!              THE ELEMENTS OF THE X AND D1 VECTORS
!              AND ELEMENTS OF THE X AND D2 VECTORS
!              BEFORE APPLICATION OF
!              THIS SUBROUTINE, THERE WILL
!              BE NO CORRESPONDANCE BETWEEN
!              Y AND D1, AND Y AND D2
!              (DUE TO THE PACKING OF
!              THE RETAINED ELEMENTS IN Y)
!              AFTER APPLICATION OF THIS SUBROUTINE.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(1)
      DIMENSION D1(1)
      DIMENSION D2(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE SUBSE2 SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE SUBS&
     &E2 SUBROUTINE HAS THE VALUE 1 *****')
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE SUBSE2 SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      poin1l = D1min
         poin1u = D1max
         IF ( D1min>D1max ) poin1l = D1max
         IF ( D1min>D1max ) poin1u = D1min
!
         poin2l = D2min
         poin2u = D2max
         IF ( D2min>D2max ) poin2l = D2max
         IF ( D2min>D2max ) poin2u = D2min
         k = 0
         DO i = 1 , N
            IF ( D1(i)>=poin1l .AND. D1(i)<=poin1u ) THEN
               IF ( D2(i)>=poin2l .AND. D2(i)<=poin2u ) THEN
                  k = k + 1
                  Y(k) = X(i)
               ENDIF
            ENDIF
         ENDDO
         Ny = k
         ndel = N - Ny
!
!     WRITE OUT A BRIEF SUMMARY
!
         WRITE (ipr,99005)
99005    FORMAT (' ')
         WRITE (ipr,99006)
99006    FORMAT (' ','OUTPUT FROM THE SUBSE2 SUBROUTINE--')
         WRITE (ipr,99007) poin1l , poin1u
99007    FORMAT (' ',7X,'D1 LIMITS (INCLUSIVE)--   ',E15.8,' AND ',     &
     &           E15.8)
         WRITE (ipr,99008) poin2l , poin2u
99008    FORMAT (' ',7X,'D2 LIMITS (INCLUSIVE)--   ',E15.8,' AND ',     &
     &           E15.8)
         WRITE (ipr,99009)
99009    FORMAT (' ',7X,'ONLY THOSE OBSERVATIONS IN X')
         WRITE (ipr,99010)
99010    FORMAT (' ',7X,'WILL BE CARRIED OVER INTO Y')
         WRITE (ipr,99011)
99011    FORMAT (' ',7X,'FOR WHICH THE CORRESPONDING ELEMENTS OF ',     &
     &           'D1 AND D2')
         WRITE (ipr,99012)
99012    FORMAT (' ',7X,'ARE SIMULTANEOUSLY WITHIN (INCLUSIVE)')
         WRITE (ipr,99013)
99013    FORMAT (' ',7X,'EACH SPECIFIED LIMIT.')
         WRITE (ipr,99014)
99014    FORMAT (' ',7X,'NO OBSERVATIONS OUTSIDE OF THIS INTERVAL')
         WRITE (ipr,99015)
99015    FORMAT (' ',7X,'HAVE BEEN CARRIED OVER INTO Y.')
         WRITE (ipr,99016) N
99016    FORMAT (' ',7X,'THE INPUT  NUMBER OF OBSERVATIONS (IN X) IS ', &
     &           I6)
         WRITE (ipr,99017) Ny
99017    FORMAT (' ',7X,'THE OUTPUT NUMBER OF OBSERVATIONS (IN Y) IS ', &
     &           I6)
         WRITE (ipr,99018) ndel
99018    FORMAT (' ',7X,'THE NUMBER OF OBSERVATIONS DELETED       IS ', &
     &           I6)
      ENDIF
!
      END SUBROUTINE SUBSE2
!*==subset.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE SUBSET(X,N,D,Dmin,Dmax,Newn)
      IMPLICIT NONE
!*--SUBSET29201
!*** Start of declarations inserted by SPAG
      REAL D , Dmax , Dmin , hold , pointl , pointu , X
      INTEGER i , ipr , k , N , ndel , Newn , newnp1 , nold
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT SUBSET
!
!     PURPOSE--THIS SUBROUTINE RETAINS ALL OBSERVATIONS IN THE
!              SINGLE PRECISION VECTOR X FOR WHICH THE
!              CORRESPONDING ELEMENTS IN THE
!              SINGLE PRECISION VECTOR D ARE INSIDE
!              THE CLOSED (INCLUSIVE) INTERVAL
!              DEFINED BY DMIN AND DMAX,
!              WHILE DELETING ALL OBSERVATIONS IN X
!              CORRESPONDING TO ELEMENTS OF D
!              OUTSIDE OF THIS INTERVAL.
!              THUS ALL OBSERVATIONS IN X WHICH
!              CORRESPOND TO ELEMENTS IN D WHICH ARE SMALLER
!              THAN DMIN OR LARGER THAN DMAX ARE DELETED FROM X.
!              THE USE OF THIS SUBROUTINE
!              GIVES THE DATA ANALYST THE CAPABILITY TO
!              EASILY EXTRACT SUBSETS OF THE DATA
!              PRIOR TO DATA ANALYSIS ON EACH SUBSET.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --D      = THE SINGLE PRECISION VECTOR
!                                WHICH 'DEFINES' THE VARIOUS
!                                POSSIBLE SUBSETS OF X.
!                     --DMIN   = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES THE LOWER LIMIT
!                                (INCLUSIVELY) OF THE PARTICULAR
!                                SUBSET OF INTEREST TO BE RETAINED.
!                     --DMAX   = THE SINGLE PRECISION VALUE
!                                WHICH DEFINES THE UPPER LIMIT
!                                (INCLUSIVELY) OF THE PARTICULAR
!                                SUBSET OF INTEREST TO BE RETAINED.
!     OUTPUT ARGUMENTS--NEWN   = THE INTEGER NUMBER OF OBSERVATIONS
!                                REMAINING (RETAINED) IN X AFTER ALL
!                                OF THE OBSERVATIONS IN X
!                                HAVE BEEN DELETED WHICH
!                                CORRESPOND TO VALUES IN THE
!                                VECTOR D OUTSIDE THE
!                                INTERVAL OF INTEREST.
!     OUTPUT--THE SINGLE PRECISION VECTOR X
!             IN WHICH ONLY THOSE VALUES
!             HAVE BEEN RETAINED WHICH
!             CORRESPOND TO VALUES
!             IN THE D VECTOR INSIDE
!             (INCLUSIVELY) THE INTERVAL OF
!             INTEREST, AND
!             THE INTEGER VALUE NEWN
!             WHICH GIVES THE NUMBER OF
!             OBSERVATIONS RETAINED IN X.
!             ALSO, 12 LINES OF SUMMARY INFORMATION
!             WILL BE GENERATED INDICATING
!             1) WHAT THE INTERVAL OF INTEREST WAS
!                IN THE D VECTOR;
!             2) HOW MANY OBSERVATIONS WERE DELETED;
!             3) WHAT THE OLD (ORIGINAL) SAMPLE SIZE WAS (N);
!             4) WHAT THE NEW SAMPLE SIZE IS (NEWN).
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--IN THE END, AFTER THIS SUBROUTINE HAS
!              MADE WHATEVER DELETIONS ARE APPROPRIATE,
!              THE OUTPUT VECTOR X WILL BE 'PACKED';
!              THAT IS, NO 'HOLES' WILL EXIST IN THE
!              VECTOR X--ALL OF THE RETAINED ELEMENTS
!              OF X WILL BE PACKED INTO THE FIRST AVAILABLE
!              LOCATIONS IN X, WHILE THE REMAINDER
!              OF THE N LOCATIONS IN X WILL BE ZERO-FILLED.
!     COMMENT--CAUTION IS TO BE EXERCISED IN
!              USING THIS SUBROUTINE FOR THE
!              FOLLOWING REASON--THE INPUT VECTOR X
!              IS IRREVOCABLY ALTERED BY APPLICATION
!              OF THIS SUBROUTINE.  ALTHOUGH THERE
!              MAY BE A CORRESPONDANCE BETWEEN THE
!              ELEMENTS OF THE X AND D VECTORS
!              BEFORE APPLICATION OF
!              THIS SUBROUTINE, THERE WILL
!              BE NO CORRESPONDANCE BETWEEN
!              X AND D (DUE TO THE PACKING OF
!              THE RETAINED ELEMENTS OF X)
!              AFTER APPLICATION OF THIS SUBROUTINE.
!              TO SUCCESSIVELY EXTRACT EACH POSSIBLE
!              SUBSET OF X, IT IS
!              RECOMMENDED THAT THE
!              ANALYST USE THE      SUBSA2
!              SUBROUTINE WHICH LEAVES
!              THE ORIGINAL INPUT VECTOR X
!              UNALTERED AND OUTPUTS THE
!              RETAINED ELEMENTS IN A
!              SEPARATE SECOND VECTOR Y.
!     COMMENT--IN THE MAIN (CALLING) ROUTINE, IT IS
!              PERMISSABLE (IF THE ANALYST SO DESIRES)
!              TO USE THE SAME VARIABLE NAME
!              IN THE SIXTH ARGUMENT AS USED IN THE SECOND
!              ARGUMENT IN THE CALLING SEQUENCE TO THIS
!              SUBSET SUBROUTINE--NO CONFLICT WILL RESULT
!              IN THE INTERNAL OPERATION OF THE     SUBSET
!              SUBROUTINE.  FOR EXAMPLE, IT IS PERMISSIBLE
!              TO HAVE     CALL SUBSET(X,N,D,0.5,1.5,N)
!              IN WHICH THE VARIABLE NAME      N    IS USED
!              AS BOTH THE SECOND AND SIXTH ARGUMENTS.
!     COMMENT--THIS IS ONE OF THE FEW SUBROUTINES IN DATAPAC
!              IN WHICH THE INPUT VECTOR X IS ALTERED.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION D(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE SUBSET SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE SUBS&
     &ET SUBROUTINE HAS THE VALUE 1 *****')
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE SUBSET SUBROUTINE HAS ALL ELEMENTS =',E15.8,' *****')
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      pointl = Dmin
         pointu = Dmax
         IF ( Dmin>Dmax ) pointl = Dmax
         IF ( Dmin>Dmax ) pointu = Dmin
!
         nold = N
         k = 0
         DO i = 1 , nold
            IF ( D(i)>=pointl .AND. D(i)<=pointu ) THEN
               k = k + 1
               X(k) = X(i)
            ENDIF
         ENDDO
         Newn = k
         ndel = nold - Newn
!
         newnp1 = Newn + 1
         IF ( newnp1<=nold ) THEN
            DO i = newnp1 , nold
               X(i) = 0.0
            ENDDO
         ENDIF
!
!     WRITE OUT A BRIEF SUMMARY
!
         WRITE (ipr,99005)
99005    FORMAT (' ')
         WRITE (ipr,99006)
99006    FORMAT (' ','OUTPUT FROM THE SUBSET SUBROUTINE--')
         WRITE (ipr,99007) pointl , pointu
99007    FORMAT (' ',7X,'D  LIMITS (INCLUSIVE)--   ',E15.8,' AND ',     &
     &           E15.8)
         WRITE (ipr,99008)
99008    FORMAT (' ',7X,'ONLY THOSE OBSERVATIONS IN X')
         WRITE (ipr,99009)
99009    FORMAT (' ',7X,'WILL BE RETAINED')
         WRITE (ipr,99010)
99010    FORMAT (' ',7X,'FOR WHICH THECORRESPONDING ELEMENTS OF D')
         WRITE (ipr,99011)
99011    FORMAT (' ',7X,'ARE WITHIN (INCLUSIVE)')
         WRITE (ipr,99012)
99012    FORMAT (' ',7X,'THE SPECIFIED LIMITS.')
         WRITE (ipr,99013)
99013    FORMAT (' ',7X,'ALL OBSERVATIONS OUTSIDE OF THIS INTERVAL')
         WRITE (ipr,99014)
99014    FORMAT (' ',7X,'HAVE BEEN DELETED IN X.')
         WRITE (ipr,99015) nold
99015    FORMAT (' ',7X,'THE INPUT  NUMBER OF OBSERVATIONS (IN X) IS ', &
     &           I6)
         WRITE (ipr,99016) Newn
99016    FORMAT (' ',7X,'THE OUTPUT NUMBER OF OBSERVATIONS (IN X) IS ', &
     &           I6)
         WRITE (ipr,99017) ndel
99017    FORMAT (' ',7X,'THE NUMBER OF OBSERVATIONS DELETED       IS ', &
     &           I6)
      ENDIF
!
      END SUBROUTINE SUBSET
!*==tail.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE TAIL(X,N)
      IMPLICIT NONE
!*--TAIL29420
!*** Start of declarations inserted by SPAG
      REAL a2 , a3 , a4 , aa , ai , al , alamba , am2 , am3 , am4 , an ,&
     &     arg , asub1 , asubn , b1 , b2 , bb , bs , cc , coef
      REAL coefi , constn , corr , corrmx , cox1xn , dd , del , eandev ,&
     &     eb1 , eb2 , ecc , ee , egeary , ei , er , ers , ersq ,       &
     &     erssq , es , essq
      REAL ewilks , ex1 , ex1xn , exn , exnsq , g , gamma , geary ,     &
     &     hold , P , p1 , pi , picons , pn , ppfnor , PTEnth , q ,     &
     &     rp1 , rpn , rs
      REAL s , sdb1 , sdb2 , sdcc , sdgear , sdrs , sdwilk , sfp1 ,     &
     &     sfpn , sum , sum1 , sum2 , sum3 , sum4 , varrs , varxn ,     &
     &     wilksh , WS , X , xbar
      REAL xline , Y , YM , Z , zb1 , zb2 , zcc , zgeary , zrs , zwilks
      INTEGER i , icount , idis , idis2 , idismx , ievodd , imax ,      &
     &        imin , ipr , irev , iupper , mx , N , nhalf , nhalfp ,    &
     &        nm1 , numdis
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT TAIL
!
!     PURPOSE--THIS SUBROUTINE PERFOMS A SYMMETRIC DISTRIBUTION
!              TAIL LENGTH ANALYSIS
!              ON THE DATA IN THE INPUT VECTOR X.
!              THE ANALYSIS CONSISTS OF THE FOLLOWING--
!              1) VARIOUS TEST STATISTICS TO TEST
!                 THE SPECIFIC HYPOTHESIS OF NORMALITY;
!              2) A UNIFORM PROBABILITY PLOT
!                 (A SHORT-TAILED DISTRIBUTION);
!              3) A NORMAL PROBAIBLITY PLOT
!                 (A MODERATE-TAILED DISTRIBUTION);
!              4) A TUKEY LAMBDA = -0.5 PROBABILTY PLOT
!                 (A MODERATE-LONG-TAILED DISTRIBTION);
!              5) A CAUCHY PROBABILITY PLOT
!                (A LONG-TAILED DISTRIBUTION);
!              6) A DETERMINATION OF THE BEST-FIT
!                 SYMMETRIC DISTRIBUTION
!                 TO THE DATA SET FROM AN
!                 ADMISSABLE SET CONSISTING OF
!                 43 SYMMETRIC DISTRIBUTIONS.
!              THE ADMISSABLE SET OF SYMMETRIC
!              DISTRIBUTIONS CONSIDERED INCLUDES THE
!              UNIFORM, NORMAL, LOGISTIC,
!              DOUBLE EXPONENTIAL, CAUCHY, AND
!              37 DISTRIBUTIONS DRAWN FROM THE
!              THE TUKEY LAMBDA DISTRIBUTIONAL FAMILY.
!              THE GOODNESS OF FIT CRITERION IS THE MAXIMUM PROBABILITY
!              PLOT CORRELATION COEFFICIENT CRITERION.
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS.
!                      N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--6 PAGES OF AUTOMATIC PRINTOUT--
!             1) VARIOUS TEST STATISTICS FOR NORMALITY;
!             2) A UNIFORM PROBABILITY PLOT;
!             3) A NORMAL PROBAIBLITY PLOT;
!             4) A TUKEY LAMBDA = -0.5 PROBABILTY PLOT;
!             5) A CAUCHY PROBABILITY PLOT;
!             6) A DETERMINATION OF THE BEST-FIT
!                SYMMETRIC DISTRIBUTION
!                TO THE DATA SET.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 3000.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, NORPPF, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, ALOG, ALOG10, EXP,
!                                         SIN, COS, ATAN.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCE--FILLIBEN (1972), 'TECHNIQUES FOR TAIL LENGTH
!                ANALYSIS', PROCEEDINGS OF THE EIGHTEENTH
!                CONFERENCE ON THE DESIGN OF EXPERIMENTS IN
!                ARMY RESEARCH AND TESTING, PAGES 425-450.
!              --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                UNPUBLISHED MANUSCRIPT.
!              --JOHNSON AND KOTZ (1970), CONTINUOUS UNIVARIATE
!                DISTRIBUTIONS-1, PAGES 250-271.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 iflag1
      CHARACTER*4 iflag2
      CHARACTER*4 iflag3
      CHARACTER*4 iline1
      CHARACTER*4 iline2
!
      CHARACTER*4 alpham
      CHARACTER*4 alphaa
      CHARACTER*4 blank
      CHARACTER*4 hyphen
      CHARACTER*4 alphai
      CHARACTER*4 alphax
!
      DIMENSION X(*)
      DIMENSION Y(3000) , Z(3000) , YM(3000)
      DIMENSION P(3000) , PTEnth(3000)
      DIMENSION corr(50) , iflag1(50) , iflag2(50) , iflag3(50)
      DIMENSION iline1(130) , iline2(130)
      DIMENSION xline(13)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (Z(1),WS(3001))
      EQUIVALENCE (YM(1),WS(6001))
      EQUIVALENCE (P(1),WS(9001))
      EQUIVALENCE (PTEnth(1),WS(12001))
!
      DATA alpham , alphaa/'M' , 'A'/
      DATA blank , hyphen , alphai , alphax/' ' , '-' , 'I' , 'X'/
      DATA picons/3.14159265358979/
      DATA constn/.3989422804/
!
      ipr = 6
      iupper = 3000
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE TAIL   SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE TAIL&
     &   SUBROUTINE HAS THE VALUE 1 *****')
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE TAIL   SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     COMPUTE THE SAMPLE MEAN
!
         sum = 0.0
         DO i = 1 , N
            sum = sum + X(i)
         ENDDO
         xbar = sum/an
!
!     COMPUTE S, BIASED S, B1, AND B2
!
         sum2 = 0.0
         sum3 = 0.0
         sum4 = 0.0
         DO i = 1 , N
            del = X(i) - xbar
            a2 = del*del
            a3 = del*a2
            a4 = a2*a2
            sum2 = sum2 + a2
            sum3 = sum3 + a3
            sum4 = sum4 + a4
         ENDDO
         am2 = sum2/an
         am3 = sum3/an
         am4 = sum4/an
         s = SQRT(sum2/(an-1.0))
         bs = SQRT(am2)
         b1 = am3/(bs**3)
         b2 = am4/(bs**4)
!
!     COMPUTE THE EXPECTED VALUE AND STANDARD DEVIATION OF B1 AND B2
!     UNDER THE NORMALITY ASSUMPTION
!     REFERENCE--CRAMER, PAGE 386
!
         eb1 = 0.0
         sdb1 = 6.0*(an-2.0)/((an+1.0)*(an+3.0))
         sdb1 = SQRT(sdb1)
         zb1 = (b1-eb1)/sdb1
         eb2 = 3.0 - 6.0/(an+1.0)
         sdb2 = 24.0*an*(an-2.0)*(an-3.0)                               &
     &          /((an+1.0)*(an+1.0)*(an+3.0)*(an+5.0))
         zb2 = (b2-eb2)/sdb2
!
!     COMPUTE GEARY'S STATISTIC
!
         sum = 0.0
         DO i = 1 , N
            sum = sum + ABS(X(i)-xbar)
         ENDDO
         eandev = sum/an
         geary = eandev/bs
!
!     COMPUTE THE EXPECTED VALUE AND STANDARD DEVIATION
!     OF GEARY'S STATISTIC UNDER THE NORMALITY ASSUMPTION
!     REFERENCE--BIOMETRIKA, 1936, PAGE 296
!
         aa = SQRT(2.0/picons)
         bb = SQRT(2.0/(an-1.0))
         IF ( N>=100 ) cc = SQRT(an/2.0)                                &
     &                      *(1.0-(1.0/(8.0*an/2.0))+(1.0/(128.0*an*an/ &
     &                      4.0)))
         IF ( N<100 ) THEN
            coef = 1.0
            imax = N - 1
            ievodd = N - 2*(N/2)
            imin = 2
            IF ( ievodd==0 ) imin = 3
            IF ( imin<=imax ) THEN
               DO i = imin , imax , 2
                  ai = i
                  coef = ((ai-1.0)/ai)*coef
               ENDDO
            ENDIF
            coef = coef*(an-1.0)
            IF ( ievodd==0 ) THEN
               coef = coef/SQRT(picons)
            ELSE
               coef = coef*(SQRT(picons)/2.0)
            ENDIF
            cc = coef
         ENDIF
         egeary = aa/(bb*cc)
         dd = (2.0/picons)*SQRT(an*(an-2.0))
         arg = 1.0/(an-1.0)
         arg = arg/SQRT(1.0-arg*arg)
         ee = ATAN(arg)
         sdgear = (1.0/an)*(1.0+dd+ee)
         sdgear = sdgear - egeary*egeary
         sdgear = SQRT(sdgear)
         zgeary = (geary-egeary)/sdgear
!
!     SORT THE DATA,
!     THEN COMPUTE RANGE/S.
!
         CALL SORT(X,N,Y)
         rs = (Y(N)-Y(1))/s
!
!     COMPUTE THE EXPECTED VALUE AND STANDARD DEVIATION OF THE RANGE/S
!     UNDER THE NORMALITY ASSUMPTION
!     REFERENCE--BIOMETRIKA, 1954, PAGE 483
!
         g = .33000598 + ((an-2.0)**.16)/41.785
         pn = (an-g)/(an-2.0*g+1.0)
         p1 = 1.0 - pn
         CALL NORPPF(pn,rpn)
         CALL NORPPF(p1,rp1)
         exn = rpn
         ex1 = rp1
         er = exn - ex1
         CALL NORPPF(p1,ppfnor)
         sfp1 = 1.0/(constn*EXP(-(ppfnor*ppfnor)/2.0))
         CALL NORPPF(pn,ppfnor)
         sfpn = 1.0/(constn*EXP(-(ppfnor*ppfnor)/2.0))
         varxn = pn*(1.0-pn)*sfpn*sfpn/(an+2.0)
         exnsq = varxn + exn*exn
         cox1xn = p1*p1*sfp1*sfpn/(an+2.0)
         ex1xn = cox1xn + ex1*exn
         ersq = 2.0*(exnsq-ex1xn)
         es = bb*cc
         essq = 1.0
         ers = er/es
         erssq = ersq/essq
         varrs = erssq - ers*ers
         sdrs = SQRT(varrs)
         zrs = (rs-ers)/sdrs
!
!     COMPUTE THE WILK-SHAPIRO STATISTIC
!
         al = ALOG10(an)
         gamma = .327511 + .058212*al - .009776*al*al
         sum = 0.0
         IF ( N<=20 ) arg = N
         IF ( N>20 ) arg = N + 1
         asubn = SQRT((1.0+(1.0/(4.0*arg)))/SQRT(arg))
         asub1 = -asubn
         sum = sum + asub1*Y(1) + asubn*Y(N)
         IF ( N>2 ) THEN
            nm1 = N - 1
            DO i = 2 , nm1
               ai = i
               pi = (ai-gamma)/(an-2.0*gamma+1.0)
               CALL NORPPF(pi,ei)
               coefi = 2.0*ei/SQRT(-2.722+4.083*an)
               sum = sum + coefi*Y(i)
            ENDDO
         ENDIF
         wilksh = sum*sum/(an*bs*bs)
!
!     COMPUTE THE EXPECTED VALUE AND STANDARD DEVIATION OF THE WILK-SHAPIRO
!     STATISTIC UNDER THE NORMALITY ASSUMPTION
!     REFERENCE--JJF APPROXIMATION TO MOMENTS ON PAGE 601 OF BIOMETRIKA (1965)
!
         IF ( N==3 ) ewilks = .9135
         IF ( N==4 ) ewilks = .9012
         IF ( N>=5 ) ewilks = .9026 + (an-5.0)                          &
     &                        /(44.608+13.593*SQRT(an)+10.267*an)
         IF ( N==3 ) sdwilk = .0755
         IF ( N==4 ) sdwilk = .0719
         IF ( N>=5 ) sdwilk = .0670 + (an-5.0)                          &
     &                        /(-42.368-5.026*SQRT(an)-14.925*an)
         zwilks = (wilksh-ewilks)/sdwilk
!
!     COMPUTE THE CORRELATION COEFFICIENT BETWEEN THE ORDERED OBSERVATIONS
!     AND THE ORDER STATISIC MEDIANS FROM 44 DIFFERENT SYMMETRIC DISTRIBUTIONS
!
         numdis = 44
         nhalf = N/2
         nhalfp = nhalf + 1
         ievodd = N - 2*(N/2)
         CALL UNIMED(N,Z)
         DO i = 1 , N
            PTEnth(i) = Z(i)**(0.1)
         ENDDO
         DO idis = 1 , numdis
            IF ( idis==20 ) THEN
               DO i = 1 , nhalf
                  irev = N - i + 1
                  CALL NORPPF(Z(i),YM(i))
                  YM(irev) = -YM(i)
               ENDDO
               IF ( ievodd==1 ) YM(nhalfp) = 0.0
            ELSEIF ( idis==22 ) THEN
               DO i = 1 , nhalf
                  irev = N - i + 1
                  YM(i) = ALOG(Z(i)/(1.0-Z(i)))
                  YM(irev) = -YM(i)
               ENDDO
               IF ( ievodd==1 ) YM(nhalfp) = 0.0
            ELSEIF ( idis==23 ) THEN
               DO i = 1 , nhalf
                  irev = N - i + 1
                  IF ( Z(i)<=0.5 ) YM(i) = ALOG(2.0*Z(i))
                  IF ( Z(i)>0.5 ) YM(i) = -ALOG(2.0*(1.0-Z(i)))
                  YM(irev) = -YM(i)
               ENDDO
               IF ( ievodd==1 ) YM(nhalfp) = 0.0
            ELSEIF ( idis==33 ) THEN
               DO i = 1 , nhalf
                  irev = N - i + 1
                  arg = picons*Z(i)
                  YM(i) = -COS(arg)/SIN(arg)
                  YM(irev) = -YM(i)
               ENDDO
               IF ( ievodd==1 ) YM(nhalfp) = 0.0
            ELSE
               IF ( idis<20 ) idis2 = idis
               IF ( idis==21 ) idis2 = idis - 1
               IF ( 23<idis .AND. idis<33 ) idis2 = idis - 2
               IF ( 33<idis ) idis2 = idis - 3
               alamba = -(0.1)*FLOAT(idis2) + 2.1
               IF ( idis==1 ) THEN
                  DO i = 1 , nhalf
                     irev = N - i + 1
                     P(i) = Z(i)*Z(i)
                     P(irev) = Z(irev)*Z(irev)
                     YM(i) = (P(i)-P(irev))/alamba
                     YM(irev) = -YM(i)
                  ENDDO
                  IF ( ievodd==1 ) YM(nhalfp) = 0.0
               ELSEIF ( idis==11 ) THEN
                  DO i = 1 , nhalf
                     irev = N - i + 1
                     P(i) = Z(i)
                     P(irev) = Z(irev)
                     YM(i) = (P(i)-P(irev))/alamba
                     YM(irev) = -YM(i)
                  ENDDO
                  IF ( ievodd==1 ) YM(nhalfp) = 0.0
               ELSEIF ( idis==24 ) THEN
                  DO i = 1 , nhalf
                     irev = N - i + 1
                     P(i) = Z(i)**(-0.1)
                     P(irev) = Z(irev)**(-0.1)
                     YM(i) = (P(i)-P(irev))/alamba
                     YM(irev) = -YM(i)
                  ENDDO
                  IF ( ievodd==1 ) YM(nhalfp) = 0.0
               ELSEIF ( idis==34 ) THEN
                  DO i = 1 , nhalf
                     P(irev) = 1.0/Z(irev)
                     P(i) = 1.0/Z(i)
                     irev = N - i + 1
                     YM(i) = (P(i)-P(irev))/alamba
                     YM(irev) = -YM(i)
                  ENDDO
                  IF ( ievodd==1 ) YM(nhalfp) = 0.0
               ELSEIF ( idis==44 ) THEN
                  DO i = 1 , nhalf
                     irev = N - i + 1
                     P(i) = 1.0/(Z(i)*Z(i))
                     P(irev) = 1.0/(Z(irev)*Z(irev))
                     YM(i) = (P(i)-P(irev))/alamba
                     YM(irev) = -YM(i)
                  ENDDO
                  IF ( ievodd==1 ) YM(nhalfp) = 0.0
               ELSE
                  DO i = 1 , nhalf
                     irev = N - i + 1
                     P(i) = P(i)/PTEnth(i)
                     P(irev) = P(irev)/PTEnth(irev)
                     YM(i) = (P(i)-P(irev))/alamba
                     YM(irev) = -YM(i)
                  ENDDO
                  IF ( ievodd==1 ) YM(nhalfp) = 0.0
               ENDIF
            ENDIF
            sum1 = 0.0
            sum2 = 0.0
            DO i = 1 , N
               sum1 = sum1 + Y(i)*YM(i)
               sum2 = sum2 + YM(i)*YM(i)
            ENDDO
            sum2 = SQRT(sum2)
            sum3 = s*SQRT(an-1.0)
            corr(idis) = sum1/(sum2*sum3)
         ENDDO
!
!     DETERMINE THAT DISTRIBUTION WITH THE MAXIMUM PROB PLOT CORR COEFFICIENT
!
         idismx = 1
         corrmx = corr(1)
         DO idis = 1 , numdis
            IF ( corr(idis)>corrmx ) idismx = idis
            IF ( corr(idis)>corrmx ) corrmx = corr(idis)
         ENDDO
         DO idis = 1 , numdis
            iflag1(idis) = blank
            iflag2(idis) = blank
            iflag3(idis) = blank
            IF ( idis==idismx ) THEN
               iflag1(idis) = alpham
               iflag2(idis) = alphaa
               iflag3(idis) = alphax
            ENDIF
         ENDDO
         cc = corr(20)
!
!     COMPUTE THE EXPECTED VALUE AND STANDARD DEVIATION OF THE PROBABILITY PLOT
!     CORRELATION COEFFICIENT UNDER THE NORMALITY ASSUMPTION
!     REFERENCE--JJF UNPUBLISHED MANUSCRIPT
!
         IF ( N==2 ) ecc = 1.0
         IF ( N==3 ) ecc = .95492958
         IF ( N>=4 ) ecc = .94947355 + (an-4.0)                         &
     &                     /(196.815-2.9418*SQRT(an)+19.7916*an)
         IF ( N==2 ) sdcc = 99999999.9999
         IF ( N==3 ) sdcc = .04007697
         IF ( N>=4 ) sdcc = .039492 + (an-4.0)/(-127.0-25.3*an)
         zcc = (cc-ecc)/sdcc
!
!     WRITE OUT THE NORMAL TAIL LENGTH STATISTICS PAGE
!
         WRITE (ipr,99044)
         WRITE (ipr,99005)
!
99005    FORMAT (' ',48X,'TAIL LENGTH ANALYSIS')
         WRITE (ipr,99045)
         WRITE (ipr,99006) N
99006    FORMAT (' ',46X,'(THE SAMPLE SIZE N = ',I5,')')
         WRITE (ipr,99007) xbar
99007    FORMAT (' ',40X,'(THE SAMPLE MEAN = ',E15.8,')')
         WRITE (ipr,99008) s
99008    FORMAT (' ',35X,'(THE SAMPLE STANDARD DEVIATION = ',E15.8,')')
         WRITE (ipr,99045)
         WRITE (ipr,99009)
99009    FORMAT (' ',35X,                                               &
     & 'REFERENCE--SHAPIRO, WILK, AND CHEN, JASA, 1968, PAGES 1343-1372'&
     & )
         WRITE (ipr,99010)
99010    FORMAT (' ',35X,'REFERENCE--CRAMER, PAGES 386-387')
         WRITE (ipr,99011)
99011    FORMAT (' ',35X,                                               &
     &           'REFERENCE--GEARY, BIOMETRIKA, 1947, PAGES 209-242')
         WRITE (ipr,99012)
99012    FORMAT (' ',35X,                                               &
     &'REFERENCE--BIOMETRIKA TABLES, VOLUME 1, PAGES 67-69, 59-60, 207-2&
     &08, AND 200')
         WRITE (ipr,99013)
99013    FORMAT (' ',35X,                                               &
     &    'REFERENCE--SHAPIRO AND WILK, BIOMETRIKA, 1965, PAGES 591-611'&
     &    )
         DO i = 1 , 6
            WRITE (ipr,99045)
         ENDDO
         WRITE (ipr,99014)
99014    FORMAT (' ',49X,'TAIL LENGTH STATISTICS')
         WRITE (ipr,99015)
99015    FORMAT (' ',5X,                                                &
     &'THE EXPECTED VALUE AND STANDARD DEVIATION OF STATISTICS ON THIS P&
     &AGE ARE BASED ON THE NORMALITY ASSUMPTION')
         WRITE (ipr,99045)
         WRITE (ipr,99045)
         WRITE (ipr,99016)
99016    FORMAT (' ',                                                   &
     &'          FORM OF STATISTIC               VALUE OF STAT    EXP(ST&
     &AT)    SD(STAT)    (STAT-EXP(STAT))/SD(STAT)    TABLE REFERENCE')
         WRITE (ipr,99045)
         WRITE (ipr,99017) b1 , eb1 , sdb1 , zb1
99017    FORMAT (' ','STANDARDIZED THIRD CENTRAL MOMENT        ',F10.5, &
     &           6X,F10.5,2X,F10.5,9X,F10.5,13X,'BIOMETRIKA TABLES')
         WRITE (ipr,99018)
99018    FORMAT (' ',111X,'VOL. 1, PAGE 207')
         WRITE (ipr,99019) b2 , eb2 , sdb2 , zb2
99019    FORMAT (' ','STANDARDIZED FOURTH CENTRAL MOMENT       ',F10.5, &
     &           6X,F10.5,2X,F10.5,9X,F10.5,13X,'BIOMETRIKA TABLES')
         WRITE (ipr,99020)
99020    FORMAT (' ',111X,'VOL. 1, PAGE 208')
         WRITE (ipr,99021) geary , egeary , sdgear , zgeary
99021    FORMAT (' ','GEARY STATISTIC (MEAN DEVIATION/S)       ',F10.5, &
     &           6X,F10.5,2X,F10.5,9X,F10.5,13X,'BIOMETRIKA TABLES')
         WRITE (ipr,99022)
99022    FORMAT (' ',111X,'VOL. 1, PAGE 207')
         WRITE (ipr,99023) rs , ers , sdrs , zrs
99023    FORMAT (' ','RANGE/S                                  ',F10.5, &
     &           6X,F10.5,2X,F10.5,9X,F10.5,13X,'BIOMETRIKA TABLES')
         WRITE (ipr,99024)
99024    FORMAT (' ',111X,'VOL. 1, PAGE 200')
         WRITE (ipr,99025) wilksh , ewilks , sdwilk , zwilks
99025    FORMAT (' ','WILK-SHAPIRO STATISTIC (BLUE FOR SCALE/S)',F10.5, &
     &           6X,F10.5,2X,F10.5,9X,F10.5,13X,'BIOMETRIKA (1965)')
         WRITE (ipr,99026)
99026    FORMAT (' ',111X,'PAGE 605')
         WRITE (ipr,99027) cc , ecc , sdcc , zcc
99027    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT ',F10.5, &
     &           6X,F10.5,2X,F10.5,9X,F10.5,13X,'UNPUBLISHED JJF')
         WRITE (ipr,99028)
99028    FORMAT (' ',111X,'MANUSCRIPT')
!
!     COMPUTE THE LINE PLOT WHICH SHOWS THE DISTRIBUTION OF THE OBSERVED
!     VALUES IN TERMS OF MULTIPLES OF SAMPLE STANDARD DEVIATIONS AWAY FROM
!     THE SAMPLE MEAN
!
         DO i = 1 , 130
            iline1(i) = blank
            iline2(i) = blank
         ENDDO
         icount = 0
         DO i = 1 , N
            mx = 10.0*(((X(i)-xbar)/s)+6.0) + 0.5
            mx = mx + 7
            IF ( mx<7 .OR. mx>127 ) icount = icount + 1
            IF ( mx>=7 .AND. mx<=127 ) iline1(mx) = alphax
         ENDDO
         DO i = 7 , 127
            iline2(i) = hyphen
         ENDDO
         DO i = 7 , 127 , 10
            iline2(i) = alphai
         ENDDO
         xline(7) = xbar
         DO i = 1 , 6
            irev = 13 - i + 1
            ai = i
            xline(i) = xbar - (7.0-ai)*s
            xline(irev) = xbar + (7.0-ai)*s
         ENDDO
!
!     WRITE OUT THE LINE PLOT SHOWING THE DEVIATIONS OF THE OBSERVATIONS
!     ABOUT THE SAMPLE MEAN IN TERMS OF MULTIPLES OF THE SAMPLE STANDARD
!     DEVIATION
!
         DO i = 1 , 8
            WRITE (ipr,99045)
         ENDDO
         WRITE (ipr,99029)
99029    FORMAT (' ',                                                   &
     &'LINE PLOT SHOWING THE DISTRIBUTION OF THE OBSERVATIONS ABOUT THE &
     &SAMPLE MEAN IN TERMS OF MULTIPLES OF THE SAMPLE STANDARD DEVIATION&
     &')
         WRITE (ipr,99045)
         WRITE (ipr,99045)
         WRITE (ipr,99042) (iline1(i),i=1,130)
         WRITE (ipr,99042) (iline2(i),i=1,130)
         WRITE (ipr,99030)
99030    FORMAT (' ',                                                   &
     &'     -6        -5        -4        -3        -2        -1        &
     & 0         1         2         3         4         5         6')
         WRITE (ipr,99031) (xline(i),i=1,13)
99031    FORMAT (' ',13F10.4)
         WRITE (ipr,99045)
         WRITE (ipr,99032) icount
99032    FORMAT (' ',10X,I5,                                            &
     &' OBSERVATIONS WERE IN EXCESS OF 6 SAMPLE STANDARD DEVIATIONS FROM&
     & THE SAMPLE MEAN AND SO WERE NOT PLOTTED')
!
!     GENERATE UNIFORM, NORMAL, LAMBDA = -0.5, AND CAUCHY PROBABILITY PLOTS
!
         nhalf = (N/2) + 1
         CALL PLOT(Y,Z,N)
         WRITE (ipr,99033) N
99033    FORMAT (' ',35X,                                               &
     &           'UNIFORM PROBABILITY PLOT  (THE SAMPLE SIZE N = ',I5,  &
     &           ')')
         WRITE (ipr,99043) corr(11)
         DO i = 1 , nhalf
            irev = N - i + 1
            CALL NORPPF(Z(i),YM(i))
            YM(irev) = -YM(i)
         ENDDO
         CALL PLOT(Y,YM,N)
         WRITE (ipr,99034) N
99034    FORMAT (' ',35X,                                               &
     &           'NORMAL PROBABILITY PLOT  (THE SAMPLE SIZE N = ',I5,   &
     &           ')')
         WRITE (ipr,99043) corr(20)
         alamba = -0.5
         DO i = 1 , nhalf
            irev = N - i + 1
            q = Z(i)
            YM(i) = (q**alamba-(1.0-q)**alamba)/alamba
            YM(irev) = -YM(i)
         ENDDO
         CALL PLOT(Y,YM,N)
         WRITE (ipr,99035) alamba , N
99035    FORMAT (' ',35X,'LAMBDA = ',F4.1,                              &
     &           ' PROBABILITY PLOT  (THE SAMPLE SIZE N = ',I5,')')
         WRITE (ipr,99043) corr(28)
         DO i = 1 , nhalf
            irev = N - i + 1
            arg = picons*Z(i)
            YM(i) = -COS(arg)/SIN(arg)
            YM(irev) = -YM(i)
         ENDDO
         CALL PLOT(Y,YM,N)
         WRITE (ipr,99036) N
99036    FORMAT (' ',35X,                                               &
     &           'CAUCHY PROBABILITY PLOT  (THE SAMPLE SIZE N = ',I5,   &
     &           ')')
         WRITE (ipr,99043) corr(33)
!
!      WRITE OUT THE PROBABILITY PLOT CORRELATION COEFFICIENT PAGE
!
         WRITE (ipr,99044)
         DO idis = 1 , numdis
            IF ( idis==20 ) THEN
               WRITE (ipr,99037) N , corr(idis) , iflag1(idis) ,        &
     &                           iflag2(idis) , iflag3(idis)
99037          FORMAT (' ','THE CORRELATION BETWEEN THE ',I6,           &
     &' ORDERED OBS. AND THE ORDER STAT. MEDIANS FROM THE NORMAL DISTRIB&
     &UTION IS ',F8.5,1X,3A1)
            ELSEIF ( idis==22 ) THEN
               WRITE (ipr,99038) N , corr(idis) , iflag1(idis) ,        &
     &                           iflag2(idis) , iflag3(idis)
99038          FORMAT (' ','THE CORRELATION BETWEEN THE ',I6,           &
     &' ORDERED OBS. AND THE ORDER STAT. MEDIANS FROM THE LOGISTIC DIST.&
     &      IS ',F8.5,1X,3A1)
            ELSEIF ( idis==23 ) THEN
               WRITE (ipr,99039) N , corr(idis) , iflag1(idis) ,        &
     &                           iflag2(idis) , iflag3(idis)
99039          FORMAT (' ','THE CORRELATION BETWEEN THE ',I6,           &
     &' ORDERED OBS. AND THE ORDER STAT. MEDIANS FROM THE DOUBLE EXP. DI&
     &ST.   IS ',F8.5,1X,3A1)
            ELSEIF ( idis==33 ) THEN
               WRITE (ipr,99040) N , corr(idis) , iflag1(idis) ,        &
     &                           iflag2(idis) , iflag3(idis)
99040          FORMAT (' ','THE CORRELATION BETWEEN THE ',I6,           &
     &' ORDERED OBS. AND THE ORDER STAT. MEDIANS FROM THE CAUCHY DISTRIB&
     &UTION IS ',F8.5,1X,3A1)
            ELSE
               IF ( idis<20 ) idis2 = idis
               IF ( idis==21 ) idis2 = idis - 1
               IF ( 23<idis .AND. idis<33 ) idis2 = idis - 2
               IF ( 33<idis ) idis2 = idis - 3
               alamba = -(0.1)*FLOAT(idis2) + 2.1
               WRITE (ipr,99041) N , alamba , corr(idis) , iflag1(idis) &
     &                           , iflag2(idis) , iflag3(idis)
99041          FORMAT (' ','THE CORRELATION BETWEEN THE ',I6,           &
     &    ' ORDERED OBS. AND THE ORDER STAT. MEDIANS FROM THE LAMBDA = '&
     &    ,F4.1,' DIST. IS ',F8.5,1X,3A1)
            ENDIF
         ENDDO
      ENDIF
99042 FORMAT (' ',130A1)
99043 FORMAT (' ',34X,'(PROBABILITY PLOT CORRELATION COEFFICIENT = ',   &
     &        F8.5,')')
99044 FORMAT ('1')
99045 FORMAT (' ')
!
      END SUBROUTINE TAIL
!*==tcdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE TCDF(X,Nu,Cdf)
      IMPLICIT NONE
!*--TCDF30117
!*** Start of declarations inserted by SPAG
      REAL anu , Cdf , cdfn , sd , X , z
      INTEGER i , ievodd , imax , imin , ipr , Nu , nucut
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT TCDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR STUDENT'S T DISTRIBUTION
!              WITH INTEGER DEGREES OF FREEDOM PARAMETER = NU.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X.
!              THE PROBABILITY DENSITY FUNCTION IS GIVEN
!              IN THE REFERENCES BELOW.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!                                X SHOULD BE NON-NEGATIVE.
!                     --NU     = THE INTEGER NUMBER OF DEGREES
!                                OF FREEDOM.
!                                NU SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF FOR THE STUDENT'S T DISTRIBUTION
!             WITH DEGREES OF FREEDOM PARAMETER = NU.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--NU SHOULD BE A POSITIVE INTEGER VARIABLE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NORCDF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--DSQRT, DATAN.
!     MODE OF INTERNAL OPERATIONS--DOUBLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--NATIONAL BUREAU OF STANDARDS APPLIED MATHMATICS
!                 SERIES 55, 1964, PAGE 948, FORMULAE 26.7.3 AND 26.7.4.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 94-129.
!               --FEDERIGHI, EXTENDED TABLES OF THE
!                 PERCENTAGE POINTS OF STUDENT'S
!                 T-DISTRIBUTION, JOURNAL OF THE
!                 AMERICAN STATISTICAL ASSOCIATION,
!                 1959, PAGES 683-688.
!               --OWEN, HANDBOOK OF STATISTICAL TABLES,
!                 1962, PAGES 27-30.
!               --PEARSON AND HARTLEY, BIOMETRIKA TABLES
!                 FOR STATISTICIANS, VOLUME 1, 1954,
!                 PAGES 132-134.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --MAY       1974.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --OCTOBER   1976.
!
!---------------------------------------------------------------------
!
      DOUBLE PRECISION dx , dnu , pi , c , csq , s , sum , term , ai
      DOUBLE PRECISION DSQRT , DATAN
      DOUBLE PRECISION dconst
      DOUBLE PRECISION term1 , term2 , term3
      DOUBLE PRECISION dcdfn
      DOUBLE PRECISION dcdf
      DOUBLE PRECISION b11
      DOUBLE PRECISION b21 , b22 , b23 , b24 , b25
      DOUBLE PRECISION b31 , b32 , b33 , b34 , b35 , b36 , b37
      DOUBLE PRECISION d1 , d3 , d5 , d7 , d9 , d11
      DATA nucut/1000/
      DATA pi/3.14159265358979D0/
      DATA dconst/0.3989422804D0/
      DATA b11/0.25D0/
      DATA b21/0.01041666666667D0/
      DATA b22 , b23 , b24 , b25/3.0D0 , -7.0D0 , -5.0D0 , -3.0D0/
      DATA b31/0.00260416666667D0/
      DATA b32 , b33 , b34 , b35 , b36 , b37/1.0D0 , -11.0D0 , 14.0D0 , &
     &     6.0D0 , -3.0D0 , -15.0D0/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( Nu<=0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE TCDF   SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) Nu
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         Cdf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         dx = X
         anu = Nu
         dnu = Nu
!
!     IF NU IS 3 THROUGH 9 AND X IS MORE THAN 3000
!     STANDARD DEVIATIONS BELOW THE MEAN,
!     SET CDF = 0.0 AND RETURN.
!     IF NU IS 10 OR LARGER AND X IS MORE THAN 150
!     STANDARD DEVIATIONS BELOW THE MEAN,
!     SET CDF = 0.0 AND RETURN.
!     IF NU IS 3 THROUGH 9 AND X IS MORE THAN 3000
!     STANDARD DEVIATIONS ABOVE THE MEAN,
!     SET CDF = 1.0 AND RETURN.
!     IF NU IS 10 OR LARGER AND X IS MORE THAN 150
!     STANDARD DEVIATIONS ABOVE THE MEAN,
!     SET CDF = 1.0 AND RETURN.
!
         IF ( Nu<=2 ) GOTO 100
         sd = SQRT(anu/(anu-2.0))
         z = X/sd
         IF ( Nu>=10 .OR. z>=-3000.0 ) THEN
            IF ( Nu<10 .OR. z>=-150.0 ) THEN
               IF ( Nu<10 .AND. z>3000.0 ) GOTO 50
               IF ( Nu<10 .OR. z<=150.0 ) GOTO 100
               GOTO 50
            ENDIF
         ENDIF
         Cdf = 0.0
         RETURN
 50      Cdf = 1.0
         RETURN
      ENDIF
!
!     DISTINGUISH BETWEEN THE SMALL AND MODERATE
!     DEGREES OF FREEDOM CASE VERSUS THE
!     LARGE DEGREES OF FREEDOM CASE
!
 100  IF ( Nu<nucut ) THEN
!
!     TREAT THE SMALL AND MODERATE DEGREES OF FREEDOM CASE
!     METHOD UTILIZED--EXACT FINITE SUM
!     (SEE AMS 55, PAGE 948, FORMULAE 26.7.3 AND 26.7.4).
!
         c = DSQRT(dnu/(dx*dx+dnu))
         csq = dnu/(dx*dx+dnu)
         s = dx/DSQRT(dx*dx+dnu)
         imax = Nu - 2
         ievodd = Nu - 2*(Nu/2)
         IF ( ievodd==0 ) THEN
!
            sum = 1.0D0
            term = 1.0D0
            imin = 2
         ELSE
!
            sum = c
            IF ( Nu==1 ) sum = 0.0D0
            term = c
            imin = 3
         ENDIF
!
         IF ( imin<=imax ) THEN
            DO i = imin , imax , 2
               ai = i
               term = term*((ai-1.0D0)/ai)*csq
               sum = sum + term
            ENDDO
         ENDIF
!
         sum = sum*s
         IF ( ievodd/=0 ) sum = (2.0D0/pi)*(DATAN(dx/DSQRT(dnu))+sum)
         Cdf = 0.5D0 + sum/2.0D0
         RETURN
      ELSE
!
!     TREAT THE LARGE DEGREES OF FREEDOM CASE.
!     METHOD UTILIZED--TRUNCATED ASYMPTOTIC EXPANSION
!     (SEE JOHNSON AND KOTZ, VOLUME 2, PAGE 102, FORMULA 10;
!     SEE FEDERIGHI, PAGE 687).
!
         CALL NORCDF(X,cdfn)
         dcdfn = cdfn
         d1 = dx
         d3 = dx**3
         d5 = dx**5
         d7 = dx**7
         d9 = dx**9
         d11 = dx**11
         term1 = b11*(d3+d1)/dnu
         term2 = b21*(b22*d7+b23*d5+b24*d3+b25*d1)/(dnu**2)
         term3 = b31*(b32*d11+b33*d9+b34*d7+b35*d5+b36*d3+b37*d1)       &
     &           /(dnu**3)
         dcdf = term1 + term2 + term3
         dcdf = dcdfn - (dconst*(DEXP(-dx*dx/2.0D0)))*dcdf
         Cdf = dcdf
      ENDIF
!
      END SUBROUTINE TCDF
!*==time.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE TIME(X,N)
      IMPLICIT NONE
!*--TIME30314
!*** Start of declarations inserted by SPAG
      REAL absr , ak , al , all , almax , an , an2 , arg1 , arg2 , bw , &
     &     df , dfroun , hold , p , perout , pi , pmsq , ps , pssq , r
      REAL r025 , r975 , rk , rmax , s , sd , sdr , ssq , sum , sum1 ,  &
     &     sum2 , var , varb , wk , X , xbar
      INTEGER i , i2 , iarg1 , iarg2 , idf , ilower , imin , ipr ,      &
     &        irev , j , jmax , jmin , k , kmax , krev , l , ll , llp1 ,&
     &        lm1 , lmax
      INTEGER maxlag , N , n2 , ndiv , nmk , numout , numsp
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT TIME
!
!     PURPOSE--THIS SUBROUTINE PERFORMS A TIME SERIES ANALYSIS
!              ON THE DATA IN THE INPUT VECTOR X.
!              THE ANALYSIS CONSISTS OF THE FOLLOWING--
!              1) A PLOT OF AUTOCORRELATION VERSUS LAG NUMBER;
!              2) A TEST FOR WHITE NOISE (ASSUMING NORMALITY);
!              3) A 'PILOT' SPECTRUM; AND
!              4) 4 OTHER ESTIMATED SPECTRA--EACH BASED
!                 ON A DIFFERING BANDWIDTH.
!
!              IN ORDER THAT THE RESULTS OF THE TIME SERIES ANALYSIS
!              BE VALID AND PROPERLY INTERPRETED, THE INPUT DATA
!              IN X SHOULD BE EQUI-SPACED IN TIME
!              (OR WHATEVER VARIABLE CORRESPONDS TO TIME).
!
!              THE HORIZONTAL AXIS OF THE SPECTRA PRODUCED
!              BY THIS SUBROUTINE IS FREQUENCY.
!              THIS FREQUENCY IS MEASURED IN UNITS OF
!              CYCLES PER 'DATA POINT' OR, MORE PRECISELY, IN
!              CYCLES PER UNIT TIME WHERE
!              'UNIT TIME' IS DEFINED AS THE
!              ELAPSED TIME BETWEEN ADJACENT OBSERVATIONS.
!              THE RANGE OF THE FREQUENCY AXIS IS 0.0 TO 0.5.
!
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED) OBSERVATIONS.
!                      N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--7 TO 11 PAGES (DEPENDING ON
!             THE INPUT SAMPLE SIZE) OF
!             AUTOMATIC PRINTOUT--
!             1) A PLOT OF AUTOCORRELATION VERSUS LAG NUMBER;
!                THIS PLOT MAY TAKE AS LITTLE AS 1
!                OR AS MANY AS 5 PAGES
!                (THE EXACT NUMBER DEPENDING ON
!                THE INPUT SAMPLE SIZE N);
!             2) A TEST FOR WHITE NOISE (ASSUMING NORMALITY);
!             3) A 'PILOT' SPECTRUM; AND
!             4) AN ESTIMATED SPECTRUM BASED ON A
!                BANDWIDTH DERIVED FROM THE DATA SET;
!             5) AN ESTIMATED SPECTRUM BASED ON A
!                BANDWIDTH ONLY 1/2 AS WIDE AS IN 4;
!             6) AN ESTIMATED SPECTRUM BASED ON A
!                BANDWIDTH ONLY 1/4 AS WIDE AS IN 4;
!             7) AN ESTIMATED SPECTRUM BASED ON A
!                BANDWIDTH ONLY 1/8 AS WIDE AS IN 4;
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!                 --THE SAMPLE SIZE N MUST BE GREATER
!                   THAN OR EQUAL TO 3.
!     OTHER DATAPAC   SUBROUTINES NEEDED--PLOTC0, PLOTSP, AND CHSPPF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--THE 'FAST FOURIER TRANSFORM' IS NOT USED
!              IN THIS VERSION OF TIME, BUT WILL BE
!              IMPLEMENTED IN A FUTURE VERSION.
!            --THE USUAL MAXIMUM NUMBER OF LAGS
!              FOR WHICH THE AUTOCORRELATION IS
!              COMPUTED IS N/4 WHERE N IS
!              THE SAMPLE SIZE (LENGTH OF THE
!              DATA RECORD IN THE VECTOR X).
!              THIS RULE IS OVERRIDDEN IN
!              LARGE DATA SETS AND IS REPLACED
!              BY THE RULE THAT THE MAXIMUM
!              NUMBER OF LAGS = 500
!              (WHICH CORRESPONDS TO AN
!              AUTOCORRELATION PLOT COVERING
!              5 COMPUTER PAGES).
!              IF MORE LAGS ARE DESIRED,
!              CHANGE THE VALUE OF THE
!              VARIABLE     MAXLAG
!              WITHIN THIS SUBROUTINE
!              FROM 500 TO WHATEVER DESIRED,
!              AND ALSO CHANGE THE DIMENSION OF
!              THE VECTOR R FROM ITS PRESENT 500 TO HOWEVER
!              MANY LAGS ARE DESIRED.
!            --IF THE INPUT OBSERVATIONS IN X ARE CONSIDERED
!              TO HAVE BEEN COLLECTED 1 SECOND APART IN TIME,
!              THEN THE FREQUENCY AXIS OF THE RESULTING
!              SPECTRA WOULD BE IN UNITS OF HERTZ
!              (= CYCLES PER SECOND).
!            --THE FREQUENCY OF 0.0 CORRESPONDS TO A CYCLE
!              IN THE DATA OF INFINITE (= 1/(0.0))
!              LENGTH OR PERIOD.
!              THE FREQUENCY OF 0.5 CORRESPONDS TO A CYCLE
!              IN THE DATA OF LENGTH = 1/(0.5) = 2 DATA POINTS.
!            --ANY EQUI-SPACED TIME SERIES ANALYSIS IS
!              INTRINSICALLY LIMITED TO DETECTING FREQUENCIES
!              NO LARGER THAN 0.5 CYCLES PER DATA POINT;
!              THIS CORRESPONDS TO THE FACT THAT THE
!              SMALLEST DETECTABLE CYCLE IN THE DATA
!              IS 2 DATA POINTS PER CYCLE.
!     REFERENCES--JENKINS AND WATTS, ESPECIALLY PAGE 290.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1977.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION r(500)
      DIMENSION s(125)
      DIMENSION pssq(6) , pmsq(6) , ps(6) , p(5) , l(4)
      DATA pi/3.14159265358979/
!
      ipr = 6
      ilower = 3
      maxlag = 500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<ilower ) THEN
         WRITE (ipr,99001) ilower
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE TIME   SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (',I6,',INFINITY) ',                &
     &'INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 100
         ENDDO
         WRITE (ipr,99003) hold
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE TIME   SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
         RETURN
      ENDIF
!
!-----START POINT-----------------------------------------------------
!
 100  an = N
!
!     COMPUTE THE SAMPLE MEAN
!
      sum = 0.0
      DO i = 1 , N
         sum = sum + X(i)
      ENDDO
      xbar = sum/an
!
!     COMPUTE THE SAMPLE VARIANCE AND THE SUM OF SQUARED DEVIATIONS
!
      sum = 0.0
      DO i = 1 , N
         sum = sum + (X(i)-xbar)*(X(i)-xbar)
      ENDDO
      ssq = sum
      varb = ssq/an
      var = ssq/(an-1.0)
      sd = SQRT(var)
!
!     COMPUTE THE SAMPLE AUTOCORRELATIONS
!     REFERENCE--JENKINS AND WATTS, PAGES 290 AND 259 (7.1.6)
!
      kmax = N/4
      IF ( N<=32 ) kmax = N/2
      IF ( N<=16 ) kmax = N
      IF ( kmax>maxlag ) kmax = maxlag
      DO k = 1 , kmax
         sum = 0.0
         nmk = N - k
         DO i = 1 , nmk
            j = i + k
            sum = sum + (X(i)-xbar)*(X(j)-xbar)
         ENDDO
         r(k) = sum/ssq
      ENDDO
!
!     PLOT THE SAMPLE AUTOCORRELATIONS
!
      CALL PLOTCO(r,kmax)
      WRITE (ipr,99004)
99004 FORMAT (' ',30X,                                                  &
     & 'AUTOCORRELATION PLOT--PLOT OF SAMPLE AUTOCORRELATION VERSUS LAG'&
     & )
      WRITE (ipr,99005) N , kmax
99005 FORMAT (' ',10X,'THE NUMBER OF OBSERVATIONS = ',I6,10X,           &
     &        'THE NUMBER OF COMPUTED (AND PLOTTED) AUTOCORRELATIONS = '&
     &        ,I6)
!
!     DO A WHITE NOISE ANALYSIS
!
      sdr = 1.0/SQRT(an)
      r975 = 1.96*sdr
      IF ( r975>1.0 ) r975 = 1.0
      r025 = -r975
      numout = 0
      DO k = 1 , kmax
         absr = r(k)
         IF ( absr<0.0 ) absr = -absr
         IF ( absr>r975 ) numout = numout + 1
      ENDDO
      perout = FLOAT(numout)/FLOAT(kmax)
      perout = 100.0*perout
      WRITE (ipr,99017)
      WRITE (ipr,99006) r025 , r975
!
99006 FORMAT (' ',                                                      &
     &'UNDER THE NULL HYPOTHESIS OF WHITE NOISE (AND NORMALITY), A 2-SID&
     &ED 95 PERCENT ACCEPTANCE INTERVAL IS (',F6.4,',',F6.4,')')
      WRITE (ipr,99007)
99007 FORMAT (' ',                                                      &
     &'UNDER THE NULL HYPOTHESIS, ONLY 5 PERCENT (ON THE AVERAGE) OF THE&
     & OBSERVED AUTOCORRELATIONS SHOULD FALL OUTSIDE THIS INTERVAL')
      WRITE (ipr,99008) numout , kmax , perout
99008 FORMAT (' ','IT IS OBSERVED THAT ',I5,' OUT OF THE ',I5,          &
     &        ' (THAT IS, ',F5.1,                                       &
     &' PERCENT) OF THE COMPUTED AUTOCORRELATIONS FALL OUTSIDE OF THIS I&
     &NTERVAL')
      DO i = 1 , 5
         WRITE (ipr,99017)
      ENDDO
      WRITE (ipr,99009) N
99009 FORMAT (' ','THE SAMPLE SIZE = ',I6)
      WRITE (ipr,99010) xbar
99010 FORMAT (' ','THE SAMPLE MEAN = ',E15.8)
      WRITE (ipr,99011) var
99011 FORMAT (' ','THE SAMPLE VARIANCE = ',E15.8)
      WRITE (ipr,99012) sd
99012 FORMAT (' ','THE SAMPLE STANDARD DEVIATION = ',E15.8)
      WRITE (ipr,99013) varb
99013 FORMAT (' ','THE BIASED SAMPLE VARIANCE = ',E15.8)
!
!     COMPUTE THE PILOT SPECTRUM FOR THE REDUCED (2**J) SAMPLE
!     REFERENCE--JENKINS AND WATTS, PAGE 288
!
      DO i = 1 , 20
         ndiv = N/(2**i)
         IF ( ndiv==0 ) i2 = i - 1
         IF ( ndiv==0 ) EXIT
      ENDDO
      IF ( 7<i2 ) i2 = 7
      n2 = 2**i2
      an2 = n2
      DO k = 1 , i2
         sum = 0.0
         imin = 2**k
         jmax = imin/2
         DO i = imin , n2 , imin
            sum1 = 0.0
            sum2 = 0.0
            DO j = 1 , jmax
               iarg1 = i + j - jmax
               iarg2 = iarg1 - jmax
               sum1 = sum1 + X(iarg1)
               sum2 = sum2 + X(iarg2)
            ENDDO
            sum = sum + (sum1-sum2)*(sum1-sum2)
         ENDDO
         pssq(k) = sum/FLOAT(imin)
         pmsq(k) = pssq(k)/an2
         ps(k) = FLOAT(2*imin)*pmsq(k)
         ps(k) = ps(k)/varb
      ENDDO
!
!     FORM THE PILOT SPECTRUM PLOT
!
      DO i = 1 , i2
         irev = i2 - i + 1
         jmin = (120/(2**i)) + 1
         IF ( i==i2 ) jmin = 1
         jmax = 120/(2**(i-1))
         DO j = jmin , jmax
            s(j) = ps(i)
         ENDDO
      ENDDO
      CALL PLOTSP(s,120,0)
      WRITE (ipr,99017)
      WRITE (ipr,99014)
99014 FORMAT (' ',50X,'PILOT SPECTRUM')
!
!     DEFINE 4 LAG WINDOW TRUNCATION POINTS
!     REFERENCE--JENKINS AND WATTS, PAGES 290 AND 260
!
      p(1) = .2
      p(2) = .1
      p(3) = .05
      p(4) = .025
      p(5) = .01
      lmax = 0
      DO i = 1 , 5
         DO k = 1 , kmax
            krev = kmax - k + 1
            rk = r(krev)
            IF ( rk<0.0 ) rk = -rk
            IF ( rk>=p(i) ) lmax = krev
            IF ( rk>=p(i) ) GOTO 200
         ENDDO
      ENDDO
      IF ( lmax==0 ) THEN
         rmax = ABS(r(1))
         DO k = 1 , kmax
            rk = r(k)
            IF ( rk<0.0 ) rk = -rk
            IF ( rk>=rmax ) lmax = k
            IF ( rk>=rmax ) rmax = rk
         ENDDO
      ENDIF
 200  almax = lmax
      l(1) = (3.0/2.0)*almax
      IF ( l(1)<=32 ) lmax = 32
      IF ( l(1)<=32 ) almax = 32.0
      IF ( l(1)<=32 ) l(1) = 32
      IF ( l(1)>=kmax ) lmax = kmax
      IF ( l(1)>=kmax ) almax = kmax
      IF ( l(1)>=kmax ) l(1) = kmax
      l(2) = (almax/2.0) + 0.1
      l(3) = (almax/4.0) + 0.1
      l(4) = (almax/8.0) + 0.1
      IF ( l(4)>=3 ) numsp = 4
      IF ( l(4)<3 ) THEN
         IF ( l(3)>=3 ) numsp = 3
         IF ( l(3)<3 ) THEN
            IF ( l(2)>=3 ) numsp = 2
            IF ( l(2)<3 ) THEN
               IF ( l(1)>=3 ) numsp = 1
               IF ( l(1)<3 ) THEN
                  WRITE (ipr,99015) N
99015             FORMAT (' ',                                          &
     &                   'DUE TO THE SMALL NUMBER OF OBSERVATIONS (N = '&
     &                   ,I6,                                           &
     &     '), THERE ARE NOT ENOUGH LAGS TO PRODUCE A RELIABLE SPECTRUM'&
     &     )
                  RETURN
               ENDIF
            ENDIF
         ENDIF
      ENDIF
!
!     COMPUTE THE 4 SPECTRUM ESTIMATES
!     REFERENCE--JENKINS AND WATTS, PAGES 260 AND 244
!
!     COMPUTE BANDWIDTHS
!     REFERENCE--JENKINS AND WATTS, PAGES 257 AND 252
!
!     COMPUTE DEGREES OF FREEDOM FOR THE SPECTAL DENSITY ESTIMATE AT INDIVIDUAL
!     FREQUENCIES
!     REFERENCE--JENKINS AND WATTS, PAGES 254 AND 252
!
!     COMPUTE 95 PERCENT CONFIDENCE INTERVAL LENGTHS FOR THE LOG SPECTRAL
!     DENSITY ESTIMATES
!     REFERENCE--JENKINS AND WATTS, PAGES 255 AND 252
!
!     WRITE OUT THE 4 SPECTRUM PLOTS
!
      DO i = 1 , numsp
         al = l(i)
         lm1 = l(i) - 1
         DO llp1 = 1 , 121
            ll = llp1 - 1
            all = ll
            sum = 0.0
            DO k = 1 , lm1
               ak = k
               arg1 = pi*ak/al
               arg2 = pi*ak*all/120.0
               wk = 0.0
               IF ( k<=l(i) ) wk = 0.5*(1.0+COS(arg1))
               sum = sum + r(k)*wk*COS(arg2)
            ENDDO
            sum = 2.0 + 4.0*sum
            s(llp1) = sum
         ENDDO
         bw = (4.0/3.0)/FLOAT(l(i))
         df = (8.0/3.0)*an/FLOAT(l(i))
         idf = df + 0.5
         CALL PLOTSP(s,121,idf)
         dfroun = idf
         WRITE (ipr,99017)
         WRITE (ipr,99016) l(i) , bw , dfroun
99016    FORMAT (' ','NUMBER OF LAGS = ',I5,10X,'BANDWIDTH =',F10.3,10X,&
     &           'DEGREES OF FREEDOM = ',F10.3)
      ENDDO
99017 FORMAT (' ')
!
      END SUBROUTINE TIME
!*==tol.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE TOL(X,N)
      IMPLICIT NONE
!*--TOL30717
!*** Start of declarations inserted by SPAG
      REAL a , a0 , a1 , a2 , a3 , a4 , a5 , ak , an , an1 , an2 , an3 ,&
     &     an4 , an5 , an6 , b , c , c1 , c2 , c3
      REAL d , d1 , d2 , d3 , d4 , d5 , d6 , d7 , f , hold , p , pa ,   &
     &     pc , q , r , rsmall , sd , t , tmax , tmin
      REAL u , univ , usmall , var , X , xbar , xmax , xmax2 , xmax3 ,  &
     &     xmin , xmin2 , xmin3 , z , z1
      INTEGER i , ipr , j , k , locmax , locmin , locmn2 , locmn3 ,     &
     &        locmx2 , locmx3 , N , numsec
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT TOL
!
!     PURPOSE--THIS SUBROUTINE COMPUTES NORMAL AND
!              DISTRIBUTION-FREE TOLERANCE LIMITS
!              FOR THE DATA IN THE INPUT VECTOR X.
!              15 NORMAL TOLERANCE LIMITS ARE COMPUTED; AND
!              30 DISTRIBUTION-FREE TOLERANCE LIMITS ARE COMPUTED.
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS.
!                      N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--2 PAGES OF AUTOMATIC PRINTOUT--
!             1 PAGE GIVING NORMAL TOLERANCE LIMITS; AND
!             1 PAGE GIVING DISTRIBUTION-FREE TOLERANCE LIMITS.
!     PRINTING--YES.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--GARDINER AND HULL, TECHNOMETRICS, 1966, PAGES 115-122
!               --WILKS, ANNALS OF MATHEMATICAL STATISTICS, 1941, PAGE 92
!               --MOOD AND GRABLE, PAGES 416-417
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION pa(6) , pc(6) , z1(3) , a(6) , b(6) , c(6) , rsmall(5,6)&
     &          , usmall(6,6)
      DIMENSION tmin(3,6) , tmax(3,6)
      DIMENSION p(10) , c1(10) , c2(10) , c3(10)
!
      DATA pa(1) , pa(2) , pa(3) , pa(4) , pa(5) , pa(6)/50. , 75. ,    &
     &     90. , 95. , 99. , 99.9/
      DATA pc(1) , pc(2) , pc(3)/90. , 95. , 99./
      DATA z1(1) , z1(2) , z1(3)/ - 1.28155157 , -1.64485363 ,          &
     &     -2.32634787/
      DATA a(1) , a(2) , a(3) , a(4) , a(5) , a(6)/.6745 , 1.1504 ,     &
     &     1.6449 , 1.9600 , 2.5758 , 3.2905/
      DATA b(1) , b(2) , b(3) , b(4) , b(5) , b(6)/.33734 , .57335 ,    &
     &     .82140 , .97910 , 1.2889 , 1.64038/
      DATA c(1) , c(2) , c(3) , c(4) , c(5) , c(6)/ - 0.15460 ,         &
     &     -0.02991 , .22044 , .40675 , .85514 , 1.42601/
      DATA rsmall(1,1) , rsmall(1,2) , rsmall(1,3) , rsmall(1,4) ,      &
     &     rsmall(1,5) , rsmall(1,6)/1.0505 , 1.6859 , 2.2844 , 2.6463 ,&
     &     3.3266 , 4.0903/
      DATA rsmall(2,1) , rsmall(2,2) , rsmall(2,3) , rsmall(2,4) ,      &
     &     rsmall(2,5) , rsmall(2,6)/0.8557 , 1.4333 , 2.0078 , 2.3624 ,&
     &     3.0368 , 3.7983/
      DATA rsmall(3,1) , rsmall(3,2) , rsmall(3,3) , rsmall(3,4) ,      &
     &     rsmall(3,5) , rsmall(3,6)/0.7929 , 1.3412 , 1.8979 , 2.2457 ,&
     &     2.9128 , 3.6708/
      DATA rsmall(4,1) , rsmall(4,2) , rsmall(4,3) , rsmall(4,4) ,      &
     &     rsmall(4,5) , rsmall(4,6)/0.7622 , 1.2940 , 1.8388 , 2.1815 ,&
     &     2.8422 , 3.5965/
      DATA rsmall(5,1) , rsmall(5,2) , rsmall(5,3) , rsmall(5,4) ,      &
     &     rsmall(5,5) , rsmall(5,6)/0.7442 , 1.2654 , 1.8019 , 2.1408 ,&
     &     2.7963 , 3.5472/
      DATA usmall(1,1) , usmall(1,2) , usmall(1,3)/0. , 0. , 0./
      DATA usmall(2,1) , usmall(2,2) , usmall(2,3)/7.9579 , 15.9472 ,   &
     &     79.7863/
      DATA usmall(3,1) , usmall(3,2) , usmall(3,3)/3.0808 , 4.4154 ,    &
     &     9.9749/
      DATA usmall(4,1) , usmall(4,2) , usmall(4,3)/2.2658 , 2.9200 ,    &
     &     5.1113/
      DATA usmall(5,1) , usmall(5,2) , usmall(5,3)/1.9393 , 2.3724 ,    &
     &     3.6692/
      DATA usmall(6,1) , usmall(6,2) , usmall(6,3)/1.7621 , 2.0893 ,    &
     &     3.0034/
      DATA p(1) , p(2) , p(3) , p(4) , p(5) , p(6) , p(7) , p(8) ,      &
     &     p(9) , p(10)/50. , 75. , 90. , 95. , 97.5 , 99. , 99.5 ,     &
     &     99.9 , 99.95 , 99.99/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE TOL    SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE TOL &
     &   SUBROUTINE HAS THE VALUE 1 *****')
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE TOL    SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     COMPUTE NORMAL TOLERANCE LIMITS
!
!     COMPUTE THE SAMPLE MEAN
!
         xbar = 0.0
         DO i = 1 , N
            xbar = xbar + X(i)
         ENDDO
         xbar = xbar/an
!
!     COMPUTE THE SAMPLE STANDARD DEVIATION
!
         var = 0.0
         DO i = 1 , N
            var = var + (X(i)-xbar)**2
         ENDDO
         var = var/(an-1.0)
         sd = SQRT(var)
!
!     COMPUTE THE NORMAL TOLERANCE LIMITS
!
         DO i = 1 , 3
            z = z1(i)
            f = N - 1
            IF ( N<=6 ) u = usmall(N,i)
            IF ( N>6 ) THEN
               d1 = 1.0 + z*SQRT(2.0)/SQRT(f)
               d2 = 2.0*(z**2-1.0)/(3.0*f)
               d3 = (z**3-7.0*z)/(9.0*SQRT(2.0)*f**1.5)
               d4 = (6.0*z**4+14.0*z**2-32.0)/(405.0*f**2.0)
               d5 = (9.0*z**5+256.0*z**3-433.0*z)                       &
     &              /(4860.0*SQRT(2.0)*f**2.5)
               d6 = (12.0*z**6-243.0*z**4-923.0*z**2+1472.0)            &
     &              /(25515.0*f**3.0)
               d7 = (3753.0*z**7+4353.0*z**5-289517.0*z**3-289717.0*z)  &
     &              /(9185400.0*SQRT(2.0)*f**3.5)
               univ = d1 + d2 + d3 - d4 + d5 + d6 - d7
               u = 1.0/univ
               u = SQRT(u)
            ENDIF
            DO j = 1 , 6
               r = a(j) + (b(j)/(c(j)+an))
               IF ( N<=5 ) r = rsmall(N,j)
               ak = r*u
               tmin(i,j) = xbar - ak*sd
               tmax(i,j) = xbar + ak*sd
            ENDDO
         ENDDO
!
!     WRITE OUT THE NORMAL TOLERANCE LIMITS
!
         WRITE (ipr,99016)
         WRITE (ipr,99005) N
!
99005    FORMAT (' ','             NORMAL TOLERANCE LIMITS FOR THE ',I6,&
     &           ' OBSERVATIONS')
         WRITE (ipr,99017)
         WRITE (ipr,99006)
99006    FORMAT (' ','             REFERENCE--CRC HANDBOOK, PAGES 32-35'&
     &           )
         WRITE (ipr,99007)
99007    FORMAT (' ',                                                   &
     &'             REFERENCE--GARDINER AND HULL, TECHNOMETRICS, 1966, P&
     &AGES 115-122')
         WRITE (ipr,99017)
         WRITE (ipr,99008) xbar , sd
99008    FORMAT (' ','             SAMPLE MEAN = ',E15.8,               &
     &           '         SAMPLE STANDARD DEVIATION = ',E15.8)
         WRITE (ipr,99017)
         WRITE (ipr,99017)
         DO i = 1 , 3
            DO j = 1 , 6
               WRITE (ipr,99009) pc(i) , pa(j) , tmin(i,j) , tmax(i,j)
99009          FORMAT (' ','WE ARE ',F6.2,' PERCENT CONFIDENT THAT ',   &
     &                 F5.2,                                            &
     &               ' PERCENT OF THE POPULATION IS BETWEEN XBAR-K*S = '&
     &               ,E12.5,' AND XBAR+K*S = ',E12.5)
            ENDDO
            WRITE (ipr,99017)
         ENDDO
!
!
!
!
!     COMPUTE DISTRIBUTION-FREE TOLERANCE LIMITS
!
         k = N/2
         numsec = 3
         IF ( k<numsec ) numsec = k
!
!     DETERMINE THE SMALLEST 3 AND LARGEST 3 OBSERVATIONS
!
         locmin = 1
         xmin = X(1)
         DO i = 1 , N
            IF ( X(i)<=xmin ) locmin = i
            IF ( X(i)<=xmin ) xmin = X(i)
         ENDDO
         locmax = 1
         xmax = X(1)
         DO i = 1 , N
            IF ( X(i)>=xmax ) locmax = i
            IF ( X(i)>=xmax ) xmax = X(i)
         ENDDO
         DO i = 1 , N
            IF ( i/=locmin ) EXIT
         ENDDO
         locmn2 = i
         xmin2 = X(i)
         DO i = 1 , N
            IF ( i/=locmin ) THEN
               IF ( X(i)<=xmin2 ) locmn2 = i
               IF ( X(i)<=xmin2 ) xmin2 = X(i)
            ENDIF
         ENDDO
         DO i = 1 , N
            IF ( i/=locmax ) EXIT
         ENDDO
         locmx2 = i
         xmax2 = X(i)
         DO i = 1 , N
            IF ( i/=locmax ) THEN
               IF ( X(i)>=xmax2 ) locmx2 = i
               IF ( X(i)>=xmax2 ) xmax2 = X(i)
            ENDIF
         ENDDO
         DO i = 1 , N
            IF ( i/=locmin .AND. i/=locmn2 ) EXIT
         ENDDO
         locmn3 = i
         xmin3 = X(i)
         DO i = 1 , N
            IF ( i/=locmin .AND. i/=locmn2 ) THEN
               IF ( X(i)<=xmin3 ) locmn3 = i
               IF ( X(i)<=xmin3 ) xmin3 = X(i)
            ENDIF
         ENDDO
         DO i = 1 , N
            IF ( i/=locmax .AND. i/=locmx2 ) EXIT
         ENDDO
         locmx3 = i
         xmax3 = X(i)
         DO i = 1 , N
            IF ( i/=locmax .AND. i/=locmx2 ) THEN
               IF ( X(i)>=xmax3 ) locmx3 = i
               IF ( X(i)>=xmax3 ) xmax3 = X(i)
            ENDIF
         ENDDO
         an1 = an - 1.0
         an2 = an - 2.0
         an3 = an - 3.0
         an4 = an - 4.0
         an5 = an - 5.0
         an6 = an - 6.0
         DO i = 1 , 10
            d = p(i)/100.0
            c1(i) = (d**an1)*(-an+an1*d)
            c1(i) = 1.0 - c1(i)
            q = 1.0 - d
            t = q*an
            c1(i) = 1.0 + an1*q
            c1(i) = 1.0 - (d**an1)*c1(i)
            c1(i) = c1(i)*100.0
            IF ( numsec/=1 ) THEN
               a0 = 6.0*d*d*d
               a1 = 2.0 - 7.0*d + 11.0*d*d
               a2 = -3.0 + 6.0*d
               a3 = 1.0
               c2(i) = a0 + a1*t + a2*t*t + a3*t*t*t
               c2(i) = 1.0 - (d**an3)*c2(i)/6.0
               c2(i) = c2(i)*100.0
               IF ( numsec/=2 ) THEN
                  a0 = 120.0*d*d*d*d*d
                  a1 = 24.0 - 126.0*d + 274.0*d*d - 326.0*d*d*d +       &
     &                 274.0*d*d*d*d
                  a2 = -50.0 + 205.0*d - 320.0*d*d + 225.0*d*d*d
                  a3 = 35.0 - 100.0*d + 85.0*d*d
                  a4 = -10.0 + 15.0*d
                  a5 = 1.0D0
                  c3(i) = a0 + a1*t + a2*t*t + a3*t*t*t + a4*t*t*t*t +  &
     &                    a5*t*t*t*t*t
                  c3(i) = 1.0 - (d**an5)*c3(i)/120.0
                  c3(i) = c3(i)*100.0
               ENDIF
            ENDIF
         ENDDO
!
!     WRITE OUT THE DISTRIBUTION-FREE TOLERANCE LIMITS
!
         WRITE (ipr,99016)
         WRITE (ipr,99010) N
99010    FORMAT (' ',                                                   &
     &         '            DISTRIBUTION-FREE TOLERANCE LIMITS FOR THE '&
     &         ,I6,' OBSERVATIONS')
         WRITE (ipr,99017)
         WRITE (ipr,99011)
99011    FORMAT (' ',                                                   &
     &           '            REFERENCE--WILKS, ANNALS, 1941, PAGE 92')
         WRITE (ipr,99012)
99012    FORMAT (' ',                                                   &
     &           '            REFERENCE--MOOD AND GRABLE, PAGES 416-417'&
     &           )
         WRITE (ipr,99017)
         WRITE (ipr,99017)
         IF ( numsec/=1 ) THEN
            IF ( numsec/=2 ) THEN
               DO i = 1 , 10
                  WRITE (ipr,99013) c3(i) , p(i) , xmin3 , xmax3
99013             FORMAT (' ','WE ARE ',F6.2,' PERCENT CONFIDENT THAT ',&
     &                    F5.2,                                         &
     &                   ' PERCENT OF THE POPULATION IS BETWEEN X3   = '&
     &                   ,F8.3,' AND X(N-2) = ',F8.3)
               ENDDO
               WRITE (ipr,99017)
            ENDIF
            DO i = 1 , 10
               WRITE (ipr,99014) c2(i) , p(i) , xmin2 , xmax2
99014          FORMAT (' ','WE ARE ',F6.2,' PERCENT CONFIDENT THAT ',   &
     &                 F5.2,                                            &
     &                 ' PERCENT OF THE POPULATION IS BETWEEN X2   = ', &
     &                 F8.3,' AND X(N-1) = ',F8.3)
            ENDDO
            WRITE (ipr,99017)
         ENDIF
         DO i = 1 , 10
            WRITE (ipr,99015) c1(i) , p(i) , xmin , xmax
99015       FORMAT (' ','WE ARE ',F6.2,' PERCENT CONFIDENT THAT ',F5.2, &
     &              ' PERCENT OF THE POPULATION IS BETWEEN XMIN = ',    &
     &              F8.3,' AND XMAX   = ',F8.3)
         ENDDO
      ENDIF
99016 FORMAT ('1')
99017 FORMAT (' ')
!
      END SUBROUTINE TOL
!*==tplt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE TPLT(X,N,Nu)
      IMPLICIT NONE
!*--TPLT31083
!*** Start of declarations inserted by SPAG
      REAL an , cc , hold , pp0025 , pp025 , pp975 , pp9975 , q , sum1 ,&
     &     sum2 , sum3 , tau , W , wbar , WS , X , Y , ybar , yint ,    &
     &     yslope
      INTEGER i , ipr , iupper , N , Nu
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT TPLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES A STUDENT'S T
!              PROBABILITY PLOT (WITH INTEGER
!              DEGREES OF FREEDOM PARAMETER VALUE = NU).
!              THE PROTOTYPE STUDENT'S T DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL X,
!              AND ITS PROBABILITY DENSITY FUNCTION IS GIVEN
!              IN THE REFERENCES BELOW.
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE STUDENT'S T PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE  STUDENT'S T DISTRIBUTION
!              WITH DEGREES OF FREEDOM PARAMETER VALUE = NU.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --NU     = THE INTEGER NUMBER OF DEGREES
!                                OF FREEDOM.
!                                NU SHOULD BE POSITIVE.
!     OUTPUT--A ONE-PAGE STUDENT'S T PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!                 --NU SHOULD BE POSITIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, TPPF, NORPPF,
!                                         PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHMATICS
!                 SERIES 55, 1964, PAGE 949, FORMULA 26.7.5.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGE 102,
!                 FORMULA 11.
!               --FEDERIGHI, 'EXTENDED TABLES OF THE
!                 PERCENTAGE POINTS OF STUDENT'S T
!                 DISTRIBUTION, JOURNAL OF THE
!                 AMERICAN STATISTICAL ASSOCIATION,
!                 1969, PAGES 683-688.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 120-123.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!     UPDATED         --FEBRUARY  1977.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE TPLT   SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99007) N
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE TPLT&
     &   SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         IF ( Nu<=0 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE TPLT   SUBROU&
     &TINE IS NON-POSITIVE *****')
            WRITE (ipr,99007) Nu
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE TPLT   SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     COMPUTE STUDENT'S T DISTRIBUTION ORDER STATISTIC MEDIANS
!
         DO i = 1 , N
            CALL TPPF(W(i),Nu,W(i))
         ENDDO
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     COMPUTE THE TAIL LENGTH MEASURE OF THE DISTRIBUTION.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         q = .9975
         CALL TPPF(q,Nu,pp9975)
         q = .0025
         CALL TPPF(q,Nu,pp0025)
         q = .975
         CALL TPPF(q,Nu,pp975)
         q = .025
         CALL TPPF(q,Nu,pp025)
         tau = (pp9975-pp0025)/(pp975-pp025)
         WRITE (ipr,99005) Nu , tau , N
!
99005    FORMAT (' ',                                                   &
     &        'STUDENT''S T PROBABILITY PLOT WITH DEGREES OF FREEDOM = '&
     &        ,I8,1X,'(TAU = ',E15.8,')',11X,'THE SAMPLE SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         sum2 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
            sum2 = sum2 + W(i)
         ENDDO
         ybar = sum1/an
         wbar = sum2/an
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + (Y(i)-ybar)*(W(i)-wbar)
            sum3 = sum3 + (W(i)-wbar)*(W(i)-wbar)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99006) cc , yint , yslope
99006    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
99007 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
!
      END SUBROUTINE TPLT
!*==tppf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE TPPF(P,Nu,Ppf)
      IMPLICIT NONE
!*--TPPF31281
!*** Start of declarations inserted by SPAG
      INTEGER ipass , ipr , maxit , Nu
      REAL P , Ppf , ppfn
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT TPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE STUDENT'S T DISTRIBUTION
!              WITH INTEGER DEGREES OF FREEDOM PARAMETER = NU.
!              THE STUDENT'S T DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL X,
!              AND ITS PROBABILITY DENSITY FUNCTION IS GIVEN
!              IN THE REFERENCES BELOW.
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 (EXCLUSIVELY)
!                                AND 1.0 (EXCLUSIVELY))
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!                     --NU     = THE INTEGER NUMBER OF DEGREES
!                                OF FREEDOM.
!                                NU SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT FUNCTION .
!             VALUE PPF FOR THE STUDENT'S T DISTRIBUTION
!             WITH DEGREES OF FREEDOM PARAMETER = NU.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--NU SHOULD BE A POSITIVE INTEGER VARIABLE.
!                 --P SHOULD BE BETWEEN 0.0 (EXCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NORPPF.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--DSIN, DCOS, DSQRT, DATAN.
!     MODE OF INTERNAL OPERATIONS--DOUBLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--FOR NU = 1 AND NU = 2, THE PERCENT POINT FUNCTION
!              FOR THE T DISTRIBUTION EXISTS IN SIMPLE CLOSED FORM
!              AND SO THE COMPUTED PERCENT POINTS ARE EXACT.
!            --FOR OTHER SMALL VALUES OF NU (NU BETWEEN 3 AND 6,
!              INCLUSIVELY), THE APPROXIMATION
!              OF THE T PERCENT POINT BY THE FORMULA
!              GIVEN IN THE REFERENCE BELOW IS AUGMENTED
!              BY 3 ITERATIONS OF NEWTON'S METHOD FOR
!              ROOT DETERMINATION.
!              THIS IMPROVES THE ACCURACY--ESPECIALLY FOR
!              VALUES OF P NEAR 0 OR 1.
!     REFERENCES--NATIONAL BUREAU OF STANDARDS APPLIED MATHMATICS
!                 SERIES 55, 1964, PAGE 949, FORMULA 26.7.5.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGE 102,
!                 FORMULA 11.
!               --FEDERIGHI, 'EXTENDED TABLES OF THE
!                 PERCENTAGE POINTS OF STUDENT'S T
!                 DISTRIBUTION, JOURNAL OF THE
!                 AMERICAN STATISTICAL ASSOCIATION,
!                 1969, PAGES 683-688.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 120-123.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DOUBLE PRECISION pi
      DOUBLE PRECISION sqrt2
      DOUBLE PRECISION dp
      DOUBLE PRECISION dnu
      DOUBLE PRECISION term1 , term2 , term3 , term4 , term5
      DOUBLE PRECISION dppfn
      DOUBLE PRECISION dppf , dcon , darg , z , s , c
      DOUBLE PRECISION b21
      DOUBLE PRECISION b31 , b32 , b33 , b34
      DOUBLE PRECISION b41 , b42 , b43 , b44 , b45
      DOUBLE PRECISION b51 , b52 , b53 , b54 , b55 , b56
      DOUBLE PRECISION d1 , d3 , d5 , d7 , d9
      DATA pi/3.14159265358979D0/
      DATA sqrt2/1.414213562D0/
      DATA b21/0.25D0/
      DATA b31 , b32 , b33 , b34/0.01041666666667D0 , 5.0D0 , 16.0D0 ,  &
     &     3.0D0/
      DATA b41 , b42 , b43 , b44 , b45/0.00260416666667D0 , 3.0D0 ,     &
     &     19.0D0 , 17.0D0 , -15.0D0/
      DATA b51 , b52 , b53 , b54 , b55 , b56/0.00001085069444D0 ,       &
     &     79.0D0 , 776.0D0 , 1482.0D0 , -1920.0D0 , -945.0D0/
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<=0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE TPPF   SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         dnu = Nu
         dp = P
         maxit = 5
!
         IF ( Nu>=3 ) THEN
!
!     TREAT THE NU GREATER THAN OR EQUAL TO 3 CASE
!
            CALL NORPPF(P,ppfn)
            dppfn = ppfn
            d1 = dppfn
            d3 = dppfn**3
            d5 = dppfn**5
            d7 = dppfn**7
            d9 = dppfn**9
            term1 = d1
            term2 = b21*(d3+d1)/dnu
            term3 = b31*(b32*d5+b33*d3+b34*d1)/(dnu**2)
            term4 = b41*(b42*d7+b43*d5+b44*d3+b45*d1)/(dnu**3)
            term5 = b51*(b52*d9+b53*d7+b54*d5+b55*d3+b56*d1)/(dnu**4)
            dppf = term1 + term2 + term3 + term4 + term5
            Ppf = dppf
            IF ( Nu>=7 ) RETURN
            IF ( Nu==3 ) THEN
!
!     AUGMENT THE RESULTS FOR THE NU = 3 CASE
!
               dcon = pi*(dp-0.5D0)
               darg = dppf/DSQRT(dnu)
               z = DATAN(darg)
               DO ipass = 1 , maxit
                  s = DSIN(z)
                  c = DCOS(z)
                  z = z - (z+s*c-dcon)/(2.0D0*c*c)
               ENDDO
               Ppf = DSQRT(dnu)*s/c
               RETURN
            ELSEIF ( Nu==4 ) THEN
!
!     AUGMENT THE RESULTS FOR THE NU = 4 CASE
!
               dcon = 2.0D0*(dp-0.5D0)
               darg = dppf/DSQRT(dnu)
               z = DATAN(darg)
               DO ipass = 1 , maxit
                  s = DSIN(z)
                  c = DCOS(z)
                  z = z - ((1.0D0+0.5D0*c*c)*s-dcon)/(1.5D0*c*c*c)
               ENDDO
               Ppf = DSQRT(dnu)*s/c
               RETURN
            ELSEIF ( Nu==5 ) THEN
!
!     AUGMENT THE RESULTS FOR THE NU = 5 CASE
!
               dcon = pi*(dp-0.5D0)
               darg = dppf/DSQRT(dnu)
               z = DATAN(darg)
               DO ipass = 1 , maxit
                  s = DSIN(z)
                  c = DCOS(z)
                  z = z - (z+(c+(2.0D0/3.0D0)*c*c*c)*s-dcon)            &
     &                /((8.0D0/3.0D0)*c**4)
               ENDDO
               Ppf = DSQRT(dnu)*s/c
               RETURN
            ELSEIF ( Nu==6 ) THEN
!
!     AUGMENT THE RESULTS FOR THE NU = 6 CASE
!
               dcon = 2.0D0*(dp-0.5D0)
               darg = dppf/DSQRT(dnu)
               z = DATAN(darg)
               DO ipass = 1 , maxit
                  s = DSIN(z)
                  c = DCOS(z)
                  z = z - ((1.0D0+0.5D0*c*c+0.375D0*c**4)*s-dcon)       &
     &                /((15.0D0/8.0D0)*c**5)
               ENDDO
               Ppf = DSQRT(dnu)*s/c
               GOTO 99999
            ENDIF
         ELSEIF ( Nu==1 ) THEN
!
!     TREAT THE NU = 1 (CAUCHY) CASE
!
            darg = pi*dp
            Ppf = -DCOS(darg)/DSIN(darg)
            RETURN
         ELSEIF ( Nu==2 ) THEN
!
!     TREAT THE NU = 2 CASE
!
            term1 = sqrt2/2.0D0
            term2 = 2.0D0*dp - 1.0D0
            term3 = DSQRT(dp*(1.0D0-dp))
            Ppf = term1*term2/term3
            RETURN
         ELSE
            WRITE (ipr,99003)
99003       FORMAT (' ','INTERNAL ERROR IN TPPF SUBROUTINE')
            Ppf = 0.0
            RETURN
         ENDIF
      ENDIF
      RETURN
!
99999 END SUBROUTINE TPPF
!*==tran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE TRAN(N,Nu,Iseed,X)
      IMPLICIT NONE
!*--TRAN31505
!*** Start of declarations inserted by SPAG
      REAL anu , arg1 , arg2 , pi , sum , X , y , z , znorm
      INTEGER i , ipr , Iseed , j , N , Nu
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT TRAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE STUDENT'S T DISTRIBUTION
!              WITH INTEGER DEGREES OF FREEDOM PARAMETER = NU.
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!                     --NU     = THE INTEGER DEGREES OF FREEDOM
!                                (PARAMETER) FOR THE T
!                                DISTRIBUTION.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE STUDENT'S T DISTRIBUTION
!             WITH DEGREES OF FREEDOM PARAMETER = NU.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!                 --NU SHOULD BE A POSITIVE INTEGER VARIABLE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG, SQRT, SIN, COS.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     REFERENCES--MOOD AND GRABLE, INTRODUCTION TO THE
!                 THEORY OF STATISTICS, 1963, PAGE 233.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGE 94.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGE 121.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82.6
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
      DIMENSION y(2) , z(2)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
!-----DATA STATEMENTS-------------------------------------------------
!
      DATA pi/3.14159265359/
!
      ipr = 6
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE TRAN   SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99003) N
         RETURN
      ELSEIF ( Nu<=0 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE TRAN   SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99003) Nu
         RETURN
      ELSE
!
!     GENERATE N STUDENT'S T RANDOM NUMBERS
!     USING THE DEFINITION THAT
!     A STUDENT'S T VARIATE WITH NU DEGREES OF FREEDOM
!     EQUALS A NORMAL VARIATE DIVIDED BY
!     A STANDARDIZED CHI VARIATE
!     (WHERE THE LATTER EQUALS SQRT(CHI-SQUARED/NU).
!     FIRST GENERATE A NORMAL RANDOM NUMBER,
!     THEN GENERATE A STANDARDIZED CHI RANDOM NUMBER,
!     THEN FORM THE RATIO OF THE FIRST DIVIDED BY
!     THE SECOND.
!
         anu = Nu
         DO i = 1 , N
!
            CALL UNIRAN(2,Iseed,y)
            arg1 = -2.0*ALOG(y(1))
            arg2 = 2.0*pi*y(2)
            znorm = (SQRT(arg1))*(COS(arg2))
!
            sum = 0.0
            DO j = 1 , Nu , 2
               CALL UNIRAN(2,Iseed,y)
               arg1 = -2.0*ALOG(y(1))
               arg2 = 2.0*pi*y(2)
               z(1) = (SQRT(arg1))*(COS(arg2))
               z(2) = (SQRT(arg1))*(SIN(arg2))
               sum = sum + z(1)*z(1)
               IF ( j/=Nu ) sum = sum + z(2)*z(2)
            ENDDO
!
            X(i) = znorm/SQRT(sum/anu)
!
         ENDDO
      ENDIF
99003 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
!
      END SUBROUTINE TRAN
!*==trim.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE TRIM(X,N,P1,P2,Iwrite,Xtrim)
      IMPLICIT NONE
!*--TRIM31645
!*** Start of declarations inserted by SPAG
      REAL ak , an , hold , P1 , P2 , perp1 , perp2 , perp3 , psum ,    &
     &     sum , WS , X , Xtrim , Y
      INTEGER i , ipr , istart , istop , iupper , Iwrite , k , N , np1 ,&
     &        np2
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT TRIM
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE TRIMMED MEAN
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE TRIMMING IS SUCH THAT
!              THE LOWER 100*P1 % OF THE DATA IS TRIMMED OFF
!              AND THE UPPER 100*P2 % OF THE DATA IS TRIMMED OFF.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --P1     = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                WHICH DEFINES WHAT FRACTION
!                                OF THE LOWER ORDER STATISTICS
!                                IS TO BE TRIMMED OFF
!                                BEFORE COMPUTING THE TRIMMED MEAN.
!                     --P2     = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                WHICH DEFINES WHAT FRACTION
!                                OF THE UPPER ORDER STATISTICS
!                                IS TO BE TRIMMED OFF
!                                BEFORE COMPUTING THE TRIMMED MEAN.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE TRIMMED MEAN
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE TRIMMED MEAN
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XTRIM  = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE TRIMMED MEAN
!                                WHERE 100*P1 % OF THE SMALLEST
!                                AND 100*P2 % OF THE LARGEST
!                                ORDERED OBSERVATIONS HAVE BEEN
!                                TRIMMED AWAY BEFORE COMPUTING THE
!                                MEAN OF THE REMAINING OBSERVATIONS
!                                IN THE MIDDLE.
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE TRIMMED MEAN
!             WHERE 100*P1 % OF THE SMALLEST
!             AND   100*P2 % OF THE LARGEST
!             ORDERED OBSERVATIONS HAVE BEEN TRIMMED AWAY.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 15000.
!                 --P1 SHOULD BE NON-NEGATIVE.
!                 --P1 SHOULD BE SMALLER THAN 1.0
!                 --P2 SHOULD BE NON-NEGATIVE.
!                 --P2 SHOULD BE SMALLER THAN 1.0
!                 --THE SUM OF P1 AND P2 SHOULD BE
!                   SMALLER THAN 1.0.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--DAVID, ORDER STATISTICS, 1970, PAGES 126-130, 136.
!               --CROW AND SIDDIQUI, 'ROBUST ESTIMATION OF LOCATION',
!                 JOURNAL OF THE AMERICAN STATISTICAL ASSOCIATION,
!                 1967, PAGES 357, 387.
!               --FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY, 1969).
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(15000)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
!
      ipr = 6
      iupper = 15000
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      an = N
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE TRIM   SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE TRIM&
     &   SUBROUTINE HAS THE VALUE 1 *****')
            Xtrim = X(1)
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE TRIM   SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            Xtrim = X(1)
         ENDIF
         GOTO 100
 50      IF ( P1<0.0 .OR. P1>=1.0 ) THEN
            WRITE (ipr,99005)
99005       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE TRIM   SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0.0,1.0)   INTERVAL *****')
            WRITE (ipr,99017) P1
            Xtrim = 0.0
            RETURN
         ELSEIF ( P2<0.0 .OR. P2>=1.0 ) THEN
            WRITE (ipr,99006)
99006       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE FOURTH INPUT ARGUMENT TO THE TRIM   SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0.0,1.0)   INTERVAL *****')
            WRITE (ipr,99017) P2
            Xtrim = 0.0
            RETURN
         ELSE
            psum = P1 + P2
            IF ( psum<0.0 .OR. psum>=1.0 ) THEN
               WRITE (ipr,99007)
99007          FORMAT (' ',                                             &
     &                 '***** FATAL ERROR--THE SUM OF INPUT ARGUMENTS ',&
     &      '3 AND 4 TO THE TRIM   SUBROUTINE IS OUTSIDE THE ALLOWABLE '&
     &      ,'(0.0,1.0) INTERVAL *****')
               WRITE (ipr,99008) P1
99008          FORMAT (' ','                  INPUT ARGUMENT 3   ',     &
     &                 '                 = ',E15.8)
               WRITE (ipr,99009) P2
99009          FORMAT (' ','                  INPUT ARGUMENT 4   ',     &
     &                 '                 = ',E15.8)
               WRITE (ipr,99010) psum
99010          FORMAT (' ','                  INPUT ARGUMENT 3 + ',     &
     &                 'INPUT ARGUMENT 4 = ',E15.8)
               Xtrim = 0.0
               RETURN
            ELSE
!
!-----START POINT-----------------------------------------------------
!
               CALL SORT(X,N,Y)
!
               an = N
               np1 = P1*an + 0.0001
               istart = np1 + 1
               np2 = P2*an + 0.0001
               istop = N - np2
               sum = 0.0
               k = 0
               IF ( istart>istop ) THEN
                  WRITE (ipr,99011)
99011             FORMAT (' ','INTERNAL ERROR IN TRIM   SUBROUTINE--',  &
     &                   'THE START INDEX IS HIGHER THAN THE STOP INDEX'&
     &                   )
                  Xtrim = 0.0
                  RETURN
               ELSE
                  DO i = istart , istop
                     k = k + 1
                     sum = sum + X(i)
                  ENDDO
                  ak = k
                  Xtrim = sum/ak
               ENDIF
            ENDIF
         ENDIF
      ENDIF
!
 100  IF ( Iwrite==0 ) RETURN
      perp1 = 100.0*P1
      perp2 = 100.0*P2
      perp3 = 100.0 - perp1 - perp2
      WRITE (ipr,99012)
99012 FORMAT (' ')
      WRITE (ipr,99013) N , Xtrim
99013 FORMAT (' ','THE SAMPLE TRIMMED MEAN OF THE ',I6,' OBSERVATIONS', &
     &        ' IS ',E15.8)
      WRITE (ipr,99014) perp1 , np1
99014 FORMAT (' ',8X,F10.4,' PERCENT (= ',I6,' OBSERVATIONS) ',         &
     &        'OF THE DATA WERE TRIMMED     FROM BELOW')
      WRITE (ipr,99015) perp2 , np2
99015 FORMAT (' ',8X,F10.4,' PERCENT (= ',I6,' OBSERVATIONS) ',         &
     &        'OF THE DATA WERE TRIMMED     FROM ABOVE')
      WRITE (ipr,99016) perp3 , k
99016 FORMAT (' ',8X,F10.4,' PERCENT (= ',I6,' OBSERVATIONS) ',         &
     &        ' OF THE DATA REMAIN IN THE MIDDLE AFTER THE TRIMMING')
99017 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
      END SUBROUTINE TRIM
!*==unicdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE UNICDF(X,Cdf)
      IMPLICIT NONE
!*--UNICDF31863
!*** Start of declarations inserted by SPAG
      REAL Cdf , X
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT UNICDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR THE UNIFORM (RECTANGULAR)
!              DISTRIBUTION ON THE UNIT INTERVAL (0,1).
!              THIS DISTRIBUTION HAS MEAN = 0.5
!              AND STANDARD DEVIATION = SQRT(1/12) = 0.28867513.
!              THIS DISTRIBUTION HAS THE PROBABILITY
!              DENSITY FUNCTION F(X) = 1.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--X SHOULD BE BETWEEN 0 AND 1, INCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 57-74.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( X<0.0 .OR. X>1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE UNIC&
     &DF SUBROUTINE IS OUTSIDE THE USUAL (0,1) INTERVAL *****')
         WRITE (ipr,99002) X
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         IF ( X<0.0 ) Cdf = 0.0
         IF ( X>1.0 ) Cdf = 1.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         Cdf = X
      ENDIF
!
      END SUBROUTINE UNICDF
!*==unimed.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE UNIMED(N,X)
      IMPLICIT NONE
!*--UNIMED31930
!*** Start of declarations inserted by SPAG
      REAL ai , an , gam , X
      INTEGER i , imax , ipr , irev , N , nevodd , nhalf
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT UNIMED
!
!     PURPOSE--THIS SUBROUTINE GENERATES THE N ORDER STATISTIC MEDIANS
!              FROM THE UNIFORM (RECTANGULAR)
!              DISTRIBUTION ON THE UNIT INTERVAL (0,1).
!              THIS DISTRIBUTION HAS MEAN = 0.5
!              AND STANDARD DEVIATION = SQRT(1/12) = 0.28867513.
!              THIS DISTRIBUTION HAS THE PROBABILITY
!              DENSITY FUNCTION F(X) = 1.
!              THIS SUBROUTINE IS A SUPPORT SUBROUTINE FOR
!              ALL OF THE PROBABILITY PLOT SUBROUTINES
!              IN DATAPAC; IT IS RARELY USED BY THE
!              DATA ANALYST DIRECTLY.
!              A PROBABILITY PLOT FOR A GENERAL DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE I-TH ORDER STATISTIC MEDIAN FOR A GENERAL
!              DISTRIBUTION IS OBTAINED BY TRANSFORMING
!              THE I-TH UNIFORM ORDER STATISTIC MEDIAN
!              BY THE PERCENT POINT FUNCTION OF THE DESIRED
!              DISTRIBUTION--HENCE THE IMPORTANCE OF BEING ABLE TO
!              GENERATE UNIFORM ORDER STATISTIC MEDIANS.
!              IT IS OF THEROETICAL INTEREST TO NOTE THAT
!              THE I-TH UNIFORM ORDER STATISTIC MEDIAN
!              IN A SAMPLE OF SIZE N IS IDENTICALLY THE
!              MEDIAN OF THE BETA DISTRIBUTION
!              WITH PARAMETERS I AND N-I+1.
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF UNIFORM ORDER STATISTIC MEDIANS
!                                TO BE GENERATED.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                UNIFORM ORDER STATISTIC MEDIANS
!                                WILL BE PLACED.
!     OUTPUT--THE N ORDER STATISTIC MEDIANS
!             FROM THE RECTANGULAR DISTRIBUTION ON (0,1).
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, 'THE PROBABILITY PLOT CORRELATION COEFFICIENT
!                 TEST FOR NORMALITY', TECHNOMETRICS, 1975, PAGES 111-117.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE UNIMED SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE UNIM&
     &ED SUBROUTINE HAS THE VALUE 1 *****')
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
         an = N
!
!     COMPUTE THE MEDIANS FOR THE FIRST AND LAST ORDER STATISTICS
!
         X(N) = 0.5**(1.0/an)
         X(1) = 1.0 - X(N)
!
!     DETERMINE IF AN ODD OR EVEN SAMPLE SIZE
!
         nhalf = (N/2) + 1
         nevodd = 2*(N/2)
         IF ( N/=nevodd ) X(nhalf) = 0.5
         IF ( N<=3 ) RETURN
!
!     COMPUTE THE MEDIANS FOR THE OTHER ORDER STATISTICS
!
         gam = 0.3175
         imax = N/2
         DO i = 2 , imax
            ai = i
            irev = N - i + 1
            X(i) = (ai-gam)/(an-2.0*gam+1.0)
            X(irev) = 1.0 - X(i)
         ENDDO
      ENDIF
!
      END SUBROUTINE UNIMED
!*==unipdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE UNIPDF(X,Pdf)
      IMPLICIT NONE
!*--UNIPDF32047
!*** Start of declarations inserted by SPAG
      INTEGER ipr
      REAL Pdf , X
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT UNIPDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PROBABILITY DENSITY
!              FUNCTION VALUE FOR THE UNIFORM (RECTANGULAR)
!              DISTRIBUTION ON THE UNIT INTERVAL (0,1).
!              THIS DISTRIBUTION HAS MEAN = 0.5
!              AND STANDARD DEVIATION = SQRT(1/12) = 0.28867513.
!              THIS DISTRIBUTION HAS THE PROBABILITY
!              DENSITY FUNCTION F(X) = 1.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE AT
!                                WHICH THE PROBABILITY DENSITY
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--PDF    = THE SINGLE PRECISION PROBABILITY
!                                DENSITY FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PROBABILITY DENSITY
!             FUNCTION VALUE PDF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--X SHOULD BE BETWEEN 0 AND 1, INCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 57-74.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( X<0.0 .OR. X>1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE UNIP&
     &DF SUBROUTINE IS OUTSIDE THE USUAL (0,1) INTERVAL *****')
         WRITE (ipr,99002) X
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         Pdf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         Pdf = 1.0
      ENDIF
!
      END SUBROUTINE UNIPDF
!*==uniplt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE UNIPLT(X,N)
      IMPLICIT NONE
!*--UNIPLT32113
!*** Start of declarations inserted by SPAG
      REAL an , cc , hold , sum1 , sum2 , sum3 , tau , W , wbar , WS ,  &
     &     X , Y , ybar , yint , yslope
      INTEGER i , ipr , iupper , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT UNIPLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES A UNIFORM
!              PROBABILITY PLOT.
!              THE PROTOTYPE UNIFORM DISTRIBUTION USED HEREIN
!              IS DEFINED ON THE UNIT INTERVAL (0,1).
!              THIS DISTRIBUTION HAS MEAN = 0.5
!              AND STANDARD DEVIATION = SQRT(1/12) = 0.28867513.
!              THIS DISTRIBUTION HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = 1.
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE UNIFORM PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE UNIFORM DISTRIBUTION.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!     OUTPUT--A ONE-PAGE UNIFORM PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 57-74.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
!
      DATA tau/1.04736842/
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE UNIPLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE UNIP&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         hold = X(1)
         DO i = 2 , N
            IF ( X(i)/=hold ) GOTO 50
         ENDDO
         WRITE (ipr,99004) hold
99004    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE UNIPLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         WRITE (ipr,99005) tau , N
!
99005    FORMAT (' ','UNIFORM PROBABILITY PLOT (TAU = ',E15.8,')',55X,  &
     &           'THE SAMPLE SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
         ENDDO
         ybar = sum1/an
         wbar = 0.5
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + (W(i)-0.5)*(Y(i)-ybar)
            sum3 = sum3 + (W(i)-0.5)*(W(i)-0.5)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99006) cc , yint , yslope
99006    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
!
      END SUBROUTINE UNIPLT
!*==unippf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE UNIPPF(P,Ppf)
      IMPLICIT NONE
!*--UNIPPF32268
!*** Start of declarations inserted by SPAG
      INTEGER ipr
      REAL P , Ppf
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT UNIPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE UNIFORM (RECTANGULAR)
!              DISTRIBUTION ON THE UNIT INTERVAL (0,1).
!              THIS DISTRIBUTION HAS MEAN = 0.5
!              AND STANDARD DEVIATION = SQRT(1/12) = 0.28867513.
!              THIS DISTRIBUTION HAS THE PROBABILITY
!              DENSITY FUNCTION F(X) = 1.
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT
!             FUNCTION VALUE PPF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0 AND 1.0, INCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 57-74.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<0.0 .OR. P>1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE UNIPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         Ppf = P
      ENDIF
!
      END SUBROUTINE UNIPPF
!*==uniran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE UNIRAN(N,Iseed,X)
      IMPLICIT NONE
!*--UNIRAN32343
!*** Start of declarations inserted by SPAG
      REAL ak , am1 , X
      INTEGER i , ipr , Iseed , iseed3 , j , j0 , j1 , k , k0 , k1 , l ,&
     &        m , m1 , m2 , mdig , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT UNIRAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE UNIFORM (RECTANGULAR)
!              DISTRIBUTION ON THE UNIT INTERVAL (0,1).
!              THIS DISTRIBUTION HAS MEAN = 0.5
!              AND STANDARD DEVIATION = SQRT(1/12) = 0.28867513.
!              THIS DISTRIBUTION HAS THE PROBABILITY
!              DENSITY FUNCTION F(X) = 1.
!
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!                     --ISEED  = AN INTEGER ISEED VALUE
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE RECTANGULAR DISTRIBUTION ON (0,1).
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER           SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!
!     ALGORITHM--FIBONACCI GENERATOR
!                AS DEFINED BY GEORGE MARSAGLIA.
!
!     NOTE--THIS GENERATOR IS TRANSPORTABLE.
!           IT IS NOT MACHINE-INDEPENDENT
!           IN THE SENSE THAT FOR A GIVEN VALUE
!           OF THE INPUT SEED ISEED AND FOR A GIVEN VALUE
!           OF MDIG (TO BE DEFINED BELOW),
!           THE SAME SEQUENCE OF UNIRFORM RANDOM
!           NUMBERS WILL RESULT ON DIFFERENT COMPUTERS
!           (VAX, PRIME, PERKIN-ELMER, IBM, UNIVAC, HONEYWELL, ETC.)
!
!     NOTE--IF MDIG = 32 AND IF ISEED = 305,
!           THEN THE OUTPUT FROM THIS GENERATOR SHOULD BE AS FOLLOWS--
!           THE FIRST      NUMBER TO RESULT IS .4771580...
!           THE SECOND     NUMBER TO RESULT IS .4219293...
!           THE THIRD      NUMBER TO RESULT IS .6646181...
!           ...
!           THE THOUSANDTH NUMBER TO RESULT IS .2036834...
!
!     NOTE--IF MDIG = 16 AND IF ISEED = 305,
!           THEN THE OUTPUT FROM THIS GENERATOR SHOULD BE AS FOLLOWS--
!           THE FIRST      NUMBER TO RESULT IS .027832881...
!           THE SECOND     NUMBER TO RESULT IS .56102176...
!           THE THIRD      NUMBER TO RESULT IS .41456343...
!           ...
!           THE THOUSANDTH NUMBER TO RESULT IS .19797357...
!
!     NOTE--IT IS RECOMMENDED THAT UPON
!           IMPLEMENTATION OF DATAPLOT, THE OUTPUT
!           FROM UNIRAN BE CHECKED FOR AGREEMENT
!           WITH THE ABOVE SAMPLE OUTPUT.
!           ALSO, THERE ARE MANY ANALYSIS AND DIAGNOSTIC
!           TOOLS IN DATAPLOT THAT WILL ALLOW THE
!           TESTING OF THE RANDOMNESS AND UNIFORMITY
!           OF THIS GENERATOR.
!           SUCH CHECKING IS ESPECIALLY IMPORTANT
!           IN LIGHT OF THE FACT THAT OTHER DATAPLOT RANDOM
!           NUMBER GENERATOR SUBROUTINES (NORRAN--NORMAL,
!           LOGRAN--LOGISTIC, ETC.) ALL MAKE USE OF INTERMEDIATE
!           OUTPUT FROM UNIRAN.
!
!     NOTE--THE OUTPUT FROM THIS SUBROUTINE DEPENDS
!           ON THE INPUT SEED (ISEED) AND ON THE
!           VALUE OF MDIG.
!           MDIG MAY NOT BE SMALLER THAN 16.
!           MDIG MAY NOT BE LARGER THAN MAX INTEGER ON YOUR COMPUTER.
!
!     NOTE--BECAUSE OF THE PREPONDERANCE OF MAINFRAMES
!           WHICH HAVE WORDS OF 32 BITS AND LARGER
!           (E.G, VAX (= 32 BITS), UNIVAC (= 36 BITS), CDC (= 60 BITS), ETC.)
!           MDIG HAS BEEN SET TO 32.
!           THUS THE SAME SEQUENCE OF RANDOM NUMBERS SHOULD RESULT
!           ON ALL OF THESE COMPUTERS.
!
!     NOTE--FOR SMALLER WORD SIZE COMPUTERS (E.G., 24-BIT AND 16-BIT),
!           THE VALUE OF MDIG SHOULD BE CHANGED TO 24 OR 16.
!           IN SUCH CASE, THE OUTPUT WILL NOT BE IDENTICAL TO
!           THE OUTPUT WHEN MDIG = 32.
!
!     NOTE--THE CYCLE OF THE RANDOM NUMBERS DEPENDS ON MDIG.
!           THE CYCLE FROM MDIG = 32 IS LONG ENOUGH FOR MOST
!           PRACTICAL APPLICATIONS.
!           IF A LONGER CYCLE IS DESIRED, THEN INCREASE MDIG.
!
!     NOTE--THE SEED MAY BE ANY POSITIVE INTEGER.
!           NO APPRECIABLE DIFFERENCE IN THE QUALITY
!           OF THE RANDOM NUMBERS HAS BEEN NOTED
!           BY THE CHOICE OF THE SEED.  THERE IS NO
!           NEED TO USE PRIMES, NOR TO USE EXCEPTIONALLY
!           LARGE NUMBERS, ETC.
!
!     REFERENCES--MARSAGLIA G., "COMMENTS ON THE PERFECT UNIFORM RANDOM
!                 NUMBER GENERATOR", UNPUBLISHED NOTES, WASH S. U.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 57-74.
!     WRITTEN BY--JAMES BLUE
!                 SCIENTIFIC COMPUTING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!               --DAVID KAHANER
!                 SCIENTIFIC COMPUTING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!               --GEORGE MARSAGLIA
!                 COMPUTER SCIENCE DEPARTMENT
!                 WASHINGTON STATE UNIVERSITY
!               --JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!
!     LANGUAGE--ANSI FORTRAN (1977)
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --AUGUST    1974.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --NOVEMBER  1981.
!     UPDATED         --MAY       1982.
!     UPDATED         --MARCH     1984.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
!
      DIMENSION m(17)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
!-----SAVE STATEMENTS-------------------------------------------------
!
      SAVE i , j , m , m1 , m2
!
!-----DATA STATEMENTS-------------------------------------------------
!
      DATA m(1) , m(2) , m(3) , m(4) , m(5) , m(6) , m(7) , m(8) ,      &
     &     m(9) , m(10) , m(11) , m(12) , m(13) , m(14) , m(15) ,       &
     &     m(16) , m(17)/30788 , 23052 , 2053 , 19346 , 10646 , 19427 , &
     &     23975 , 19049 , 10949 , 19693 , 29746 , 26748 , 2796 ,       &
     &     23890 , 29168 , 31924 , 16499/
      DATA m1 , m2 , i , j/32767 , 256 , 5 , 17/
!
      ipr = 6
!
!-----START POINT-----------------------------------------------------
!
!               ********************************************
!               **  STEP 1--                              **
!               **  CHECK THE INPUT ARGUMENTS FOR ERRORS  **
!               ********************************************
!
      IF ( N>=1 ) THEN
!
!               *******************************************************
!               **  STEP 2--                                         **
!               **  IF A POSITIVE INPUT SEED HAS BEEN GIVEN,         **
!               **  THEN THIS INDICATES THAT THE GENERATOR           **
!               **  SHOULD HAVE ITS INTERNAL M(.) ARRAY REDEFINED--  **
!               **  DO SO IN THIS SECTION.                           **
!               **  IF A NON-POSITIVE INPUT SEED HAS BEEN GIVEN,     **
!               **  THEN THIS INDICATES THAT THE GENERATOR           **
!               **  SHOULD CONTINUE ON FROM WHERE IT LEFT OFF,       **
!               **  AND THEREFORE THIS SECTION IS SKIPPED.           **
!               *******************************************************
!
         IF ( Iseed>0 ) THEN
!
!CCCC MDIG=16
            mdig = 32
!
            m1 = 2**(mdig-2) + (2**(mdig-2)-1)
            m2 = 2**(mdig/2)
!CCCC ISEED3=MIN0(IABS(ISEED),M1)
            iseed3 = IABS(Iseed)
            IF ( m1<IABS(Iseed) ) iseed3 = m1
            IF ( MOD(iseed3,2)==0 ) iseed3 = iseed3 - 1
            k0 = MOD(9069,m2)
            k1 = 9069/m2
            j0 = MOD(iseed3,m2)
            j1 = iseed3/m2
!
            DO i = 1 , 17
               iseed3 = j0*k0
               j1 = MOD(iseed3/m2+j0*k1+j1*k0,m2/2)
               j0 = MOD(iseed3,m2)
               m(i) = j0 + m2*j1
            ENDDO
!
            i = 5
            j = 17
         ENDIF
!
!
!               *************************************
!               **  STEP 3--                       **
!               **  GENERATE THE N RANDOM NUMBERS  **
!               *************************************
!
         DO l = 1 , N
            k = m(i) - m(j)
            IF ( k<0 ) k = k + m1
            m(j) = k
            i = i - 1
            IF ( i==0 ) i = 17
            j = j - 1
            IF ( j==0 ) j = 17
            ak = k
            am1 = m1
            X(l) = ak/am1
         ENDDO
!
!               *****************************************************
!               **  STEP 4--                                       **
!               **  REGARDLESS OF THE VALUE OF THE INPUT SEED,     **
!               **  REDEFINE THE VALUE OF ISEED UPON EXIT HERE     **
!               **  TO -1 WITH THE NET EFFECT THAT                 **
!               **  IF THE USER DOES NOT REDEFINE THE SEED         **
!               **  VALUE BEFORE THE NEXT CALL TO THIS GENERATOR,  **
!               **  THEN THIS GENERATOR WILL PICK UP               **
!               **  WHERE IT LEFT OFF.                             **
!               *****************************************************
!
         Iseed = (-1)
      ELSE
         WRITE (ipr,99001)
99001    FORMAT (' ')
         WRITE (ipr,99002)
99002    FORMAT (' ','***** ERROR IN UNIRAN--')
         WRITE (ipr,99003)
99003    FORMAT (' ','      THE INPUT NUMBER OF OBSERVATIONS IS ',      &
     &           'NON-POSITIVE.')
         WRITE (ipr,99004) N
99004    FORMAT (' ','      N = ',I8)
      ENDIF
!
!               *****************
!               **  STEP 90--  **
!               **  EXIT       **
!               *****************
!
!CCCC DEBUG TRACE,INIT
!CCCC AT 90
!CCCC TRACE ON
      END SUBROUTINE UNIRAN
!*==unisf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE UNISF(P,Sf)
      IMPLICIT NONE
!*--UNISF32614
!*** Start of declarations inserted by SPAG
      INTEGER ipr
      REAL P , Sf
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT UNISF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE SPARSITY
!              FUNCTION VALUE FOR THE UNIFORM (RECTANGULAR)
!              DISTRIBUTION ON THE UNIT INTERVAL (0,1).
!              THIS DISTRIBUTION HAS MEAN = 0.5
!              AND STANDARD DEVIATION = SQRT(1/12) = 0.28867513.
!              THIS DISTRIBUTION HAS THE PROBABILITY
!              DENSITY FUNCTION F(X) = 1.
!              NOTE THAT THE SPARSITY FUNCTION OF A DISTRIBUTION
!              IS THE DERIVATIVE OF THE PERCENT POINT FUNCTION,
!              AND ALSO IS THE RECIPROCAL OF THE PROBABILITY
!              DENSITY FUNCTION (BUT IN UNITS OF P RATHER THAN X).
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                AT WHICH THE SPARSITY
!                                FUNCTION IS TO BE EVALUATED.
!     OUTPUT ARGUMENTS--SF     = THE SINGLE PRECISION SPARSITY
!                                FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION
!             SPARSITY FUNCTION VALUE SF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0 AND 1.0, INCLUSIVELY.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231.
!               --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 57-74.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<0.0 .OR. P>1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE UNISF  SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99002) P
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         Sf = 1.0
      ENDIF
!
      END SUBROUTINE UNISF
!*==var.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE VAR(X,N,Iwrite,Xvar)
      IMPLICIT NONE
!*--VAR32690
!*** Start of declarations inserted by SPAG
      REAL an , hold , sum , X , xmean , Xvar
      INTEGER i , ipr , Iwrite , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT VAR
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE VARIANCE (WITH DENOMINATOR N-1)
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE SAMPLE VARIANCE = (THE SUM OF THE
!              SQUARED DEVIATIONS ABOUT THE SAMPLE MEAN)/(N-1).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE VARIANCE
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE VARIANCE
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XVAR   = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE VARIANCE.
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE VARIANCE (WITH DENOMINATOR N-1).
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--SNEDECOR AND COCHRAN, STATISTICAL METHODS,
!                 EDITION 6, 1967, PAGE 44.
!               --DIXON AND MASSEY, INTRODUCTION TO STATISTICAL
!                 ANALYSIS, EDITION 2, 1957, PAGE 38.
!               --MOOD AND GRABLE, 'INTRODUCTION TO THE THEORY
!                 OF STATISTICS, EDITION 2, 1963, PAGE 171.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      an = N
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE VAR    SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE VAR &
     &   SUBROUTINE HAS THE VALUE 1 *****')
            Xvar = 0.0
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE VAR    SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            Xvar = 0.0
         ENDIF
         GOTO 100
!
!-----START POINT-----------------------------------------------------
!
 50      sum = 0.0
         DO i = 1 , N
            sum = sum + X(i)
         ENDDO
         xmean = sum/an
         sum = 0.0
         DO i = 1 , N
            sum = sum + (X(i)-xmean)**2
         ENDDO
         Xvar = sum/(an-1.0)
      ENDIF
!
 100  IF ( Iwrite==0 ) RETURN
      WRITE (ipr,99005)
99005 FORMAT (' ')
      WRITE (ipr,99006) N , Xvar
99006 FORMAT (' ','THE SAMPLE VARIANCE OF THE ',I6,' OBSERVATIONS IS ', &
     &        E15.8)
      END SUBROUTINE VAR
!*==weib.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE WEIB(X,N)
      IMPLICIT NONE
!*--WEIB32807
!*** Start of declarations inserted by SPAG
      REAL a , aindex , an , cc , corr , corrmx , gamtab , hold , sum1 ,&
     &     sum2 , sum3 , sy , t , w , wbar , WS , X , xmax , xmin , Y
      REAL ybar , yi , yint , ys , yslope , Z
      INTEGER i , idis , idismx , ipr , iupper , N , numdis , numdm1
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT WEIB
!
!     PURPOSE--THIS SUBROUTINE PERFOMS A WEIBULL DISTRIBUTION ANALYSIS
!              ON THE DATA IN THE INPUT VECTOR X.
!              THIS ANALYSIS CONSISTS OF DETERMINING THAT PARTICULAR
!              WEIBULL DISTRIBUTION
!              WHICH BEST FITS THE DATA SET.
!              THE GOODNESS OF FIT CRITERION IS THE MAXIMUM PROBABILITY
!              PLOT CORRELATION COEFFICIENT CRITERION.
!              AFTER THE BEST-FIT DISTRIBUTION IS DETERMINED,
!              ESTIMATES ARE COMPUTED AND PRINTED OUT FOR THE
!              LOCATION AND SCALE PARAMETERS.
!              TWO PROBABILITY PLOTS ARE ALSO PRINTED OUT--
!              THE BEST-FIT WEIBULL PROBABILITY PLOT
!              AND AN EXTREME VALUE TYPE 1 PROBABILITY PLOT
!              (THIS IS DUE TO THE FACT THAT AS THE WEIBULL PARAMETER
!              GAMMA APPROACHES INFINITY, THE WEIBULL DISTRIBUTION
!              APPROACHES THE EXTREME VALUE TYPE 1 DISTRIBUTION).
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               (UNSORTED OR SORTED) OBSERVATIONS.
!                      N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!     OUTPUT--4 PAGES OF AUTOMATIC PRINTOUT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, WEIPLT,
!                                         EV1PLT, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT AND ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCE--FILLIBEN (1972), 'TECHNIQUES FOR TAIL LENGTH
!                ANALYSIS', PROCEEDINGS OF THE EIGHTEENTH
!                CONFERENCE ON THE DESIGN OF EXPERIMENTS IN
!                ARMY RESEARCH AND TESTING, PAGES 425-450.
!              --FILLIBEN, 'THE PERCENT POINT FUNCTION',
!                UNPUBLISHED MANUSCRIPT.
!              --JOHNSON AND KOTZ (1970), CONTINUOUS UNIVARIATE
!                DISTRIBUTIONS-1, PAGES 250-271.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --AUGUST    1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --MAY       1976.
!
!---------------------------------------------------------------------
!
      CHARACTER*4 iflag1
      CHARACTER*4 iflag2
      CHARACTER*4 iflag3
!
      CHARACTER*4 blank
      CHARACTER*4 alpham
      CHARACTER*4 alphaa
      CHARACTER*4 alphax
      CHARACTER*4 alphai
      CHARACTER*4 alphan
      CHARACTER*4 alphaf
      CHARACTER*4 alphat
      CHARACTER*4 alphay
      CHARACTER*4 alphag
      CHARACTER*4 equal
!
      DIMENSION w(3000)
      DIMENSION X(1)
      DIMENSION Y(7500) , Z(7500)
      DIMENSION gamtab(50) , corr(50)
      DIMENSION yi(50) , ys(50) , t(50)
      DIMENSION iflag1(50) , iflag2(50) , iflag3(50)
      DIMENSION aindex(50)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (Z(1),WS(7501))
      DATA blank , alpham , alphaa , alphax/' ' , 'M' , 'A' , 'X'/
      DATA alphai , alphan , alphaf , alphat , alphay/'I' , 'N' , 'F' , &
     &     'T' , 'Y'/
      DATA alphag , equal/'G' , '='/
      DATA gamtab(1) , gamtab(2) , gamtab(3) , gamtab(4) , gamtab(5) ,  &
     &     gamtab(6) , gamtab(7) , gamtab(8) , gamtab(9) , gamtab(10) , &
     &     gamtab(11) , gamtab(12) , gamtab(13) , gamtab(14) ,          &
     &     gamtab(15) , gamtab(16) , gamtab(17) , gamtab(18) ,          &
     &     gamtab(19) , gamtab(20) , gamtab(21) , gamtab(22) ,          &
     &     gamtab(23) , gamtab(24) , gamtab(25)/1. , 2. , 3. , 4. , 5. ,&
     &     6. , 7. , 8. , 9. , 10. , 11. , 12. , 13. , 14. , 15. , 16. ,&
     &     17. , 18. , 19. , 20. , 21. , 22. , 23. , 24. , 25./
      DATA gamtab(26) , gamtab(27) , gamtab(28) , gamtab(29) ,          &
     &     gamtab(30) , gamtab(31) , gamtab(32) , gamtab(33) ,          &
     &     gamtab(34) , gamtab(35) , gamtab(36) , gamtab(37) ,          &
     &     gamtab(38) , gamtab(39) , gamtab(40) , gamtab(41) ,          &
     &     gamtab(42)/30. , 35. , 40. , 45. , 50. , 60. , 70. , 80. ,   &
     &     90. , 100. , 150. , 200. , 250. , 350. , 500. , 750. , 1000./
      DATA t(1) , t(2) , t(3) , t(4) , t(5) , t(6) , t(7) , t(8) ,      &
     &     t(9) , t(10) , t(11) , t(12) , t(13) , t(14) , t(15) ,       &
     &     t(16) , t(17) , t(18) , t(19) , t(20)/1.63474 , 1.36116 ,    &
     &     1.34278 , 1.35854 , 1.37836 , 1.39657 , 1.41225 , 1.42557 ,  &
     &     1.43690 , 1.44660 , 1.45496 , 1.46223 , 1.46860 , 1.47422 ,  &
     &     1.47921 , 1.48368 , 1.48769 , 1.49132 , 1.49461 , 1.49761/
      DATA t(21) , t(22) , t(23) , t(24) , t(25) , t(26) , t(27) ,      &
     &     t(28) , t(29) , t(30) , t(31) , t(32) , t(33) , t(34) ,      &
     &     t(35) , t(36) , t(37) , t(38) , t(39) , t(40) , t(41) ,      &
     &     t(42) , t(43)/1.50036 , 1.50288 , 1.50521 , 1.50736 ,        &
     &     1.50935 , 1.51748 , 1.52344 , 1.52798 , 1.53157 , 1.53447 ,  &
     &     1.53888 , 1.54206 , 1.54447 , 1.54636 , 1.54788 , 1.55248 ,  &
     &     1.55480 , 1.55620 , 1.55781 , 1.55902 , 1.55997 , 1.56044 ,  &
     &     1.62391/
      DATA aindex(1) , aindex(2) , aindex(3) , aindex(4) , aindex(5) ,  &
     &     aindex(6) , aindex(7) , aindex(8) , aindex(9) , aindex(10) , &
     &     aindex(11) , aindex(12) , aindex(13) , aindex(14) ,          &
     &     aindex(15) , aindex(16) , aindex(17) , aindex(18) ,          &
     &     aindex(19) , aindex(20) , aindex(21) , aindex(22) ,          &
     &     aindex(23) , aindex(24) , aindex(25)/1. , 2. , 3. , 4. , 5. ,&
     &     6. , 7. , 8. , 9. , 10. , 11. , 12. , 13. , 14. , 15. , 16. ,&
     &     17. , 18. , 19. , 20. , 21. , 22. , 23. , 24. , 25./
      DATA aindex(26) , aindex(27) , aindex(28) , aindex(29) ,          &
     &     aindex(30) , aindex(31) , aindex(32) , aindex(33) ,          &
     &     aindex(34) , aindex(35) , aindex(36) , aindex(37) ,          &
     &     aindex(38) , aindex(39) , aindex(40) , aindex(41) ,          &
     &     aindex(42) , aindex(43) , aindex(44) , aindex(45) ,          &
     &     aindex(46) , aindex(47) , aindex(48) , aindex(49) ,          &
     &     aindex(50)/26. , 27. , 28. , 29. , 30. , 31. , 32. , 33. ,   &
     &     34. , 35. , 36. , 37. , 38. , 39. , 40. , 41. , 42. , 43. ,  &
     &     44. , 45. , 46. , 47. , 48. , 49. , 50./
!
      ipr = 6
      iupper = 7500
      numdis = 43
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE WEIB   SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE WEIB&
     &   SUBROUTINE HAS THE VALUE 1 *****')
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE WEIB   SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     COMPUTE THE SAMPLE MINIMUM AND SAMPLE MAXIMUM
!
         xmin = X(1)
         xmax = X(1)
         DO i = 2 , N
            IF ( X(i)<xmin ) xmin = X(i)
            IF ( X(i)>xmax ) xmax = X(i)
         ENDDO
!
!     COMPUTE THE PROB PLOT CORRELATION COEFFICIENTS FOR THE VARIOUS VALUES
!     OF GAMMA
!
         CALL SORT(X,N,Y)
         CALL UNIMED(N,Z)
!
         DO idis = 1 , numdis
            IF ( idis==numdis ) THEN
               DO i = 1 , N
                  w(i) = -ALOG(ALOG(1.0/Z(i)))
               ENDDO
            ELSE
               a = gamtab(idis)
               DO i = 1 , N
                  w(i) = (-ALOG(1.0-Z(i)))**(1.0/a)
               ENDDO
            ENDIF
!
            sum1 = 0.0
            sum2 = 0.0
            DO i = 1 , N
               sum1 = sum1 + Y(i)
               sum2 = sum2 + w(i)
            ENDDO
            ybar = sum1/an
            wbar = sum2/an
            sum1 = 0.0
            sum2 = 0.0
            sum3 = 0.0
            DO i = 1 , N
               sum2 = sum2 + (Y(i)-ybar)*(w(i)-wbar)
               sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
               sum3 = sum3 + (w(i)-wbar)*(w(i)-wbar)
            ENDDO
            sy = SQRT(sum1/(an-1.0))
            cc = sum2/SQRT(sum3*sum1)
            yslope = sum2/sum3
            yint = ybar - yslope*wbar
            corr(idis) = cc
            yi(idis) = yint
            ys(idis) = yslope
         ENDDO
!
!     DETERMINE THAT DISTRIBUTION WITH THE MAX PROB PLOT CORR COEFFICIENT
!
         idismx = 1
         corrmx = corr(1)
         DO idis = 1 , numdis
            IF ( corr(idis)>corrmx ) idismx = idis
            IF ( corr(idis)>corrmx ) corrmx = corr(idis)
         ENDDO
         DO idis = 1 , numdis
            iflag1(idis) = blank
            iflag2(idis) = blank
            iflag3(idis) = blank
            IF ( idis==idismx ) THEN
               iflag1(idis) = alpham
               iflag2(idis) = alphaa
               iflag3(idis) = alphax
            ENDIF
         ENDDO
!
!     WRITE OUT THE TABLE OF PROB PLOT CORR COEFFICIENTS FOR VARIOUS GAMMA
!
         WRITE (ipr,99005)
!
99005    FORMAT ('1')
         WRITE (ipr,99006)
99006    FORMAT (' ',40X,'WEIBULL ANALYSIS')
         WRITE (ipr,99020)
         WRITE (ipr,99007) N
99007    FORMAT (' ',37X,'THE SAMPLE SIZE N = ',I7)
         WRITE (ipr,99008) ybar
99008    FORMAT (' ',34X,'THE SAMPLE MEAN = ',F14.7)
         WRITE (ipr,99009) sy
99009    FORMAT (' ',28X,'THE SAMPLE STANDARD DEVIATION = ',F14.7)
         WRITE (ipr,99010) xmin
99010    FORMAT (' ',32X,'THE SAMPLE MINIMUM = ',F14.7)
         WRITE (ipr,99011) xmax
99011    FORMAT (' ',32X,'THE SAMPLE MAXIMUM = ',F14.7)
         WRITE (ipr,99020)
         WRITE (ipr,99012)
99012    FORMAT (' ',                                                   &
     &'       WEIBULL          PROBABILITY PLOT     LOCATION         SCA&
     &LE       TAIL LENGTH')
         WRITE (ipr,99013)
99013    FORMAT (' ',                                                   &
     &'     TAIL LENGTH          CORRELATION        ESTIMATE        ESTI&
     &MATE       MEASURE')
         WRITE (ipr,99014)
99014    FORMAT (' ','   PARAMETER (GAMMA)      COEFFICIENT')
         WRITE (ipr,99020)
!
         numdm1 = numdis - 1
         IF ( numdm1>=1 ) THEN
            DO i = 1 , numdm1
               WRITE (ipr,99015) gamtab(i) , corr(i) , iflag1(i) ,      &
     &                           iflag2(i) , iflag3(i) , yi(i) , ys(i) ,&
     &                           t(i)
99015          FORMAT (' ',3X,F10.2,13X,F8.5,1X,3A1,2X,F14.7,2X,F14.7,  &
     &                 3X,F10.5)
            ENDDO
         ENDIF
         i = numdis
         WRITE (ipr,99016) alphai , alphan , alphaf , alphai , alphan , &
     &                     alphai , alphat , alphay , corr(i) ,         &
     &                     iflag1(i) , iflag2(i) , iflag3(i) , yi(i) ,  &
     &                     ys(i) , t(i)
99016    FORMAT (' ',5X,8A1,13X,F8.5,1X,3A1,2X,F14.7,2X,F14.7,3X,F10.5)
!
!     PLOT THE PROB PLOT CORR COEFFICIENT VERSUS GAMMA VALUE INDEX
!
         CALL PLOT(corr,aindex,numdis)
         WRITE (ipr,99017) alphag , alphaa , alpham , alpham , alphaa , &
     &                     equal , gamtab(1) , gamtab(12) , gamtab(23) ,&
     &                     gamtab(34) , alphai , alphan , alphaf ,      &
     &                     alphai , alphan , alphai , alphat , alphay
99017    FORMAT (' ',12X,5A1,1X,A1,F14.7,11X,F14.7,11X,F14.7,11X,F14.7, &
     &           15X,8A1)
         WRITE (ipr,99020)
         WRITE (ipr,99018)
99018    FORMAT (' ',                                                   &
     &'THE ABOVE IS A PLOT OF THE 46 PROBABILITY PLOT CORRELATION COEFFI&
     &CIENTS (FROM THE PREVIOUS PAGE)')
         WRITE (ipr,99019)
99019    FORMAT (' ',16X,'VERSUS THE 46 WEIBULL DISTRIBUTIONS')
!
!     IF THE OPTIMAL GAMMA IS FINITE, PLOT OUT THE WEIBULL
!     PROBABILITY PLOT FOR THE OPTIMAL VALUE
!     OF GAMMA.
!
         IF ( idismx<numdis ) CALL WEIPLT(X,N,gamtab(idismx))
!
!     PLOT OUT AN EXTREM VALUE TYPE 1 PROBABILITY PLOT
!     (WHICH IS IDENTICALLY A WEIBULL PROBABILITY
!     WITH GAMMA = INFINITY)
!
         CALL EV1PLT(X,N)
      ENDIF
99020 FORMAT (' ')
!
      END SUBROUTINE WEIB
!*==weicdf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE WEICDF(X,Gamma,Cdf)
      IMPLICIT NONE
!*--WEICDF33133
!*** Start of declarations inserted by SPAG
      REAL Cdf , Gamma , X
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT WEICDF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR THE WEIBULL
!              DISTRIBUTION WITH SINGLE PRECISION
!              TAIL LENGTH PARAMETER = GAMMA.
!              THE WEIBULL DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL POSITIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = GAMMA * (X**(GAMMA-1)) * EXP(-(X**GAMMA)).
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VALUE
!                                AT WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!                                X SHOULD BE POSITIVE.
!                     --GAMMA  = THE SINGLE PRECISION VALUE
!                                OF THE TAIL LENGTH PARAMETER.
!                                GAMMA SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF FOR THE WEIBULL DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--GAMMA SHOULD BE POSITIVE.
!                 --X SHOULD BE POSITIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 250-271.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGE 124.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( X<=0.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT TO THE WEIC&
     &DF SUBROUTINE IS NON-POSITIVE *****')
         WRITE (ipr,99003) X
         Cdf = 0.0
         RETURN
      ELSEIF ( Gamma<=0.0 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE WEICDF SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99003) Gamma
         Cdf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         Cdf = 1.0 - (EXP(-(X**Gamma)))
      ENDIF
99003 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
      END SUBROUTINE WEICDF
!*==weiplt.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE WEIPLT(X,N,Gamma)
      IMPLICIT NONE
!*--WEIPLT33215
!*** Start of declarations inserted by SPAG
      REAL an , cc , Gamma , hold , pp0025 , pp025 , pp975 , pp9975 ,   &
     &     q , sum1 , sum2 , sum3 , tau , W , wbar , WS , X , Y , ybar ,&
     &     yint
      REAL yslope
      INTEGER i , ipr , iupper , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT WEIPLT
!
!     PURPOSE--THIS SUBROUTINE GENERATES A WEIBULL
!              PROBABILITY PLOT
!              (WITH TAIL LENGTH PARAMETER VALUE = GAMMA).
!              THE PROTOTYPE WEIBULL DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL POSITIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = GAMMA * (X**(GAMMA-1)) * EXP(-(X**GAMMA)).
!              AS USED HEREIN, A PROBABILITY PLOT FOR A DISTRIBUTION
!              IS A PLOT OF THE ORDERED OBSERVATIONS VERSUS
!              THE ORDER STATISTIC MEDIANS FOR THAT DISTRIBUTION.
!              THE WEIBULL PROBABILITY PLOT IS USEFUL IN
!              GRAPHICALLY TESTING THE COMPOSITE (THAT IS,
!              LOCATION AND SCALE PARAMETERS NEED NOT BE SPECIFIED)
!              HYPOTHESIS THAT THE UNDERLYING DISTRIBUTION
!              FROM WHICH THE DATA HAVE BEEN RANDOMLY DRAWN
!              IS THE  WEIBULL DISTRIBUTION
!              WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!              IF THE HYPOTHESIS IS TRUE, THE PROBABILITY PLOT
!              SHOULD BE NEAR-LINEAR.
!              A MEASURE OF SUCH LINEARITY IS GIVEN BY THE
!              CALCULATED PROBABILITY PLOT CORRELATION COEFFICIENT.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --GAMMA  = THE SINGLE PRECISION VALUE OF THE
!                                TAIL LENGTH PARAMETER.
!                                GAMMA SHOULD BE POSITIVE.
!     OUTPUT--A ONE-PAGE WEIBULL PROBABILITY PLOT.
!     PRINTING--YES.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 7500.
!                 --GAMMA SHOULD BE POSITIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT, UNIMED, PLOT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--SQRT, ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--FILLIBEN, 'TECHNIQUES FOR TAIL LENGTH ANALYSIS',
!                 PROCEEDINGS OF THE EIGHTEENTH CONFERENCE
!                 ON THE DESIGN OF EXPERIMENTS IN ARMY RESEARCH
!                 DEVELOPMENT AND TESTING (ABERDEEN, MARYLAND,
!                 OCTOBER, 1972), PAGES 425-450.
!               --HAHN AND SHAPIRO, STATISTICAL METHODS IN ENGINEERING,
!                 1967, PAGES 260-308.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 250-271.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--DECEMBER  1972.
!     UPDATED         --MARCH     1975.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(7500) , W(7500)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
      EQUIVALENCE (W(1),WS(7501))
!
      ipr = 6
      iupper = 7500
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE WEIPLT SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( N==1 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE WEIP&
     &LT SUBROUTINE HAS THE VALUE 1 *****')
         RETURN
      ELSE
         IF ( Gamma<=0.0 ) THEN
            WRITE (ipr,99004)
99004       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE WEIPLT SUBROU&
     &TINE IS NON-POSITIVE *****')
            WRITE (ipr,99005) Gamma
99005       FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,    &
     &              ' *****')
            RETURN
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99006) hold
99006       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE WEIPLT SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            RETURN
         ENDIF
!
!-----START POINT-----------------------------------------------------
!
 50      an = N
!
!     SORT THE DATA
!
         CALL SORT(X,N,Y)
!
!     GENERATE UNIFORM ORDER STATISTIC MEDIANS
!
         CALL UNIMED(N,W)
!
!     COMPUTE WEIBULL DISTRIBUTION ORDER STATISTIC MEDIANS
!
         DO i = 1 , N
            W(i) = (-ALOG(1.0-W(i)))**(1.0/Gamma)
         ENDDO
!
!     PLOT THE ORDERED OBSERVATIONS VERSUS ORDER STATISTICS MEDIANS.
!     COMPUTE THE TAIL LENGTH MEASURE OF THE DISTRIBUTION.
!     WRITE OUT THE TAIL LENGTH MEASURE OF THE DISTRIBUTION
!     AND THE SAMPLE SIZE.
!
         CALL PLOT(Y,W,N)
         q = .9975
         pp9975 = (-ALOG(1.0-q))**(1.0/Gamma)
         q = .0025
         pp0025 = (-ALOG(1.0-q))**(1.0/Gamma)
         q = .975
         pp975 = (-ALOG(1.0-q))**(1.0/Gamma)
         q = .025
         pp025 = (-ALOG(1.0-q))**(1.0/Gamma)
         tau = (pp9975-pp0025)/(pp975-pp025)
         WRITE (ipr,99007) Gamma , tau , N
!
99007    FORMAT (' ',                                                   &
     &           'WEIBULL PROBABILITY PLOT WITH EXPONENT PARAMETER = ', &
     &           E17.10,1X,'(TAU = ',E15.8,')',11X,                     &
     &           'THE SAMPLE SIZE N = ',I7)
!
!     COMPUTE THE PROBABILITY PLOT CORRELATION COEFFICIENT.
!     COMPUTE LOCATION AND SCALE ESTIMATES
!     FROM THE INTERCEPT AND SLOPE OF THE PROBABILITY PLOT.
!     THEN WRITE THEM OUT.
!
         sum1 = 0.0
         sum2 = 0.0
         DO i = 1 , N
            sum1 = sum1 + Y(i)
            sum2 = sum2 + W(i)
         ENDDO
         ybar = sum1/an
         wbar = sum2/an
         sum1 = 0.0
         sum2 = 0.0
         sum3 = 0.0
         DO i = 1 , N
            sum1 = sum1 + (Y(i)-ybar)*(Y(i)-ybar)
            sum2 = sum2 + (Y(i)-ybar)*(W(i)-wbar)
            sum3 = sum3 + (W(i)-wbar)*(W(i)-wbar)
         ENDDO
         cc = sum2/SQRT(sum3*sum1)
         yslope = sum2/sum3
         yint = ybar - yslope*wbar
         WRITE (ipr,99008) cc , yint , yslope
99008    FORMAT (' ','PROBABILITY PLOT CORRELATION COEFFICIENT = ',F8.5,&
     &           5X,'ESTIMATED INTERCEPT = ',E15.8,3X,                  &
     &           'ESTIMATED SLOPE = ',E15.8)
      ENDIF
!
      END SUBROUTINE WEIPLT
!*==weippf.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE WEIPPF(P,Gamma,Ppf)
      IMPLICIT NONE
!*--WEIPPF33406
!*** Start of declarations inserted by SPAG
      REAL Gamma , P , Ppf
      INTEGER ipr
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT WEIPPF
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE WEIBULL
!              DISTRIBUTION WITH SINGLE PRECISION
!              TAIL LENGTH PARAMETER = GAMMA.
!              THE WEIBULL DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL POSITIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = GAMMA * (X**(GAMMA-1)) * EXP(-(X**GAMMA)).
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 (INCLUSIVELY)
!                                AND 1.0 (EXCLUSIVELY))
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!                     --GAMMA  = THE SINGLE PRECISION VALUE
!                                OF THE TAIL LENGTH PARAMETER.
!                                GAMMA SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--PPF    = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT FUNCTION .
!             VALUE PPF FOR THE WEIBULL DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--GAMMA SHOULD BE POSITIVE.
!                 --P SHOULD BE BETWEEN 0.0 (INCLUSIVELY)
!                   AND 1.0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 250-271.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGE 124.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      ipr = 6
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( P<0.0 .OR. P>=1.0 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE WEIPPF SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL *****')
         WRITE (ipr,99003) P
         Ppf = 0.0
         RETURN
      ELSEIF ( Gamma<=0.0 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE WEIPPF SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99003) Gamma
         Ppf = 0.0
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
         Ppf = (-ALOG(1.0-P))**(1.0/Gamma)
      ENDIF
99003 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
      END SUBROUTINE WEIPPF
!*==weiran.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE WEIRAN(N,Gamma,Iseed,X)
      IMPLICIT NONE
!*--WEIRAN33493
!*** Start of declarations inserted by SPAG
      REAL Gamma , X
      INTEGER i , ipr , Iseed , N
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT WEIRAN
!
!     PURPOSE--THIS SUBROUTINE GENERATES A RANDOM SAMPLE OF SIZE N
!              FROM THE WEIBULL DISTRIBUTION
!              WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!              THE PROTOTYPE WEIBULL DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL POSITIVE X,
!              AND HAS THE PROBABILITY DENSITY FUNCTION
!              F(X) = GAMMA * (X**(GAMMA-1)) * EXP(-(X**GAMMA)).
!     INPUT  ARGUMENTS--N      = THE DESIRED INTEGER NUMBER
!                                OF RANDOM NUMBERS TO BE
!                                GENERATED.
!                     --GAMMA  = THE SINGLE PRECISION VALUE OF THE
!                                TAIL LENGTH PARAMETER.
!                                GAMMA SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--X      = A SINGLE PRECISION VECTOR
!                                (OF DIMENSION AT LEAST N)
!                                INTO WHICH THE GENERATED
!                                RANDOM SAMPLE WILL BE PLACED.
!     OUTPUT--A RANDOM SAMPLE OF SIZE N
!             FROM THE WEIBULL DISTRIBUTION
!             WITH TAIL LENGTH PARAMETER VALUE = GAMMA.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--THERE IS NO RESTRICTION ON THE MAXIMUM VALUE
!                   OF N FOR THIS SUBROUTINE.
!                 --GAMMA SHOULD BE POSITIVE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--UNIRAN.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--ALOG.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN (1977)
!     REFERENCES--TOCHER, THE ART OF SIMULATION,
!                 1963, PAGES 14-15.
!               --HAMMERSLEY AND HANDSCOMB, MONTE CARLO METHODS,
!                 1964, PAGE 36.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 250-271.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGE 128.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE--DATAPLOT IS A REGISTERED TRADEMARK
!           OF THE NATIONAL BUREAU OF STANDARDS.
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THE DATAPLOT LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!               EXCEPTION--HOLLERITH STRINGS IN FORMAT STATEMENTS
!                          DENOTED BY QUOTES RATHER THAN NH.
!     VERSION NUMBER--82.6
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --DECEMBER  1981.
!     UPDATED         --MAY       1982.
!
!-----CHARACTER STATEMENTS FOR NON-COMMON VARIABLES-------------------
!
!---------------------------------------------------------------------
!
      DIMENSION X(*)
!
!---------------------------------------------------------------------
!
!CCCC CHARACTER*4 IFEEDB
!CCCC CHARACTER*4 IPRINT
!
!CCCC COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!CCCC COMMON /PRINT/IFEEDB,IPRINT
!
      ipr = 6
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE WEIRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSEIF ( Gamma<=0.0 ) THEN
         WRITE (ipr,99003)
99003    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE WEIRAN SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99004) Gamma
99004    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,       &
     &           ' *****')
         RETURN
      ELSE
!
!     GENERATE N UNIFORM (0,1) RANDOM NUMBERS;
!
         CALL UNIRAN(N,Iseed,X)
!
!     GENERATE N WEIBULL DISTRIBUTION RANDOM NUMBERS
!     USING THE PERCENT POINT FUNCTION TRANSFORMATION METHOD.
!
         DO i = 1 , N
            X(i) = (-ALOG(1.0-X(i)))**(1.0/Gamma)
         ENDDO
      ENDIF
!
      END SUBROUTINE WEIRAN
!*==wind.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE WIND(X,N,P1,P2,Iwrite,Xwind)
      IMPLICIT NONE
!*--WIND33613
!*** Start of declarations inserted by SPAG
      REAL ak , an , anp1 , anp2 , hold , P1 , P2 , perp1 , perp2 ,     &
     &     perp3 , psum , sum , WS , X , Xwind , Y
      INTEGER i , ipr , istart , istop , iupper , Iwrite , k , N , np1 ,&
     &        np2
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT WIND
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE
!              SAMPLE WINDSORIZED MEAN
!              OF THE DATA IN THE INPUT VECTOR X.
!              THE WINDSORIZING IS SUCH THAT
!              THE LOWER 100*P1 % OF THE DATA IS
!              REPLACED BY THE SMALLEST NON-WINDSORIZED VALUE,
!              AND THE UPPER 100*P2 % OF THE DATA IS WINDSORIZED.
!              REPLACED BY THE LARGEST NON-WINDSORIZED VALUE.
!     INPUT  ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                                (UNSORTED OR SORTED) OBSERVATIONS.
!                     --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                                IN THE VECTOR X.
!                     --P1     = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                WHICH DEFINES WHAT FRACTION
!                                OF THE LOWER ORDER STATISTICS
!                                IS TO BE WINDSORIZED
!                                BEFORE COMPUTING THE WINDSORIZED MEAN.
!                     --P2     = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0 AND 1.0)
!                                WHICH DEFINES WHAT FRACTION
!                                OF THE UPPER ORDER STATISTICS
!                                IS TO BE WINDSORIZED
!                                BEFORE COMPUTING THE WINDSORIZED MEAN.
!                     --IWRITE = AN INTEGER FLAG CODE WHICH
!                                (IF SET TO 0) WILL SUPPRESS
!                                THE PRINTING OF THE
!                                SAMPLE WINDSORIZED MEAN
!                                AS IT IS COMPUTED;
!                                OR (IF SET TO SOME INTEGER
!                                VALUE NOT EQUAL TO 0),
!                                LIKE, SAY, 1) WILL CAUSE
!                                THE PRINTING OF THE
!                                SAMPLE WINDSORIZED MEAN
!                                AT THE TIME IT IS COMPUTED.
!     OUTPUT ARGUMENTS--XWIND  = THE SINGLE PRECISION VALUE OF THE
!                                COMPUTED SAMPLE WINDSORIZED MEAN
!                                WHERE 100*P1 % OF THE SMALLEST
!                                AND 100*P2 % OF THE LARGEST
!                                ORDERED OBSERVATIONS HAVE BEEN
!                                WINSORIZED BEFORE COMPUTING THE
!                                MEAN.
!     OUTPUT--THE COMPUTED SINGLE PRECISION VALUE OF THE
!             SAMPLE WINDSORIZED MEAN
!             WHERE 100*P1 % OF THE SMALLEST
!             AND   100*P2 % OF THE LARGEST
!             ORDERED OBSERVATIONS HAVE BEEN WINDSORIZED.
!     PRINTING--NONE, UNLESS IWRITE HAS BEEN SET TO A NON-ZERO
!               INTEGER, OR UNLESS AN INPUT ARGUMENT ERROR
!               CONDITION EXISTS.
!     RESTRICTIONS--THE MAXIMUM ALLOWABLE VALUE OF N
!                   FOR THIS SUBROUTINE IS 15000.
!                 --P1 SHOULD BE NON-NEGATIVE.
!                 --P1 SHOULD BE SMALLER THAN 1.0
!                 --P2 SHOULD BE NON-NEGATIVE.
!                 --P2 SHOULD BE SMALLER THAN 1.0
!                 --THE SUM OF P1 AND P2 SHOULD BE
!                   SMALLER THAN 1.0.
!     OTHER DATAPAC   SUBROUTINES NEEDED--SORT.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--DAVID, ORDER STATISTICS, 1970, PAGES 126-130, 136.
!               --CROW AND SIDDIQUI, 'ROBUST ESTIMATION OF LOCATION',
!                 JOURNAL OF THE AMERICAN STATISTICAL ASSOCIATION,
!                 1967, PAGES 357, 387.
!               --FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY, 1969).
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE:  301-921-2315
!     ORIGINAL VERSION--NOVEMBER  1975.
!     UPDATED         --FEBRUARY  1976.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
      DIMENSION Y(15000)
      COMMON /BLOCK2/ WS(15000)
      EQUIVALENCE (Y(1),WS(1))
!
      ipr = 6
      iupper = 15000
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      an = N
      IF ( N<1 .OR. N>iupper ) THEN
         WRITE (ipr,99001) iupper
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE WIND   SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (1,',I6,') INTERVAL *****')
         WRITE (ipr,99002) N
99002    FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
         RETURN
      ELSE
         IF ( N==1 ) THEN
            WRITE (ipr,99003)
99003       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE SECOND INPUT ARGUMENT TO THE WIND&
     &   SUBROUTINE HAS THE VALUE 1 *****')
            Xwind = X(1)
         ELSE
            hold = X(1)
            DO i = 2 , N
               IF ( X(i)/=hold ) GOTO 50
            ENDDO
            WRITE (ipr,99004) hold
99004       FORMAT (' ',                                                &
     &'***** NON-FATAL DIAGNOSTIC--THE FIRST  INPUT ARGUMENT (A VECTOR) &
     &TO THE WIND   SUBROUTINE HAS ALL ELEMENTS = ',E15.8,' *****')
            Xwind = X(1)
         ENDIF
         GOTO 100
 50      IF ( P1<0.0 .OR. P1>=1.0 ) THEN
            WRITE (ipr,99005)
99005       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE WIND   SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0.0,1.0)   INTERVAL *****')
            WRITE (ipr,99017) P1
            Xwind = 0.0
            RETURN
         ELSEIF ( P2<0.0 .OR. P2>=1.0 ) THEN
            WRITE (ipr,99006)
99006       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE FOURTH INPUT ARGUMENT TO THE WIND   SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (0.0,1.0)   INTERVAL *****')
            WRITE (ipr,99017) P2
            Xwind = 0.0
            RETURN
         ELSE
            psum = P1 + P2
            IF ( psum<0.0 .OR. psum>=1.0 ) THEN
               WRITE (ipr,99007)
99007          FORMAT (' ',                                             &
     &                 '***** FATAL ERROR--THE SUM OF INPUT ARGUMENTS ',&
     &      '3 AND 4 TO THE WIND   SUBROUTINE IS OUTSIDE THE ALLOWABLE '&
     &      ,'(0.0,1.0) INTERVAL *****')
               WRITE (ipr,99008) P1
99008          FORMAT (' ','                  INPUT ARGUMENT 3   ',     &
     &                 '                 = ',E15.8)
               WRITE (ipr,99009) P2
99009          FORMAT (' ','                  INPUT ARGUMENT 4   ',     &
     &                 '                 = ',E15.8)
               WRITE (ipr,99010) psum
99010          FORMAT (' ','                  INPUT ARGUMENT 3 + ',     &
     &                 'INPUT ARGUMENT 4 = ',E15.8)
               Xwind = 0.0
               RETURN
            ELSE
!
!-----START POINT-----------------------------------------------------
!
               CALL SORT(X,N,Y)
!
               an = N
               np1 = P1*an + 0.0001
               istart = np1 + 1
               np2 = P2*an + 0.0001
               istop = N - np2
               sum = 0.0
               k = 0
               IF ( istart>istop ) THEN
                  WRITE (ipr,99011)
99011             FORMAT (' ','INTERNAL ERROR IN WIND   SUBROUTINE--',  &
     &                   'THE START INDEX IS HIGHER THAN THE STOP INDEX'&
     &                   )
                  Xwind = 0.0
                  RETURN
               ELSE
                  DO i = istart , istop
                     k = k + 1
                     sum = sum + X(i)
                  ENDDO
                  ak = k
                  anp1 = np1
                  anp2 = np2
                  sum = sum + anp1*X(istart)
                  sum = sum + anp2*X(istop)
                  Xwind = sum/an
               ENDIF
            ENDIF
         ENDIF
      ENDIF
!
 100  IF ( Iwrite==0 ) RETURN
      perp1 = 100.0*P1
      perp2 = 100.0*P2
      perp3 = 100.0 - perp1 - perp2
      WRITE (ipr,99012)
99012 FORMAT (' ')
      WRITE (ipr,99013) N , Xwind
99013 FORMAT (' ','THE SAMPLE WINDSORIZED MEAN OF THE ',I6,             &
     &        ' OBSERVATIONS IS ',E15.8)
      WRITE (ipr,99014) perp1 , np1
99014 FORMAT (' ',8X,F10.4,' PERCENT (= ',I6,' OBSERVATIONS) ',         &
     &        'OF THE DATA WERE WINDSORIZED BELOW')
      WRITE (ipr,99015) perp2 , np2
99015 FORMAT (' ',8X,F10.4,' PERCENT (= ',I6,' OBSERVATIONS) ',         &
     &        'OF THE DATA WERE WINDSORIZED ABOVE')
      WRITE (ipr,99016) perp3 , k
99016 FORMAT (' ',8X,F10.4,' PERCENT (= ',I6,' OBSERVATIONS) ',         &
     &        ' OF THE DATA WERE UNWINDSORIZED IN THE MIDDLE')
99017 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',E15.8,' *****')
!
      END SUBROUTINE WIND
!*==write.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE WRITE(X,N,Nnline,Iwidth,Idec)
      IMPLICIT NONE
!*--WRITE33836
!*** Start of declarations inserted by SPAG
      INTEGER i , i10 , i50 , Idec , idecp1 , ipr , iwidm2 , iwidp1 ,   &
     &        Iwidth , j , jmax , jmin , maxcha , maxwid , N , nlines , &
     &        Nnline , numcha
      REAL X
!*** End of declarations inserted by SPAG
!CCCC FOLLOWING LINE ADDED TO MAKE THIS A DLL.
!      DLL_EXPORT WRITE
!
!     PURPOSE--THIS SUBROUTINE WRITES OUT THE CONTENTS
!              OF THE SINGLE PRECISION VECTOR X IN AN ORDERLY
!              AND NEAT FASHION.
!              THIS SUBROUTINE GIVES THE DATA ANALYST THE ABILITY
!              TO GET DATA OUT OF THE MACHINE WITHOUT HAVING
!              TO WORRY ABOUT AND SPECIFY FORMATS.
!     INPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR OF
!                               OBSERVATIONS TO BE PRINTED OUT.
!                    --N      = THE INTEGER NUMBER OF OBSERVATIONS
!                               IN THE VECTOR X.
!                    --NNLINE = THE INTEGER VALUE
!                               OF THE DESIRED NUMBER OF
!                               OBSERVATIONS IN X TO APPEAR PER LINE.
!                    --IWIDTH = THE INTEGER VALUE
!                               OF THE LARGEST NUMBER OF
!                               CHARACTERS THAT A VALUE IN X MAY TAKE UP
!                               = THE DESIRED NUMBER OF INTEGER DIGITS
!                               + THE DESIRED NUMBER OF DECIMAL DIGITS
!                               + 1 DIGIT FOR THE SIGN
!                               + 1 DIGIT FOR THE DECIMAL POINT.
!                               (NO PROVISION NEED BE MADE FOR LEADING
!                               OR TRAILING SEPARATION BLANKS--THIS IS
!                               DONE AUTOMATICALLY BY THE SUBROUTINE.)
!                    --IDEC   = THE INTEGER VALUE
!                               OF THE DESIRED NUMBER OF
!                               DECIMAL DIGITS TO BE PRINTED OUT.
!     OUTPUT--A LISTING OF THE N VALUES OF THE DATA VECTOR X
!             WITH NNLINE VALUES PRINTED PER LINE, AND WITH
!             BLANKS AUTOMATICALLY INSERTED BETWEEN ADJACENT VALUES.
!             A BLANK LINE WILL APPEAR AFTER EVERY TENTH LINE.
!             50 LINES OF DATA WILL APPEAR PER PRINTER PAGE.
!     PRINTING--YES.
!     RESTRICTIONS--NNLINE MUST BE 1 OR LARGER;
!                 --IWIDTH MUST BE 2 OR LARGER;
!                 --IWIDTH MUST BE 12 OR SMALLER;
!                 --IDEC MUST BE 0 OR LARGER;
!                 --IDEC MUST BE (IWIDTH-2) OR SMALLER;
!                 --THE PRODUCT OF NNLINE AND (IWIDTH+1) MUST
!                   BE 131 OR SMALLER.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE.
!     FORTRAN LIBRARY SUBROUTINES NEEDED--NONE.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     COMMENT--THE LISTED VALUES ARE TO BE READ ROW BY ROW--
!              THAT IS, THE FIRST VALUE IN X APPEARS
!              ON ROW 1, COLUMN 1 OF THE OUTPUT,
!              THE SECOND VALUE IN X APPEARS ON ROW 1, COLUMN 2,
!              ETC.
!     REFERENCES--NONE.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-2315
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
      DIMENSION X(1)
!
      ipr = 6
      maxwid = 12
      maxcha = 131
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF ( N<1 ) THEN
         WRITE (ipr,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE WRITE  SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99075) N
         RETURN
      ELSEIF ( Nnline<1 ) THEN
         WRITE (ipr,99002)
99002    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO THE WRITE  SUBROU&
     &TINE IS NON-POSITIVE *****')
         WRITE (ipr,99075) Nnline
         RETURN
      ELSEIF ( Iwidth<2 .OR. maxwid<Iwidth ) THEN
         WRITE (ipr,99003) maxwid
99003    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FOURTH INPUT ARGUMENT TO THE WRITE  SUBROU&
     &TINE IS OUTSIDE THE ALLOWABLE (2,',I4,') INTERVAL *****')
         WRITE (ipr,99075) Iwidth
         RETURN
      ELSE
         iwidm2 = Iwidth - 2
         IF ( Idec<0 .OR. iwidm2<Idec ) THEN
            WRITE (ipr,99004) Iwidth , iwidm2
99004       FORMAT (' ',                                                &
     &'***** FATAL ERROR--THE FIFTH  INPUT ARGUMENT TO THE WRITE  SUBROU&
     &TINE IS NEGATIVE OR EXCEEDS IWIDTH-2 (= ',I6,'-2 = ',I6,') *****')
            WRITE (ipr,99075) Idec
            RETURN
         ELSE
            iwidp1 = Iwidth + 1
            numcha = Nnline*iwidp1
            IF ( numcha>maxcha ) THEN
               WRITE (ipr,99005) maxcha
99005          FORMAT (' ',                                             &
     &'***** FATAL ERROR--THE PRODUCT OF THE 3RD INPUT ARGUMENT TO THE W&
     &RITE SUBROUTINE AND THE (4TH INPUT ARGUMENT + 1) EXCEEDS ',I3,    &
     &' ****')
               WRITE (ipr,99006) Nnline , Iwidth , Nnline , iwidp1 ,    &
     &                           numcha
99006          FORMAT (' ','***** THE VALUE OF THE PRODUCT = ',I8,      &
     &                 ' X (',I8,' + 1) = ',I8,' X ',I8,' = ',I8,       &
     &                 ' *****')
               RETURN
            ELSE
!
!-----START POINT-----------------------------------------------------
!
               nlines = ((N-1)/Nnline) + 1
               WRITE (ipr,99076)
               WRITE (ipr,99007) N
99007          FORMAT (' ',                                             &
     &              'THE TOTAL NUMBER OF OBSERVATIONS PRINTED BELOW IS '&
     &              ,I7)
               WRITE (ipr,99008) nlines , Nnline
99008          FORMAT (' ','THERE ARE ',I7,' ROWS AND ',I7,' COLUMNS')
               WRITE (ipr,99077)
               DO i = 1 , nlines
                  jmax = Nnline*i
                  jmin = jmax - Nnline + 1
                  IF ( jmax>N ) jmax = N
                  idecp1 = Idec + 1
                  IF ( Iwidth==2 ) THEN
!
                     WRITE (ipr,99009) (X(j),j=jmin,jmax)
!
!
99009                FORMAT (' ',43(F2.0,1X))
                     GOTO 50
                  ELSEIF ( Iwidth==3 ) THEN
                     IF ( idecp1==1 ) THEN
                        WRITE (ipr,99010) (X(j),j=jmin,jmax)
99010                   FORMAT (' ',32(F3.0,1X))
                     ELSEIF ( idecp1==2 ) THEN
                        WRITE (ipr,99011) (X(j),j=jmin,jmax)
99011                   FORMAT (' ',32(F3.1,1X))
                     ELSE
                        GOTO 5
                     ENDIF
                     GOTO 50
                  ELSEIF ( Iwidth==4 ) THEN
                  ELSEIF ( Iwidth==5 ) THEN
                     GOTO 10
                  ELSEIF ( Iwidth==6 ) THEN
                     GOTO 15
                  ELSEIF ( Iwidth==7 ) THEN
                     GOTO 20
                  ELSEIF ( Iwidth==8 ) THEN
                     GOTO 25
                  ELSEIF ( Iwidth==9 ) THEN
                     GOTO 30
                  ELSEIF ( Iwidth==10 ) THEN
                     GOTO 35
                  ELSEIF ( Iwidth==11 ) THEN
                     GOTO 40
                  ELSEIF ( Iwidth==12 ) THEN
                     GOTO 45
                  ELSE
                     RETURN
                  ENDIF
 5                IF ( idecp1==1 ) THEN
                     WRITE (ipr,99012) (X(j),j=jmin,jmax)
99012                FORMAT (' ',26(F4.0,1X))
                  ELSEIF ( idecp1==2 ) THEN
                     WRITE (ipr,99013) (X(j),j=jmin,jmax)
99013                FORMAT (' ',26(F4.1,1X))
                  ELSEIF ( idecp1==3 ) THEN
                     WRITE (ipr,99014) (X(j),j=jmin,jmax)
99014                FORMAT (' ',26(F4.2,1X))
                  ELSE
                     GOTO 10
                  ENDIF
                  GOTO 50
 10               IF ( idecp1==1 ) THEN
                     WRITE (ipr,99015) (X(j),j=jmin,jmax)
99015                FORMAT (' ',21(F5.0,1X))
                  ELSEIF ( idecp1==2 ) THEN
                     WRITE (ipr,99016) (X(j),j=jmin,jmax)
99016                FORMAT (' ',21(F5.1,1X))
                  ELSEIF ( idecp1==3 ) THEN
                     WRITE (ipr,99017) (X(j),j=jmin,jmax)
99017                FORMAT (' ',21(F5.2,1X))
                  ELSEIF ( idecp1==4 ) THEN
                     WRITE (ipr,99018) (X(j),j=jmin,jmax)
99018                FORMAT (' ',21(F5.3,1X))
                  ELSE
                     GOTO 15
                  ENDIF
                  GOTO 50
 15               IF ( idecp1==1 ) THEN
                     WRITE (ipr,99019) (X(j),j=jmin,jmax)
99019                FORMAT (' ',18(F6.0,1X))
                  ELSEIF ( idecp1==2 ) THEN
                     WRITE (ipr,99020) (X(j),j=jmin,jmax)
99020                FORMAT (' ',18(F6.1,1X))
                  ELSEIF ( idecp1==3 ) THEN
                     WRITE (ipr,99021) (X(j),j=jmin,jmax)
99021                FORMAT (' ',18(F6.2,1X))
                  ELSEIF ( idecp1==4 ) THEN
                     WRITE (ipr,99022) (X(j),j=jmin,jmax)
99022                FORMAT (' ',18(F6.3,1X))
                  ELSEIF ( idecp1==5 ) THEN
                     WRITE (ipr,99023) (X(j),j=jmin,jmax)
99023                FORMAT (' ',18(F6.4,1X))
                  ELSE
                     GOTO 20
                  ENDIF
                  GOTO 50
 20               IF ( idecp1==1 ) THEN
                     WRITE (ipr,99024) (X(j),j=jmin,jmax)
99024                FORMAT (' ',16(F7.0,1X))
                  ELSEIF ( idecp1==2 ) THEN
                     WRITE (ipr,99025) (X(j),j=jmin,jmax)
99025                FORMAT (' ',16(F7.1,1X))
                  ELSEIF ( idecp1==3 ) THEN
                     WRITE (ipr,99026) (X(j),j=jmin,jmax)
99026                FORMAT (' ',16(F7.2,1X))
                  ELSEIF ( idecp1==4 ) THEN
                     WRITE (ipr,99027) (X(j),j=jmin,jmax)
99027                FORMAT (' ',16(F7.3,1X))
                  ELSEIF ( idecp1==5 ) THEN
                     WRITE (ipr,99028) (X(j),j=jmin,jmax)
99028                FORMAT (' ',16(F7.4,1X))
                  ELSEIF ( idecp1==6 ) THEN
                     WRITE (ipr,99029) (X(j),j=jmin,jmax)
99029                FORMAT (' ',16(F7.5,1X))
                  ELSE
                     GOTO 25
                  ENDIF
                  GOTO 50
 25               IF ( idecp1==1 ) THEN
                     WRITE (ipr,99030) (X(j),j=jmin,jmax)
99030                FORMAT (' ',14(F8.0,1X))
                  ELSEIF ( idecp1==2 ) THEN
                     WRITE (ipr,99031) (X(j),j=jmin,jmax)
99031                FORMAT (' ',14(F8.1,1X))
                  ELSEIF ( idecp1==3 ) THEN
                     WRITE (ipr,99032) (X(j),j=jmin,jmax)
99032                FORMAT (' ',14(F8.2,1X))
                  ELSEIF ( idecp1==4 ) THEN
                     WRITE (ipr,99033) (X(j),j=jmin,jmax)
99033                FORMAT (' ',14(F8.3,1X))
                  ELSEIF ( idecp1==5 ) THEN
                     WRITE (ipr,99034) (X(j),j=jmin,jmax)
99034                FORMAT (' ',14(F8.4,1X))
                  ELSEIF ( idecp1==6 ) THEN
                     WRITE (ipr,99035) (X(j),j=jmin,jmax)
99035                FORMAT (' ',14(F8.5,1X))
                  ELSEIF ( idecp1==7 ) THEN
                     WRITE (ipr,99036) (X(j),j=jmin,jmax)
99036                FORMAT (' ',14(F8.6,1X))
                  ELSE
                     GOTO 30
                  ENDIF
                  GOTO 50
 30               IF ( idecp1==1 ) THEN
                     WRITE (ipr,99037) (X(j),j=jmin,jmax)
99037                FORMAT (' ',13(F9.0,1X))
                  ELSEIF ( idecp1==2 ) THEN
                     WRITE (ipr,99038) (X(j),j=jmin,jmax)
99038                FORMAT (' ',13(F9.1,1X))
                  ELSEIF ( idecp1==3 ) THEN
                     WRITE (ipr,99039) (X(j),j=jmin,jmax)
99039                FORMAT (' ',13(F9.2,1X))
                  ELSEIF ( idecp1==4 ) THEN
                     WRITE (ipr,99040) (X(j),j=jmin,jmax)
99040                FORMAT (' ',13(F9.3,1X))
                  ELSEIF ( idecp1==5 ) THEN
                     WRITE (ipr,99041) (X(j),j=jmin,jmax)
99041                FORMAT (' ',13(F9.4,1X))
                  ELSEIF ( idecp1==6 ) THEN
                     WRITE (ipr,99042) (X(j),j=jmin,jmax)
99042                FORMAT (' ',13(F9.5,1X))
                  ELSEIF ( idecp1==7 ) THEN
                     WRITE (ipr,99043) (X(j),j=jmin,jmax)
99043                FORMAT (' ',13(F9.6,1X))
                  ELSEIF ( idecp1==8 ) THEN
                     WRITE (ipr,99044) (X(j),j=jmin,jmax)
99044                FORMAT (' ',13(F9.7,1X))
                  ELSE
                     GOTO 35
                  ENDIF
                  GOTO 50
 35               IF ( idecp1==1 ) THEN
                     WRITE (ipr,99045) (X(j),j=jmin,jmax)
99045                FORMAT (' ',11(F10.0,1X))
                  ELSEIF ( idecp1==2 ) THEN
                     WRITE (ipr,99046) (X(j),j=jmin,jmax)
99046                FORMAT (' ',11(F10.1,1X))
                  ELSEIF ( idecp1==3 ) THEN
                     WRITE (ipr,99047) (X(j),j=jmin,jmax)
99047                FORMAT (' ',11(F10.2,1X))
                  ELSEIF ( idecp1==4 ) THEN
                     WRITE (ipr,99048) (X(j),j=jmin,jmax)
99048                FORMAT (' ',11(F10.3,1X))
                  ELSEIF ( idecp1==5 ) THEN
                     WRITE (ipr,99049) (X(j),j=jmin,jmax)
99049                FORMAT (' ',11(F10.4,1X))
                  ELSEIF ( idecp1==6 ) THEN
                     WRITE (ipr,99050) (X(j),j=jmin,jmax)
99050                FORMAT (' ',11(F10.5,1X))
                  ELSEIF ( idecp1==7 ) THEN
                     WRITE (ipr,99051) (X(j),j=jmin,jmax)
99051                FORMAT (' ',11(F10.6,1X))
                  ELSEIF ( idecp1==8 ) THEN
                     WRITE (ipr,99052) (X(j),j=jmin,jmax)
99052                FORMAT (' ',11(F10.7,1X))
                  ELSEIF ( idecp1==9 ) THEN
                     WRITE (ipr,99053) (X(j),j=jmin,jmax)
99053                FORMAT (' ',11(F10.8,1X))
                  ELSE
                     GOTO 40
                  ENDIF
                  GOTO 50
 40               IF ( idecp1==1 ) THEN
                     WRITE (ipr,99054) (X(j),j=jmin,jmax)
99054                FORMAT (' ',10(F11.0,1X))
                  ELSEIF ( idecp1==2 ) THEN
                     WRITE (ipr,99055) (X(j),j=jmin,jmax)
99055                FORMAT (' ',10(F11.1,1X))
                  ELSEIF ( idecp1==3 ) THEN
                     WRITE (ipr,99056) (X(j),j=jmin,jmax)
99056                FORMAT (' ',10(F11.2,1X))
                  ELSEIF ( idecp1==4 ) THEN
                     WRITE (ipr,99057) (X(j),j=jmin,jmax)
99057                FORMAT (' ',10(F11.3,1X))
                  ELSEIF ( idecp1==5 ) THEN
                     WRITE (ipr,99058) (X(j),j=jmin,jmax)
99058                FORMAT (' ',10(F11.4,1X))
                  ELSEIF ( idecp1==6 ) THEN
                     WRITE (ipr,99059) (X(j),j=jmin,jmax)
99059                FORMAT (' ',10(F11.5,1X))
                  ELSEIF ( idecp1==7 ) THEN
                     WRITE (ipr,99060) (X(j),j=jmin,jmax)
99060                FORMAT (' ',10(F11.6,1X))
                  ELSEIF ( idecp1==8 ) THEN
                     WRITE (ipr,99061) (X(j),j=jmin,jmax)
99061                FORMAT (' ',10(F11.7,1X))
                  ELSEIF ( idecp1==9 ) THEN
                     WRITE (ipr,99062) (X(j),j=jmin,jmax)
99062                FORMAT (' ',10(F11.8,1X))
                  ELSEIF ( idecp1==10 ) THEN
                     WRITE (ipr,99063) (X(j),j=jmin,jmax)
99063                FORMAT (' ',10(F11.9,1X))
                  ELSE
                     GOTO 45
                  ENDIF
                  GOTO 50
 45               IF ( idecp1==1 ) THEN
                     WRITE (ipr,99064) (X(j),j=jmin,jmax)
99064                FORMAT (' ',10(F12.0,1X))
                  ELSEIF ( idecp1==2 ) THEN
                     WRITE (ipr,99065) (X(j),j=jmin,jmax)
99065                FORMAT (' ',10(F12.1,1X))
                  ELSEIF ( idecp1==3 ) THEN
                     WRITE (ipr,99066) (X(j),j=jmin,jmax)
99066                FORMAT (' ',10(F12.2,1X))
                  ELSEIF ( idecp1==4 ) THEN
                     WRITE (ipr,99067) (X(j),j=jmin,jmax)
99067                FORMAT (' ',10(F12.3,1X))
                  ELSEIF ( idecp1==5 ) THEN
                     WRITE (ipr,99068) (X(j),j=jmin,jmax)
99068                FORMAT (' ',10(F12.4,1X))
                  ELSEIF ( idecp1==6 ) THEN
                     WRITE (ipr,99069) (X(j),j=jmin,jmax)
99069                FORMAT (' ',10(F12.5,1X))
                  ELSEIF ( idecp1==7 ) THEN
                     WRITE (ipr,99070) (X(j),j=jmin,jmax)
99070                FORMAT (' ',10(F12.6,1X))
                  ELSEIF ( idecp1==8 ) THEN
                     WRITE (ipr,99071) (X(j),j=jmin,jmax)
99071                FORMAT (' ',10(F12.7,1X))
                  ELSEIF ( idecp1==9 ) THEN
                     WRITE (ipr,99072) (X(j),j=jmin,jmax)
99072                FORMAT (' ',10(F12.8,1X))
                  ELSEIF ( idecp1==10 ) THEN
                     WRITE (ipr,99073) (X(j),j=jmin,jmax)
99073                FORMAT (' ',10(F12.9,1X))
                  ELSEIF ( idecp1==11 ) THEN
                     WRITE (ipr,99074) (X(j),j=jmin,jmax)
99074                FORMAT (' ',10(F12.10,1X))
                  ELSE
                     WRITE (ipr,99009) (X(j),j=jmin,jmax)
                  ENDIF
!
 50               i50 = i - 50*(i/50)
                  IF ( i50==0 ) WRITE (ipr,99076)
                  IF ( i50/=0 ) THEN
                     i10 = i - 10*(i/10)
                     IF ( i10==0 ) WRITE (ipr,99077)
                  ENDIF
               ENDDO
            ENDIF
         ENDIF
      ENDIF
99075 FORMAT (' ','***** THE VALUE OF THE ARGUMENT IS ',I8,' *****')
99076 FORMAT ('1')
99077 FORMAT (' ')
      END SUBROUTINE WRITE
end module M_datapac
