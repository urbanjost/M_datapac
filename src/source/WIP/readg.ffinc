$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT --file readg.3m_datapac.man
NAME
   readg(3f) - [M_datapac:STATISTICS] perform a format-free read of data
   from a file restricted to a user-specified set of columns

SYNOPSIS
      SUBROUTINE READG(Ird,Icol1,Icol2,X,N)

DESCRIPTION

   readg(3f) performs a format-free read of data from input unit = ird.

   only the card columns between icol1 and icol2 (inclusively) are
   scanned for the read.

   readg(3f) is identical to the read subroutine except that the read
   subroutine assumes input unit 5, whereas this readg subroutine allows
   the analyst to specify the input unit.

   readg(3f) gives the data analyst the ability to get data into the
   machine from a variety of input sources (card, tape, disc, etc.)
   without having to worry about and specify formats.

   the data card images may be made without regard to any particular
   format and may be entered into the machine without defining any
   formats.

OPTIONS
    X   description of parameter
    Y   description of parameter

EXAMPLES
  Sample program:

   program demo_readg
   use M_datapac, only : readg
   implicit none
   character(len=*),parameter ::  g='(*(g0,1x))'
   ! call readg(x,y)
   end program demo_readg

  Results:

AUTHOR
   The original DATAPAC library was written by James Filliben of the Statistical
   Engineering Division, National Institute of Standards and Technology.
MAINTAINER
   John Urban, 2022.05.31
LICENSE
   CC0-1.0
$ENDBLOCK
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!*==readg.f90  processed by SPAG 7.51RB at 12:54 on 18 Mar 2022
      SUBROUTINE READG(Ird,Icol1,Icol2,X,N)
INTEGER :: i , Icol1 , Icol2 , iend , ipower , Ird , istart ,  &
     &        istop , j , jp1 , jp2 , jrev , k , l , locpt , maxcol ,   &
     &        mincol , N , nc
INTEGER :: ncp1 , ndp , numcrd , numdec , numint
REAL(kind=wp) :: sum , X , y
!
!     INPUT ARGUMENTS--IRD    = THE INTEGER VALUE SPECIFYING
!                                THE INPUT UNIT FROM WHICH
!                                THE CARD IMAGES WILL COME.
!                     --ICOL1  = THE INTEGER CARD COLUMN NUMBER
!                                WHICH DEFINES THE LOWER BOUND
!                                (INCLUSIVELY) OF THE INTERVAL
!                                ON EACH CARD IMAGE TO BE SCANNED
!                                FOR THE READ.
!                     --ICOL2  = THE INTEGER CARD COLUMN NUMBER
!                                WHICH DEFINES THE UPPER BOUND
!                                (INCLUSIVELY) OF THE INTERVAL
!                                ON EACH CARD IMAGE TO BE SCANNED
!                                FOR THE READ.
!     OUTPUT ARGUMENTS--X      = THE SINGLE PRECISION VECTOR
!                                INTO WHICH THE READ DATA VALUES
!                                WILL BE SEQUENTIALLY PLACED.
!                     --N      = THE INTEGER VALUE
!                                WHICH WILL EQUAL THE NUMBER OF DATA
!                                VALUES WHICH WERE READ.
!     OUTPUT--THE SINGLE PRECISION VECTOR X WHICH
!             WILL CONTAIN THE READ
!             DATA VALUES, AND
!             THE INTEGER VALUE N WHICH WILL
!             EQUAL THE NUMBER OF DATA VALUES
!             READ INTO X.
!             ALSO, 7 LINES OF SUMMARY INFORMATION
!             WILL BE GENERATED--
!             REGARDING WHAT WAS IN FACT READ INTO THE MACHINE--
!             1) THE VALUES OF ICOL1 AND ICOL2;
!             2) THE (ENTIRE) FIRST DATA CARD READ;
!             3) THE (ENTIRE) LAST DATA CARD READ;
!             4) THE TOTAL NUMBER OF DATA CARDS READ;
!             5) THE TOTAL NUMBER OF DATA VALUES READ.
!     PRINTING--YES.
!     RESTRICTIONS--ICOL1 AND ICOL2 MUST BE BETWEEN 1 AND 80,
!                   INCLUSIVELY.
!     MODE OF INTERNAL OPERATIONS--SINGLE PRECISION.
!     COMMENT--ADJACENT DATA VALUES ON THE SAME CARD
!              MUST BE SEPARATED BY AT LEAST 1 BLANK
!              OR 1 ALPHABETIC CHARACTER, OR BY  ANY
!              COMBINATION OF BLANKS AND ALPHABETIC
!              CHARACTERS.  IN THIS CONTEXT, AN
!              ALPHABETIC CHARACTER IS ANY CHARACTER
!              OTHER THAN 0, 1, 2, ..., 9, +, -, OR ..
!              IN EFFECT, THEREFORE, ALL ALPHABETIC INFORMATION
!              IN THE INTERVAL DEFINED BY ICOL1 AND ICOL2
!              (INCLUSIVELY) IS IGNORED FOR READING PURPOSES.
!              ALL INFORMATION (BOTH NUMERIC AND ALPHABETIC)
!              OUTSIDE THE DEFINED INTERVAL IS ALSO IGNORED
!              FOR READING PURPOSES.
!     COMMENT--THE DATA VALUES ON THE CARDS ARE FREE-FORMAT.
!              THEY MAY BE EITHER INTEGER OR FLOATING POINT
!              (THAT IS, WITHOUT OR WITH THE DECIMAL POINTS).
!              EXPONENTIAL FLOATING POINT FORMAT (E FORMAT)
!              IS NOT PERMITTED.
!              ALL DATA, WHETHER WITHOUT OR WITH THE DECIMAL POINT
!              ON THE CARDS, WILL BE READ INTO THE MACHINE
!              INTO THE X VECTOR AND WILL RESIDE THERE AS FLOATING
!              POINT NUMBERS.
!     COMMENT--ANY PARTICULAR DATA VALUE MUST START AND END
!              ON THE SAME DATA CARD; DATA VALUES MAY NOT
!              START ON ONE CARD AND FINISH ON THE NEXT.
!              VARIOUS ILLEGAL COMBINATIONS (SUCH AS
!              MULTIPLE DECIMAL POINTS, MULTIPLE PLUSSES OR
!              MINUSES, INCOMPLETE VALUES CONSISTING ONLY
!              OF A DECIMAL POINT, OR ONLY OF A SIGN AND A DECIMAL
!              POINT, ETC. ARE NOT ACCEPTED AND THE
!              DATA ANALYST WILL BE INFORMED OF THE EXISTENCE OF
!              SUCH BY AN ERROR DIAGNOSTIC.
!              IN THE EVENT OF SUCH AN ILLEGAL COMBINATION,
!              THAT 'NUMBER' AND ALL REMAINING NUMBERS ON THAT CARD WILL
!              WILL BE IGNORED (NOT READ INTO THE MACHINE)
!              AND THE NEXT DATA CARD WILL THEN
!              BE READ.
!     COMMENT--THIS SUBROUTINE WILL CONTINUOUSLY AND
!              SEQUENTIALLY READ CARDS UNTIL A CARD WITH
!              THE WORD         END       (SOMEWHERE BETWEEN
!              COLUMNS ICOL1 AND ICOL2 (INCLUSIVELY)
!              IS ENCOUNTERED.
!              TO TERMINATE A DATA SET, THE ANALYST SHOULD
!              APPEND SUCH A CARD WHICH HAS THE WORD
!              END        SOMEWHERE IN THE INTERVAL
!              DEFINED BY ICOL1 AND ICOL2.
!              FOR EXAMPLE, IF ICOL1 = 1 AND ICOL2 = 20,
!              THEN A SEPARATE CARD WITH     END
!              IN COLUMNS 1, 2, AND 3, OR
!              IN COLUMNS 10, 11, AND 12, ETC.
!              WOULD TERMINATE THE READ.
!              IT IS IMPORTANT TO APPEND SUCH A CARD--
!              FAILURE TO DO SO WILL RESULT IN AN INCOMPLETE
!              DATA SET OR (ON SOME COMPUTERS) AN
!              UNPREDICTABLE RUN TERMINATION.
!     ORIGINAL VERSION--DECEMBER  1972.
!     UPDATED         --AUGUST    1974.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --OCTOBER   1976.
!
!---------------------------------------------------------------------
!
CHARACTER(len=4) :: plus , minus , point , blank
CHARACTER(len=4) :: alphae , alphan , alphad
CHARACTER(len=4) :: ic
CHARACTER(len=4) :: ia
CHARACTER(len=4) :: ichar
CHARACTER(len=4) :: istor1
CHARACTER(len=4) :: istor2
!
      DIMENSION X(:)
      DIMENSION ia(80) , ichar(41) , ic(10)
      DIMENSION istor1(80) , istor2(80)
!
      DATA plus , minus , point , blank/'+' , '-' , '.' , ' '/
      DATA alphae , alphan , alphad/'E' , 'N' , 'D'/
      DATA ic(1) , ic(2) , ic(3) , ic(4) , ic(5) , ic(6) , ic(7) ,      &
     &     ic(8) , ic(9) , ic(10)/'0' , '1' , '2' , '3' , '4' , '5' ,   &
     &     '6' , '7' , '8' , '9'/
!
      N = 0
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      mincol = Icol1
      maxcol = Icol2
      IF ( Icol2<Icol1 ) mincol = Icol2
      IF ( Icol2<Icol1 ) maxcol = Icol1
      IF ( mincol<1 .OR. maxcol>80 ) THEN
         WRITE (G_IO,99001)
99001    FORMAT (' ',                                                   &
     &'***** FATAL ERROR--THE FIRST OR SECOND (OR BOTH) INPUT ARGUMENT T&
     &O THE READG  SUBROUTINE IS OUTSIDE THE')
         WRITE (G_IO,99002)
99002    FORMAT (' ','      ALLOWABLE (1,80) INTERVAL *****')
         WRITE (G_IO,99003) Icol1 , Icol2
99003    FORMAT (' ','***** THE VALUE OF THE FIRST ARGUMENT IS ',I7,    &
     &           '  AND THE VALUE OF THE SECOND ARGUMENT IS ',I7,       &
     &           ' *****')
         RETURN
      ELSE
!
!-----START POINT-----------------------------------------------------
!
!
         numcrd = 0
      ENDIF
 100  READ (Ird,99004,END=700) (ia(i),i=1,80)
99004 FORMAT (80A1)
      DO j = 1 , 78
         IF ( ia(j)==alphae ) THEN
            jp1 = j + 1
            IF ( ia(jp1)==alphan ) THEN
               jp2 = j + 2
               IF ( ia(jp2)==alphad ) GOTO 700
            ENDIF
         ENDIF
      ENDDO
      numcrd = numcrd + 1
      IF ( numcrd==1 ) THEN
         DO j = 1 , 80
            istor1(j) = ia(j)
            istor2(j) = ia(j)
         ENDDO
      ELSE
         DO j = 1 , 80
            istor2(j) = ia(j)
         ENDDO
      ENDIF
      i = mincol
!
 200  DO j = 1 , 41
         ichar(j) = blank
      ENDDO
      nc = 0
      ndp = 0
 300  DO
         DO j = 1 , 10
            IF ( ia(i)==ic(j) ) GOTO 400
         ENDDO
         IF ( ia(i)==plus ) THEN
!
            IF ( nc==0 ) THEN
               nc = 1
               ichar(nc) = ia(i)
               i = i + 1
               IF ( i>maxcol ) THEN
                  WRITE (G_IO,99024)
                  WRITE (G_IO,99005)
99005             FORMAT (' ',                                          &
     &'***** INPUT    DATA ERROR--THE LAST DATA VALUE ON THE CARD BELOW &
     &CONSISTS OF ONLY A PLUS *****')
                  WRITE (G_IO,99025)
                  WRITE (G_IO,99026) numcrd
                  WRITE (G_IO,99027) (ia(j),j=1,80)
                  WRITE (G_IO,99024)
                  GOTO 100
               ENDIF
            ELSE
               WRITE (G_IO,99024)
               WRITE (G_IO,99006)
99006          FORMAT (' ',                                             &
     &'***** INPUT    DATA ERROR--A PLUS HAS OCCURRED IN THE MIDDLE OF S&
     &OME DATA VALUE ON THE CARD BELOW *****')
               WRITE (G_IO,99025)
               WRITE (G_IO,99026) numcrd
               WRITE (G_IO,99027) (ia(j),j=1,80)
               WRITE (G_IO,99024)
               GOTO 100
            ENDIF
         ELSEIF ( ia(i)==minus ) THEN
!
            IF ( nc==0 ) THEN
               nc = 1
               ichar(nc) = ia(i)
               i = i + 1
               IF ( i>maxcol ) THEN
                  WRITE (G_IO,99024)
                  WRITE (G_IO,99007)
99007             FORMAT (' ',                                          &
     &'***** INPUT     DATA ERROR--THE LAST DATA VALUE ON HE CARD BELOW &
     &CONSISTS OF ONLY A MINUS *****')
                  WRITE (G_IO,99025)
                  WRITE (G_IO,99026) numcrd
                  WRITE (G_IO,99027) (ia(j),j=1,80)
                  WRITE (G_IO,99024)
                  GOTO 100
               ENDIF
            ELSE
               WRITE (G_IO,99024)
               WRITE (G_IO,99008)
99008          FORMAT (' ',                                             &
     &'***** INPUT     DATA ERROR--A MINUS HAS OCCURRED INTHE MIDDLE OF &
     &SOME DATA VALUE ON THE CARD BELOW *****')
               WRITE (G_IO,99025)
               WRITE (G_IO,99026) numcrd
               WRITE (G_IO,99027) (ia(j),j=1,80)
               WRITE (G_IO,99024)
               GOTO 100
            ENDIF
         ELSEIF ( ia(i)==point ) THEN
!
            IF ( nc==0 ) THEN
               nc = 1
               ichar(nc) = plus
               nc = 2
               ichar(nc) = ia(i)
               ndp = ndp + 1
               i = i + 1
               IF ( i>maxcol ) THEN
                  WRITE (G_IO,99024)
                  WRITE (G_IO,99009)
99009             FORMAT (' ',                                          &
     &'***** INPUT     DATA ERROR--THE LAST DATA VALUE ON HE CARD BELOW &
     &CONSISTS OF ONLY A DECIMAL POINT *****')
                  WRITE (G_IO,99025)
                  WRITE (G_IO,99026) numcrd
                  WRITE (G_IO,99027) (ia(j),j=1,80)
                  WRITE (G_IO,99024)
                  GOTO 100
               ENDIF
            ELSEIF ( nc==1 ) THEN
               nc = 2
               ichar(nc) = ia(i)
               ndp = ndp + 1
               i = i + 1
               IF ( i>maxcol ) THEN
                  WRITE (G_IO,99024)
                  WRITE (G_IO,99010)
99010             FORMAT (' ',                                          &
     &'***** INPUT     DATA ERROR--THE LAST DATA VALUE ON HE CARD BELOW &
     &CONSISTS OF ONLY A      +.     OR OF ONLY A      -.    *****')
                  WRITE (G_IO,99025)
                  WRITE (G_IO,99026) numcrd
                  WRITE (G_IO,99027) (ia(j),j=1,80)
                  WRITE (G_IO,99024)
                  GOTO 100
               ENDIF
            ELSEIF ( ndp==0 ) THEN
               nc = nc + 1
               ichar(nc) = ia(i)
               ndp = ndp + 1
               i = i + 1
               IF ( i>maxcol ) THEN
                  iend = 1
                  GOTO 500
               ENDIF
            ELSE
               WRITE (G_IO,99024)
               WRITE (G_IO,99011)
99011          FORMAT (' ',                                             &
     &'***** INPUT     DATA ERROR--SOME DATA VALUE ON THE ARD BELOW HAS &
     &MULTIPLE DECIMAL POINTS *****')
               WRITE (G_IO,99025)
               WRITE (G_IO,99026) numcrd
               WRITE (G_IO,99027) (ia(j),j=1,80)
               WRITE (G_IO,99024)
               GOTO 100
            ENDIF
         ELSEIF ( nc==0 ) THEN
!
            i = i + 1
            IF ( i>maxcol ) GOTO 100
         ELSEIF ( nc==1 ) THEN
!
            WRITE (G_IO,99024)
            WRITE (G_IO,99012)
99012       FORMAT (' ',                                                &
     &'***** INPUT     DATA ERROR--SOME DATA VALUE ON THE ARD BELOW CONS&
     &ISTS OF ONLY A PLUS OR OF ONLY A MINUS *****')
            WRITE (G_IO,99025)
            WRITE (G_IO,99026) numcrd
            WRITE (G_IO,99027) (ia(j),j=1,80)
            WRITE (G_IO,99024)
            GOTO 100
         ELSEIF ( nc==2 ) THEN
!
            IF ( ichar(1)==plus .AND. ichar(2)==point ) THEN
               WRITE (G_IO,99024)
               WRITE (G_IO,99013)
99013          FORMAT (' ',                                             &
     &'***** INPUT     DATA ERROR--SOME DATA VALUE ON THE ARD BELOW CONS&
     &ISTS OF ONLY A      +.     *****')
               WRITE (G_IO,99025)
               WRITE (G_IO,99026) numcrd
               WRITE (G_IO,99027) (ia(j),j=1,80)
               WRITE (G_IO,99024)
               GOTO 100
            ELSEIF ( ichar(1)==minus .AND. ichar(2)==point ) THEN
               WRITE (G_IO,99024)
               WRITE (G_IO,99014)
99014          FORMAT (' ',                                             &
     &'***** INPUT     DATA ERROR--SOME DATA VALUE ON THE ARD BELOW CONS&
     &ISTS OF ONLY A      -.     *****')
               WRITE (G_IO,99025)
               WRITE (G_IO,99026) numcrd
               WRITE (G_IO,99027) (ia(j),j=1,80)
               WRITE (G_IO,99024)
               GOTO 100
            ELSE
               iend = 0
               GOTO 500
            ENDIF
         ELSE
            iend = 0
            GOTO 500
         ENDIF
      ENDDO
!
 400  IF ( nc==0 ) THEN
         nc = 1
         ichar(nc) = plus
      ENDIF
      nc = nc + 1
      ichar(nc) = ia(i)
      i = i + 1
      IF ( i<=maxcol ) GOTO 300
      iend = 1
!
!
!
 500  DO j = 2 , nc
         IF ( ichar(j)==point ) GOTO 600
      ENDDO
      j = nc + 1
      ncp1 = nc + 1
      ichar(ncp1) = point
      nc = ncp1
!
 600  locpt = j
      numint = j - 2
      numdec = nc - j
      sum = 0.0_wp
      IF ( numint/=0 ) THEN
         istart = 2
         istop = numint + 1
         ipower = -1
         DO j = istart , istop
            jrev = istop - j + 2
            DO k = 1 , 10
               IF ( ichar(jrev)==ic(k) ) GOTO 620
            ENDDO
            WRITE (G_IO,99024)
            WRITE (G_IO,99015)
99015       FORMAT (' ',                                                &
     &'***** PROGRAMMING ERROR IN THE READG  SUBROUTINE-- A NON-NUMERIC &
     &CHARACTER WAS ENCOUNTERED IN CONVERTING THE INTEGER PART')
            WRITE (G_IO,99028) (ichar(l),l=1,41)
            WRITE (G_IO,99027) (ia(l),l=1,80)
            WRITE (G_IO,99026) numcrd
            WRITE (G_IO,99024)
            RETURN
!
 620        y = k - 1
            ipower = ipower + 1
            sum = sum + y*(10.0_wp**ipower)
         ENDDO
      ENDIF
!
      IF ( numdec/=0 ) THEN
         istart = locpt + 1
         istop = nc
         ipower = 0
         DO j = istart , istop
            DO k = 1 , 10
               IF ( ichar(j)==ic(k) ) GOTO 640
            ENDDO
            WRITE (G_IO,99024)
            WRITE (G_IO,99016)
99016       FORMAT (' ',                                                &
     &'***** PROGRAMMING ERROR IN THE READG  SUBROUTINE-- A NON-NUMERIC &
     &CHARACTER WAS ENCOUNTERED IN CONVERTING THE DECIMAL PART')
            WRITE (G_IO,99028) (ichar(l),l=1,41)
            WRITE (G_IO,99027) (ia(l),l=1,80)
            WRITE (G_IO,99026) numcrd
            WRITE (G_IO,99024)
            RETURN
!
 640        y = k - 1
            ipower = ipower + 1
            sum = sum + y/(10.0_wp**ipower)
         ENDDO
      ENDIF
!
      IF ( ichar(1)==minus ) sum = -sum
      N = N + 1
      X(N) = sum
      IF ( iend==1 ) GOTO 100
      i = i + 1
      IF ( i>maxcol ) GOTO 100
      GOTO 200
 700  WRITE (G_IO,99024)
      IF ( numcrd/=0 ) THEN
         WRITE (G_IO,99017)
99017    FORMAT (' ','OUTPUT FROM THE READG  SUBROUTINE--')
         WRITE (G_IO,99018) Ird
99018    FORMAT (' ','THE INPUT UNIT DEVICE NUMBER = ',I7)
         WRITE (G_IO,99019) mincol , maxcol
99019    FORMAT (' ',                                                   &
     &     'THE SCANNING INTERVAL FOR EACH DATA CARD IMAGE WAS COLUMN  '&
     &     ,I3,' THROUGH COLUMN  ',I3,' (INCLUSIVE)')
         WRITE (G_IO,99020) (istor1(j),j=1,80)
99020    FORMAT (' ','THE (ENTIRE) FIRST  DATA CARD IMAGE   READ WAS ', &
     &           80A1)
         WRITE (G_IO,99021) (istor2(j),j=1,80)
99021    FORMAT (' ','THE (ENTIRE) LAST   DATA CARD IMAGE   READ WAS ', &
     &           80A1)
      ENDIF
      WRITE (G_IO,99022) numcrd
99022 FORMAT (' ','THE TOTAL NUMBER OF DATA CARD IMAGES  READ WAS ',I7)
      WRITE (G_IO,99023) N
99023 FORMAT (' ','THE TOTAL NUMBER (= N) OF DATA VALUES READ WAS ',I7)
      WRITE (G_IO,99024)
      WRITE (G_IO,99024)
      RETURN
!
99024 FORMAT (' ')
99025 FORMAT (' ',                                                      &
     &'      THIS ILLEGAL DATA VALUE AND ALL SUBSEQUENT DATA VALUES ON T&
     &HIS CARD IMAGE (ONLY) HAVE BEEN DELETED')
99026 FORMAT (' ','      THIS CARD IMAGE WAS THE ',I7,                  &
     &        '-TH DATA CARD IMAGE THAT WAS READ')
99027 FORMAT (' ','      THE CARD IMAGE IS AS FOLLOWS--   ',80A1)
99028 FORMAT (' ','      OF THE FOLLOWING DATA VALUE--   ',41A1)
!
END SUBROUTINE READG
